// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

internal class <Module>
{
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class DisplayNameAttribute : Attribute
	{
		public readonly string displayName;

		public DisplayNameAttribute(string displayName)
		{
			this.displayName = displayName;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class MaxAttribute : Attribute
	{
		public readonly float max;

		public MaxAttribute(float max)
		{
			this.max = max;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class MinAttribute : Attribute
	{
		public readonly float min;

		public MinAttribute(float min)
		{
			this.min = min;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class MinMaxAttribute : Attribute
	{
		public readonly float min;

		public readonly float max;

		public MinMaxAttribute(float min, float max)
		{
			this.min = min;
			this.max = max;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
	public sealed class PostProcessAttribute : Attribute
	{
		public readonly Type renderer;

		public readonly PostProcessEvent eventType;

		public readonly string menuItem;

		public readonly bool allowInSceneView;

		internal readonly bool builtinEffect;

		public PostProcessAttribute(Type renderer, PostProcessEvent eventType, string menuItem, bool allowInSceneView = true)
		{
			this.renderer = renderer;
			this.eventType = eventType;
			this.menuItem = menuItem;
			this.allowInSceneView = allowInSceneView;
			this.builtinEffect = false;
		}

		internal PostProcessAttribute(Type renderer, string menuItem, bool allowInSceneView = true)
		{
			this.renderer = renderer;
			this.menuItem = menuItem;
			this.allowInSceneView = allowInSceneView;
			this.builtinEffect = true;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class TrackballAttribute : Attribute
	{
		public enum Mode
		{
			None,
			Lift,
			Gamma,
			Gain
		}

		public readonly TrackballAttribute.Mode mode;

		public TrackballAttribute(TrackballAttribute.Mode mode)
		{
			this.mode = mode;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum AmbientOcclusionMode
	{
		ScalableAmbientObscurance,
		MultiScaleVolumetricObscurance
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum AmbientOcclusionQuality
	{
		Lowest,
		Low,
		Medium,
		High,
		Ultra
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class AmbientOcclusionModeParameter : ParameterOverride<AmbientOcclusionMode>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class AmbientOcclusionQualityParameter : ParameterOverride<AmbientOcclusionQuality>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(AmbientOcclusionRenderer), "Unity/Ambient Occlusion", true)]
	[Serializable]
	public sealed class AmbientOcclusion : PostProcessEffectSettings
	{
		[Tooltip("The ambient occlusion method to use. \"MSVO\" is higher quality and faster on desktop & console platforms but requires compute shader support.")]
		public AmbientOcclusionModeParameter mode = new AmbientOcclusionModeParameter
		{
			value = AmbientOcclusionMode.MultiScaleVolumetricObscurance
		};

		[Range(0f, 4f), Tooltip("Degree of darkness added by ambient occlusion.")]
		public FloatParameter intensity = new FloatParameter
		{
			value = 0f
		};

		[ColorUsage(false), Tooltip("Custom color to use for the ambient occlusion.")]
		public ColorParameter color = new ColorParameter
		{
			value = Color.black
		};

		[Tooltip("Only affects ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering. Objects rendered with the Forward rendering path won't get any ambient occlusion.")]
		public BoolParameter ambientOnly = new BoolParameter
		{
			value = true
		};

		[Range(-8f, 0f)]
		public FloatParameter noiseFilterTolerance = new FloatParameter
		{
			value = 0f
		};

		[Range(-8f, -1f)]
		public FloatParameter blurTolerance = new FloatParameter
		{
			value = -4.6f
		};

		[Range(-12f, -1f)]
		public FloatParameter upsampleTolerance = new FloatParameter
		{
			value = -12f
		};

		[Range(1f, 10f), Tooltip("Modifies thickness of occluders. This increases dark areas but also introduces dark halo around objects.")]
		public FloatParameter thicknessModifier = new FloatParameter
		{
			value = 1f
		};

		[Range(0f, 1f), Tooltip("")]
		public FloatParameter directLightingStrength = new FloatParameter
		{
			value = 0f
		};

		[Tooltip("Radius of sample points, which affects extent of darkened areas.")]
		public FloatParameter radius = new FloatParameter
		{
			value = 0.25f
		};

		[Tooltip("Number of sample points, which affects quality and performance. Lowest, Low & Medium passes are downsampled. High and Ultra are not and should only be used on high-end hardware.")]
		public AmbientOcclusionQualityParameter quality = new AmbientOcclusionQualityParameter
		{
			value = AmbientOcclusionQuality.Medium
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			bool flag = this.enabled.value && this.intensity.value > 0f;
			if (this.mode.value == AmbientOcclusionMode.ScalableAmbientObscurance)
			{
				flag &= !RuntimeUtilities.scriptableRenderPipelineActive;
			}
			else if (this.mode.value == AmbientOcclusionMode.MultiScaleVolumetricObscurance)
			{
				flag &= (SystemInfo.supportsComputeShaders && RenderTextureFormat.RFloat.IsSupported() && RenderTextureFormat.RHalf.IsSupported() && RenderTextureFormat.R8.IsSupported());
			}
			return flag;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public interface IAmbientOcclusionMethod
	{
		DepthTextureMode GetCameraFlags();

		void RenderAfterOpaque(PostProcessRenderContext context);

		void RenderAmbientOnly(PostProcessRenderContext context);

		void CompositeAmbientOnly(PostProcessRenderContext context);

		void Release();
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class AmbientOcclusionRenderer : PostProcessEffectRenderer<AmbientOcclusion>
	{
		private IAmbientOcclusionMethod[] m_Methods;

		public override void Init()
		{
			if (this.m_Methods == null)
			{
				this.m_Methods = new IAmbientOcclusionMethod[]
				{
					new ScalableAO(base.settings),
					new MultiScaleVO(base.settings)
				};
			}
		}

		public bool IsAmbientOnly(PostProcessRenderContext context)
		{
			Camera camera = context.camera;
			return base.settings.ambientOnly.value && camera.actualRenderingPath == RenderingPath.DeferredShading && camera.allowHDR;
		}

		public IAmbientOcclusionMethod Get()
		{
			return this.m_Methods[(int)base.settings.mode.value];
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return this.Get().GetCameraFlags();
		}

		public override void Release()
		{
			IAmbientOcclusionMethod[] methods = this.m_Methods;
			for (int i = 0; i < methods.Length; i++)
			{
				IAmbientOcclusionMethod ambientOcclusionMethod = methods[i];
				ambientOcclusionMethod.Release();
			}
		}

		public ScalableAO GetScalableAO()
		{
			return (ScalableAO)this.m_Methods[0];
		}

		public MultiScaleVO GetMultiScaleVO()
		{
			return (MultiScaleVO)this.m_Methods[1];
		}

		public override void Render(PostProcessRenderContext context)
		{
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum EyeAdaptation
	{
		Progressive,
		Fixed
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class EyeAdaptationParameter : ParameterOverride<EyeAdaptation>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(AutoExposureRenderer), "Unity/Auto Exposure", true)]
	[Serializable]
	public sealed class AutoExposure : PostProcessEffectSettings
	{
		[DisplayName("Filtering (%)"), MinMax(1f, 99f), Tooltip("Filters the bright & dark part of the histogram when computing the average luminance to avoid very dark pixels & very bright pixels from contributing to the auto exposure. Unit is in percent.")]
		public Vector2Parameter filtering = new Vector2Parameter
		{
			value = new Vector2(50f, 95f)
		};

		[Range(-9f, 9f), DisplayName("Minimum (EV)"), Tooltip("Minimum average luminance to consider for auto exposure (in EV).")]
		public FloatParameter minLuminance = new FloatParameter
		{
			value = 0f
		};

		[Range(-9f, 9f), DisplayName("Maximum (EV)"), Tooltip("Maximum average luminance to consider for auto exposure (in EV).")]
		public FloatParameter maxLuminance = new FloatParameter
		{
			value = 0f
		};

		[Min(0f), Tooltip("Exposure bias. Use this to offset the global exposure of the scene.")]
		public FloatParameter keyValue = new FloatParameter
		{
			value = 1f
		};

		[DisplayName("Type"), Tooltip("Use \"Progressive\" if you want auto exposure to be animated. Use \"Fixed\" otherwise.")]
		public EyeAdaptationParameter eyeAdaptation = new EyeAdaptationParameter
		{
			value = EyeAdaptation.Progressive
		};

		[Min(0f), Tooltip("Adaptation speed from a dark to a light environment.")]
		public FloatParameter speedUp = new FloatParameter
		{
			value = 2f
		};

		[Min(0f), Tooltip("Adaptation speed from a light to a dark environment.")]
		public FloatParameter speedDown = new FloatParameter
		{
			value = 1f
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && SystemInfo.supportsComputeShaders && RenderTextureFormat.RFloat.IsSupported();
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class AutoExposureRenderer : PostProcessEffectRenderer<AutoExposure>
	{
		private const int k_NumEyes = 2;

		private const int k_NumAutoExposureTextures = 2;

		private readonly RenderTexture[][] m_AutoExposurePool = new RenderTexture[2][];

		private int[] m_AutoExposurePingPong = new int[2];

		private RenderTexture m_CurrentAutoExposure;

		public AutoExposureRenderer()
		{
			for (int i = 0; i < 2; i++)
			{
				this.m_AutoExposurePool[i] = new RenderTexture[2];
				this.m_AutoExposurePingPong[i] = 0;
			}
		}

		private void CheckTexture(int eye, int id)
		{
			if (this.m_AutoExposurePool[eye][id] == null || !this.m_AutoExposurePool[eye][id].IsCreated())
			{
				this.m_AutoExposurePool[eye][id] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
				this.m_AutoExposurePool[eye][id].Create();
			}
		}

		public override void Render(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("AutoExposureLookup");
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.autoExposure);
			propertySheet.ClearKeywords();
			this.CheckTexture(context.xrActiveEye, 0);
			this.CheckTexture(context.xrActiveEye, 1);
			float num = base.settings.filtering.value.x;
			float num2 = base.settings.filtering.value.y;
			num2 = Mathf.Clamp(num2, 1.01f, 99f);
			num = Mathf.Clamp(num, 1f, num2 - 0.01f);
			float value = base.settings.minLuminance.value;
			float value2 = base.settings.maxLuminance.value;
			base.settings.minLuminance.value = Mathf.Min(value, value2);
			base.settings.maxLuminance.value = Mathf.Max(value, value2);
			propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, context.logHistogram.data);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(num * 0.01f, num2 * 0.01f, RuntimeUtilities.Exp2(base.settings.minLuminance.value), RuntimeUtilities.Exp2(base.settings.maxLuminance.value)));
			propertySheet.properties.SetVector(ShaderIDs.Speed, new Vector2(base.settings.speedDown.value, base.settings.speedUp.value));
			propertySheet.properties.SetVector(ShaderIDs.ScaleOffsetRes, context.logHistogram.GetHistogramScaleOffsetRes(context));
			propertySheet.properties.SetFloat(ShaderIDs.ExposureCompensation, base.settings.keyValue.value);
			if (this.m_ResetHistory || !Application.isPlaying)
			{
				this.m_CurrentAutoExposure = this.m_AutoExposurePool[context.xrActiveEye][0];
				command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, this.m_CurrentAutoExposure, propertySheet, 1, false);
				RuntimeUtilities.CopyTexture(command, this.m_AutoExposurePool[context.xrActiveEye][0], this.m_AutoExposurePool[context.xrActiveEye][1]);
				this.m_ResetHistory = false;
			}
			else
			{
				int num3 = this.m_AutoExposurePingPong[context.xrActiveEye];
				RenderTexture tex = this.m_AutoExposurePool[context.xrActiveEye][++num3 % 2];
				RenderTexture renderTexture = this.m_AutoExposurePool[context.xrActiveEye][++num3 % 2];
				command.BlitFullscreenTriangle(tex, renderTexture, propertySheet, (int)base.settings.eyeAdaptation.value, false);
				this.m_AutoExposurePingPong[context.xrActiveEye] = (num3 + 1) % 2;
				this.m_CurrentAutoExposure = renderTexture;
			}
			command.EndSample("AutoExposureLookup");
			context.autoExposureTexture = this.m_CurrentAutoExposure;
			context.autoExposure = base.settings;
		}

		public override void Release()
		{
			RenderTexture[][] autoExposurePool = this.m_AutoExposurePool;
			for (int i = 0; i < autoExposurePool.Length; i++)
			{
				RenderTexture[] array = autoExposurePool[i];
				RenderTexture[] array2 = array;
				for (int j = 0; j < array2.Length; j++)
				{
					RenderTexture obj = array2[j];
					RuntimeUtilities.Destroy(obj);
				}
			}
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using UnityEngine.Serialization;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(BloomRenderer), "Unity/Bloom", true)]
	[Serializable]
	public sealed class Bloom : PostProcessEffectSettings
	{
		[Min(0f), Tooltip("Strength of the bloom filter. Values higher than 1 will make bloom contribute more energy to the final render. Keep this under or equal to 1 if you want energy conservation.")]
		public FloatParameter intensity = new FloatParameter
		{
			value = 0f
		};

		[Min(0f), Tooltip("Filters out pixels under this level of brightness. Value is in gamma-space.")]
		public FloatParameter threshold = new FloatParameter
		{
			value = 1f
		};

		[Range(0f, 1f), Tooltip("Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft threshold).")]
		public FloatParameter softKnee = new FloatParameter
		{
			value = 0.5f
		};

		[Range(1f, 10f), Tooltip("Changes the extent of veiling effects. For maximum quality stick to integer values. Because this value changes the internal iteration count, animating it isn't recommended as it may introduce small hiccups in the perceived radius.")]
		public FloatParameter diffusion = new FloatParameter
		{
			value = 7f
		};

		[Range(-1f, 1f), Tooltip("Distorts the bloom to give an anamorphic look. Negative values distort vertically, positive values distort horizontally.")]
		public FloatParameter anamorphicRatio = new FloatParameter
		{
			value = 0f
		};

		[ColorUsage(false, true), Tooltip("Global tint of the bloom filter.")]
		public ColorParameter color = new ColorParameter
		{
			value = Color.white
		};

		[FormerlySerializedAs("mobileOptimized"), Tooltip("Boost performances by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
		public BoolParameter fastMode = new BoolParameter
		{
			value = false
		};

		[DisplayName("Texture"), Tooltip("Dirtiness texture to add smudges or dust to the bloom effect.")]
		public TextureParameter dirtTexture = new TextureParameter
		{
			value = null
		};

		[DisplayName("Intensity"), Min(0f), Tooltip("Amount of dirtiness.")]
		public FloatParameter dirtIntensity = new FloatParameter
		{
			value = 0f
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && this.intensity.value > 0f;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class BloomRenderer : PostProcessEffectRenderer<Bloom>
	{
		private enum Pass
		{
			Prefilter13,
			Prefilter4,
			Downsample13,
			Downsample4,
			UpsampleTent,
			UpsampleBox,
			DebugOverlayThreshold,
			DebugOverlayTent,
			DebugOverlayBox
		}

		private struct Level
		{
			internal int down;

			internal int up;
		}

		private BloomRenderer.Level[] m_Pyramid;

		private const int k_MaxPyramidSize = 16;

		public override void Init()
		{
			this.m_Pyramid = new BloomRenderer.Level[16];
			for (int i = 0; i < 16; i++)
			{
				this.m_Pyramid[i] = new BloomRenderer.Level
				{
					down = Shader.PropertyToID("_BloomMipDown" + i),
					up = Shader.PropertyToID("_BloomMipUp" + i)
				};
			}
		}

		public override void Render(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("BloomPyramid");
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.bloom);
			propertySheet.properties.SetTexture(ShaderIDs.AutoExposureTex, context.autoExposureTexture);
			float num = Mathf.Clamp(base.settings.anamorphicRatio, -1f, 1f);
			float num2 = (num >= 0f) ? 0f : (-num);
			float num3 = (num <= 0f) ? 0f : num;
			int num4 = Mathf.FloorToInt((float)context.screenWidth / (2f - num2));
			int num5 = Mathf.FloorToInt((float)context.screenHeight / (2f - num3));
			int num6 = Mathf.Max(num4, num5);
			float num7 = Mathf.Log((float)num6, 2f) + Mathf.Min(base.settings.diffusion.value, 10f) - 10f;
			int num8 = Mathf.FloorToInt(num7);
			int num9 = Mathf.Clamp(num8, 1, 16);
			float num10 = 0.5f + num7 - (float)num8;
			propertySheet.properties.SetFloat(ShaderIDs.SampleScale, num10);
			float num11 = Mathf.GammaToLinearSpace(base.settings.threshold.value);
			float num12 = num11 * base.settings.softKnee.value + 1E-05f;
			Vector4 value = new Vector4(num11, num11 - num12, num12 * 2f, 0.25f / num12);
			propertySheet.properties.SetVector(ShaderIDs.Threshold, value);
			int num13 = (!base.settings.fastMode) ? 0 : 1;
			RenderTargetIdentifier source = context.source;
			for (int i = 0; i < num9; i++)
			{
				int down = this.m_Pyramid[i].down;
				int up = this.m_Pyramid[i].up;
				int pass = (i != 0) ? (2 + num13) : num13;
				context.GetScreenSpaceTemporaryRT(command, down, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, num4, num5);
				context.GetScreenSpaceTemporaryRT(command, up, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, num4, num5);
				command.BlitFullscreenTriangle(source, down, propertySheet, pass, false);
				source = down;
				num4 = Mathf.Max(num4 / 2, 1);
				num5 = Mathf.Max(num5 / 2, 1);
			}
			int num14 = this.m_Pyramid[num9 - 1].down;
			for (int j = num9 - 2; j >= 0; j--)
			{
				int down2 = this.m_Pyramid[j].down;
				int up2 = this.m_Pyramid[j].up;
				command.SetGlobalTexture(ShaderIDs.BloomTex, down2);
				command.BlitFullscreenTriangle(num14, up2, propertySheet, 4 + num13, false);
				num14 = up2;
			}
			Color linear = base.settings.color.value.linear;
			float num15 = RuntimeUtilities.Exp2(base.settings.intensity.value / 10f) - 1f;
			Vector4 value2 = new Vector4(num10, num15, base.settings.dirtIntensity.value, (float)num9);
			if (context.IsDebugOverlayEnabled(DebugOverlay.BloomThreshold))
			{
				context.PushDebugOverlay(command, context.source, propertySheet, 6);
			}
			else if (context.IsDebugOverlayEnabled(DebugOverlay.BloomBuffer))
			{
				propertySheet.properties.SetVector(ShaderIDs.ColorIntensity, new Vector4(linear.r, linear.g, linear.b, num15));
				context.PushDebugOverlay(command, this.m_Pyramid[0].up, propertySheet, 7 + num13);
			}
			Texture texture = (!(base.settings.dirtTexture.value == null)) ? base.settings.dirtTexture.value : RuntimeUtilities.blackTexture;
			float num16 = (float)texture.width / (float)texture.height;
			float num17 = (float)context.screenWidth / (float)context.screenHeight;
			Vector4 value3 = new Vector4(1f, 1f, 0f, 0f);
			if (num16 > num17)
			{
				value3.x = num17 / num16;
				value3.z = (1f - value3.x) * 0.5f;
			}
			else if (num17 > num16)
			{
				value3.y = num16 / num17;
				value3.w = (1f - value3.y) * 0.5f;
			}
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("BLOOM");
			uberSheet.properties.SetVector(ShaderIDs.Bloom_DirtTileOffset, value3);
			uberSheet.properties.SetVector(ShaderIDs.Bloom_Settings, value2);
			uberSheet.properties.SetColor(ShaderIDs.Bloom_Color, linear);
			uberSheet.properties.SetTexture(ShaderIDs.Bloom_DirtTex, texture);
			command.SetGlobalTexture(ShaderIDs.BloomTex, num14);
			for (int k = 0; k < num9; k++)
			{
				if (this.m_Pyramid[k].down != num14)
				{
					command.ReleaseTemporaryRT(this.m_Pyramid[k].down);
				}
				if (this.m_Pyramid[k].up != num14)
				{
					command.ReleaseTemporaryRT(this.m_Pyramid[k].up);
				}
			}
			command.EndSample("BloomPyramid");
			context.bloomBufferNameID = num14;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using UnityEngine.Serialization;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(ChromaticAberrationRenderer), "Unity/Chromatic Aberration", true)]
	[Serializable]
	public sealed class ChromaticAberration : PostProcessEffectSettings
	{
		[Tooltip("Shift the hue of chromatic aberrations.")]
		public TextureParameter spectralLut = new TextureParameter
		{
			value = null
		};

		[Range(0f, 1f), Tooltip("Amount of tangential distortion.")]
		public FloatParameter intensity = new FloatParameter
		{
			value = 0f
		};

		[FormerlySerializedAs("mobileOptimized"), Tooltip("Boost performances by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
		public BoolParameter fastMode = new BoolParameter
		{
			value = false
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && this.intensity.value > 0f;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class ChromaticAberrationRenderer : PostProcessEffectRenderer<ChromaticAberration>
	{
		private Texture2D m_InternalSpectralLut;

		public override void Render(PostProcessRenderContext context)
		{
			Texture texture = base.settings.spectralLut.value;
			if (texture == null)
			{
				if (this.m_InternalSpectralLut == null)
				{
					this.m_InternalSpectralLut = new Texture2D(3, 1, TextureFormat.RGB24, false)
					{
						name = "Chromatic Aberration Spectrum Lookup",
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0,
						hideFlags = HideFlags.DontSave
					};
					this.m_InternalSpectralLut.SetPixels(new Color[]
					{
						new Color(1f, 0f, 0f),
						new Color(0f, 1f, 0f),
						new Color(0f, 0f, 1f)
					});
					this.m_InternalSpectralLut.Apply();
				}
				texture = this.m_InternalSpectralLut;
			}
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword((!base.settings.fastMode) ? "CHROMATIC_ABERRATION" : "CHROMATIC_ABERRATION_LOW");
			uberSheet.properties.SetFloat(ShaderIDs.ChromaticAberration_Amount, base.settings.intensity * 0.05f);
			uberSheet.properties.SetTexture(ShaderIDs.ChromaticAberration_SpectralLut, texture);
		}

		public override void Release()
		{
			RuntimeUtilities.Destroy(this.m_InternalSpectralLut);
			this.m_InternalSpectralLut = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum GradingMode
	{
		LowDefinitionRange,
		HighDefinitionRange,
		External
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum Tonemapper
	{
		None,
		Neutral,
		ACES,
		Custom
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class GradingModeParameter : ParameterOverride<GradingMode>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class TonemapperParameter : ParameterOverride<Tonemapper>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(ColorGradingRenderer), "Unity/Color Grading", true)]
	[Serializable]
	public sealed class ColorGrading : PostProcessEffectSettings
	{
		[DisplayName("Mode"), Tooltip("Select a color grading mode that fits your dynamic range and workflow. Use HDR if your camera is set to render in HDR and your target platform supports it. Use LDR for low-end mobiles or devices that don't support HDR. Use External if you prefer authoring a Log LUT in external softwares.")]
		public GradingModeParameter gradingMode = new GradingModeParameter
		{
			value = GradingMode.HighDefinitionRange
		};

		[DisplayName("Lookup Texture"), Tooltip("")]
		public TextureParameter externalLut = new TextureParameter
		{
			value = null
		};

		[DisplayName("Mode"), Tooltip("Select a tonemapping algorithm to use at the end of the color grading process.")]
		public TonemapperParameter tonemapper = new TonemapperParameter
		{
			value = Tonemapper.None
		};

		[Range(0f, 1f), DisplayName("Toe Strength"), Tooltip("Affects the transition between the toe and the mid section of the curve. A value of 0 means no toe, a value of 1 means a very hard transition.")]
		public FloatParameter toneCurveToeStrength = new FloatParameter
		{
			value = 0f
		};

		[Range(0f, 1f), DisplayName("Toe Length"), Tooltip("Affects how much of the dynamic range is in the toe. With a small value, the toe will be very short and quickly transition into the linear section, and with a longer value having a longer toe.")]
		public FloatParameter toneCurveToeLength = new FloatParameter
		{
			value = 0.5f
		};

		[Range(0f, 1f), DisplayName("Shoulder Strength"), Tooltip("Affects the transition between the mid section and the shoulder of the curve. A value of 0 means no shoulder, a value of 1 means a very hard transition.")]
		public FloatParameter toneCurveShoulderStrength = new FloatParameter
		{
			value = 0f
		};

		[DisplayName("Shoulder Length"), Min(0f), Tooltip("Affects how many F-stops (EV) to add to the dynamic range of the curve.")]
		public FloatParameter toneCurveShoulderLength = new FloatParameter
		{
			value = 0.5f
		};

		[Range(0f, 1f), DisplayName("Shoulder Angle"), Tooltip("Affects how much overshoot to add to the shoulder.")]
		public FloatParameter toneCurveShoulderAngle = new FloatParameter
		{
			value = 0f
		};

		[DisplayName("Gamma"), Min(0.001f), Tooltip("")]
		public FloatParameter toneCurveGamma = new FloatParameter
		{
			value = 1f
		};

		[DisplayName("Lookup Texture"), Tooltip("Custom log-space lookup texture (strip format, e.g. 1024x32). EXR format is highly recommended or precision will be heavily degraded. Refer to the documentation for more information about how to create such a Lut.")]
		public TextureParameter logLut = new TextureParameter
		{
			value = null
		};

		[DisplayName("Lookup Texture"), Tooltip("Custom lookup texture (strip format, e.g. 256x16) to apply before the rest of the color grading operators. If none is provided, a neutral one will be generated internally.")]
		public TextureParameter ldrLut = new TextureParameter
		{
			value = null
		};

		[Range(-100f, 100f), DisplayName("Temperature"), Tooltip("Sets the white balance to a custom color temperature.")]
		public FloatParameter temperature = new FloatParameter
		{
			value = 0f
		};

		[Range(-100f, 100f), DisplayName("Tint"), Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
		public FloatParameter tint = new FloatParameter
		{
			value = 0f
		};

		[ColorUsage(false, true), DisplayName("Color Filter"), Tooltip("Tint the render by multiplying a color.")]
		public ColorParameter colorFilter = new ColorParameter
		{
			value = Color.white
		};

		[Range(-180f, 180f), DisplayName("Hue Shift"), Tooltip("Shift the hue of all colors.")]
		public FloatParameter hueShift = new FloatParameter
		{
			value = 0f
		};

		[Range(-100f, 100f), DisplayName("Saturation"), Tooltip("Pushes the intensity of all colors.")]
		public FloatParameter saturation = new FloatParameter
		{
			value = 0f
		};

		[Range(-100f, 100f), DisplayName("Brightness"), Tooltip("Makes the image brighter or darker.")]
		public FloatParameter brightness = new FloatParameter
		{
			value = 0f
		};

		[DisplayName("Post-exposure (EV)"), Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
		public FloatParameter postExposure = new FloatParameter
		{
			value = 0f
		};

		[Range(-100f, 100f), DisplayName("Contrast"), Tooltip("Expands or shrinks the overall range of tonal values.")]
		public FloatParameter contrast = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Red"), Tooltip("Modify influence of the red channel in the overall mix.")]
		public FloatParameter mixerRedOutRedIn = new FloatParameter
		{
			value = 100f
		};

		[Range(-200f, 200f), DisplayName("Green"), Tooltip("Modify influence of the green channel in the overall mix.")]
		public FloatParameter mixerRedOutGreenIn = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Blue"), Tooltip("Modify influence of the blue channel in the overall mix.")]
		public FloatParameter mixerRedOutBlueIn = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Red"), Tooltip("Modify influence of the red channel in the overall mix.")]
		public FloatParameter mixerGreenOutRedIn = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Green"), Tooltip("Modify influence of the green channel in the overall mix.")]
		public FloatParameter mixerGreenOutGreenIn = new FloatParameter
		{
			value = 100f
		};

		[Range(-200f, 200f), DisplayName("Blue"), Tooltip("Modify influence of the blue channel in the overall mix.")]
		public FloatParameter mixerGreenOutBlueIn = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Red"), Tooltip("Modify influence of the red channel in the overall mix.")]
		public FloatParameter mixerBlueOutRedIn = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Green"), Tooltip("Modify influence of the green channel in the overall mix.")]
		public FloatParameter mixerBlueOutGreenIn = new FloatParameter
		{
			value = 0f
		};

		[Range(-200f, 200f), DisplayName("Blue"), Tooltip("Modify influence of the blue channel in the overall mix.")]
		public FloatParameter mixerBlueOutBlueIn = new FloatParameter
		{
			value = 100f
		};

		[DisplayName("Lift"), Trackball(TrackballAttribute.Mode.Lift), Tooltip("Controls the darkest portions of the render.")]
		public Vector4Parameter lift = new Vector4Parameter
		{
			value = new Vector4(1f, 1f, 1f, 0f)
		};

		[DisplayName("Gamma"), Trackball(TrackballAttribute.Mode.Gamma), Tooltip("Power function that controls midrange tones.")]
		public Vector4Parameter gamma = new Vector4Parameter
		{
			value = new Vector4(1f, 1f, 1f, 0f)
		};

		[DisplayName("Gain"), Trackball(TrackballAttribute.Mode.Gain), Tooltip("Controls the lightest portions of the render.")]
		public Vector4Parameter gain = new Vector4Parameter
		{
			value = new Vector4(1f, 1f, 1f, 0f)
		};

		public SplineParameter masterCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(new Keyframe[]
			{
				new Keyframe(0f, 0f, 1f, 1f),
				new Keyframe(1f, 1f, 1f, 1f)
			}), 0f, false, new Vector2(0f, 1f))
		};

		public SplineParameter redCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(new Keyframe[]
			{
				new Keyframe(0f, 0f, 1f, 1f),
				new Keyframe(1f, 1f, 1f, 1f)
			}), 0f, false, new Vector2(0f, 1f))
		};

		public SplineParameter greenCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(new Keyframe[]
			{
				new Keyframe(0f, 0f, 1f, 1f),
				new Keyframe(1f, 1f, 1f, 1f)
			}), 0f, false, new Vector2(0f, 1f))
		};

		public SplineParameter blueCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(new Keyframe[]
			{
				new Keyframe(0f, 0f, 1f, 1f),
				new Keyframe(1f, 1f, 1f, 1f)
			}), 0f, false, new Vector2(0f, 1f))
		};

		public SplineParameter hueVsHueCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(), 0.5f, true, new Vector2(0f, 1f))
		};

		public SplineParameter hueVsSatCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(), 0.5f, true, new Vector2(0f, 1f))
		};

		public SplineParameter satVsSatCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(), 0.5f, false, new Vector2(0f, 1f))
		};

		public SplineParameter lumVsSatCurve = new SplineParameter
		{
			value = new Spline(new AnimationCurve(), 0.5f, false, new Vector2(0f, 1f))
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return (this.gradingMode.value != GradingMode.External || (SystemInfo.supports3DRenderTextures && SystemInfo.supportsComputeShaders)) && this.enabled.value;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class ColorGradingRenderer : PostProcessEffectRenderer<ColorGrading>
	{
		private enum Pass
		{
			LutGenLDRFromScratch,
			LutGenLDR,
			LutGenHDR2D
		}

		private Texture2D m_GradingCurves;

		private readonly Color[] m_Pixels = new Color[256];

		private RenderTexture m_InternalLdrLut;

		private RenderTexture m_InternalLogLut;

		private const int k_Lut2DSize = 32;

		private const int k_Lut3DSize = 33;

		private readonly HableCurve m_HableCurve = new HableCurve();

		public override void Render(PostProcessRenderContext context)
		{
			GradingMode value = base.settings.gradingMode.value;
			bool flag = SystemInfo.supports3DRenderTextures && SystemInfo.supportsComputeShaders && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLCore && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES3;
			if (value == GradingMode.External)
			{
				this.RenderExternalPipeline3D(context);
			}
			else if (value == GradingMode.HighDefinitionRange && flag)
			{
				this.RenderHDRPipeline3D(context);
			}
			else if (value == GradingMode.HighDefinitionRange)
			{
				this.RenderHDRPipeline2D(context);
			}
			else
			{
				this.RenderLDRPipeline2D(context);
			}
		}

		private void RenderExternalPipeline3D(PostProcessRenderContext context)
		{
			Texture value = base.settings.externalLut.value;
			if (value == null)
			{
				return;
			}
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("COLOR_GRADING_HDR_3D");
			uberSheet.properties.SetTexture(ShaderIDs.Lut3D, value);
			uberSheet.properties.SetVector(ShaderIDs.Lut3D_Params, new Vector2(1f / (float)value.width, (float)value.width - 1f));
			uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(base.settings.postExposure.value));
			context.logLut = value;
		}

		private void RenderHDRPipeline3D(PostProcessRenderContext context)
		{
			this.CheckInternalLogLut();
			ComputeShader lut3DBaker = context.resources.computeShaders.lut3DBaker;
			int kernelIndex = 0;
			switch (base.settings.tonemapper.value)
			{
			case Tonemapper.None:
				kernelIndex = lut3DBaker.FindKernel("KGenLut3D_NoTonemap");
				break;
			case Tonemapper.Neutral:
				kernelIndex = lut3DBaker.FindKernel("KGenLut3D_NeutralTonemap");
				break;
			case Tonemapper.ACES:
				kernelIndex = lut3DBaker.FindKernel("KGenLut3D_AcesTonemap");
				break;
			case Tonemapper.Custom:
				kernelIndex = lut3DBaker.FindKernel("KGenLut3D_CustomTonemap");
				break;
			}
			int num = Mathf.CeilToInt(4.125f);
			int threadGroupsZ = Mathf.CeilToInt(33f / ((!RuntimeUtilities.isAndroidOpenGL) ? 8f : 2f));
			CommandBuffer command = context.command;
			command.SetComputeTextureParam(lut3DBaker, kernelIndex, "_Output", this.m_InternalLogLut);
			command.SetComputeVectorParam(lut3DBaker, "_Size", new Vector4(33f, 0.03125f, 0f, 0f));
			Vector3 v = ColorUtilities.ComputeColorBalance(base.settings.temperature.value, base.settings.tint.value);
			command.SetComputeVectorParam(lut3DBaker, "_ColorBalance", v);
			command.SetComputeVectorParam(lut3DBaker, "_ColorFilter", base.settings.colorFilter.value);
			float x = base.settings.hueShift.value / 360f;
			float y = base.settings.saturation.value / 100f + 1f;
			float z = base.settings.contrast.value / 100f + 1f;
			command.SetComputeVectorParam(lut3DBaker, "_HueSatCon", new Vector4(x, y, z, 0f));
			Vector4 a = new Vector4(base.settings.mixerRedOutRedIn, base.settings.mixerRedOutGreenIn, base.settings.mixerRedOutBlueIn, 0f);
			Vector4 a2 = new Vector4(base.settings.mixerGreenOutRedIn, base.settings.mixerGreenOutGreenIn, base.settings.mixerGreenOutBlueIn, 0f);
			Vector4 a3 = new Vector4(base.settings.mixerBlueOutRedIn, base.settings.mixerBlueOutGreenIn, base.settings.mixerBlueOutBlueIn, 0f);
			command.SetComputeVectorParam(lut3DBaker, "_ChannelMixerRed", a / 100f);
			command.SetComputeVectorParam(lut3DBaker, "_ChannelMixerGreen", a2 / 100f);
			command.SetComputeVectorParam(lut3DBaker, "_ChannelMixerBlue", a3 / 100f);
			Vector3 vector = ColorUtilities.ColorToLift(base.settings.lift.value * 0.2f);
			Vector3 vector2 = ColorUtilities.ColorToGain(base.settings.gain.value * 0.8f);
			Vector3 vector3 = ColorUtilities.ColorToInverseGamma(base.settings.gamma.value * 0.8f);
			command.SetComputeVectorParam(lut3DBaker, "_Lift", new Vector4(vector.x, vector.y, vector.z, 0f));
			command.SetComputeVectorParam(lut3DBaker, "_InvGamma", new Vector4(vector3.x, vector3.y, vector3.z, 0f));
			command.SetComputeVectorParam(lut3DBaker, "_Gain", new Vector4(vector2.x, vector2.y, vector2.z, 0f));
			command.SetComputeTextureParam(lut3DBaker, kernelIndex, "_Curves", this.GetCurveTexture(true));
			if (base.settings.tonemapper.value == Tonemapper.Custom)
			{
				this.m_HableCurve.Init(base.settings.toneCurveToeStrength.value, base.settings.toneCurveToeLength.value, base.settings.toneCurveShoulderStrength.value, base.settings.toneCurveShoulderLength.value, base.settings.toneCurveShoulderAngle.value, base.settings.toneCurveGamma.value);
				command.SetComputeVectorParam(lut3DBaker, "_CustomToneCurve", this.m_HableCurve.uniforms.curve);
				command.SetComputeVectorParam(lut3DBaker, "_ToeSegmentA", this.m_HableCurve.uniforms.toeSegmentA);
				command.SetComputeVectorParam(lut3DBaker, "_ToeSegmentB", this.m_HableCurve.uniforms.toeSegmentB);
				command.SetComputeVectorParam(lut3DBaker, "_MidSegmentA", this.m_HableCurve.uniforms.midSegmentA);
				command.SetComputeVectorParam(lut3DBaker, "_MidSegmentB", this.m_HableCurve.uniforms.midSegmentB);
				command.SetComputeVectorParam(lut3DBaker, "_ShoSegmentA", this.m_HableCurve.uniforms.shoSegmentA);
				command.SetComputeVectorParam(lut3DBaker, "_ShoSegmentB", this.m_HableCurve.uniforms.shoSegmentB);
			}
			context.command.BeginSample("HdrColorGradingLut3D");
			command.DispatchCompute(lut3DBaker, kernelIndex, num, num, threadGroupsZ);
			context.command.EndSample("HdrColorGradingLut3D");
			RenderTexture internalLogLut = this.m_InternalLogLut;
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("COLOR_GRADING_HDR_3D");
			uberSheet.properties.SetTexture(ShaderIDs.Lut3D, internalLogLut);
			uberSheet.properties.SetVector(ShaderIDs.Lut3D_Params, new Vector2(1f / (float)internalLogLut.width, (float)internalLogLut.width - 1f));
			uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(base.settings.postExposure.value));
			context.logLut = internalLogLut;
		}

		private void RenderHDRPipeline2D(PostProcessRenderContext context)
		{
			this.CheckInternalStripLut();
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lut2DBaker);
			propertySheet.ClearKeywords();
			propertySheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector4(32f, 0.00048828125f, 0.015625f, 1.032258f));
			Vector3 v = ColorUtilities.ComputeColorBalance(base.settings.temperature.value, base.settings.tint.value);
			propertySheet.properties.SetVector(ShaderIDs.ColorBalance, v);
			propertySheet.properties.SetVector(ShaderIDs.ColorFilter, base.settings.colorFilter.value);
			float x = base.settings.hueShift.value / 360f;
			float y = base.settings.saturation.value / 100f + 1f;
			float z = base.settings.contrast.value / 100f + 1f;
			propertySheet.properties.SetVector(ShaderIDs.HueSatCon, new Vector3(x, y, z));
			Vector3 a = new Vector3(base.settings.mixerRedOutRedIn, base.settings.mixerRedOutGreenIn, base.settings.mixerRedOutBlueIn);
			Vector3 a2 = new Vector3(base.settings.mixerGreenOutRedIn, base.settings.mixerGreenOutGreenIn, base.settings.mixerGreenOutBlueIn);
			Vector3 a3 = new Vector3(base.settings.mixerBlueOutRedIn, base.settings.mixerBlueOutGreenIn, base.settings.mixerBlueOutBlueIn);
			propertySheet.properties.SetVector(ShaderIDs.ChannelMixerRed, a / 100f);
			propertySheet.properties.SetVector(ShaderIDs.ChannelMixerGreen, a2 / 100f);
			propertySheet.properties.SetVector(ShaderIDs.ChannelMixerBlue, a3 / 100f);
			Vector3 v2 = ColorUtilities.ColorToLift(base.settings.lift.value * 0.2f);
			Vector3 v3 = ColorUtilities.ColorToGain(base.settings.gain.value * 0.8f);
			Vector3 v4 = ColorUtilities.ColorToInverseGamma(base.settings.gamma.value * 0.8f);
			propertySheet.properties.SetVector(ShaderIDs.Lift, v2);
			propertySheet.properties.SetVector(ShaderIDs.InvGamma, v4);
			propertySheet.properties.SetVector(ShaderIDs.Gain, v3);
			propertySheet.properties.SetTexture(ShaderIDs.Curves, this.GetCurveTexture(false));
			Tonemapper value = base.settings.tonemapper.value;
			if (value == Tonemapper.Custom)
			{
				propertySheet.EnableKeyword("TONEMAPPING_CUSTOM");
				this.m_HableCurve.Init(base.settings.toneCurveToeStrength.value, base.settings.toneCurveToeLength.value, base.settings.toneCurveShoulderStrength.value, base.settings.toneCurveShoulderLength.value, base.settings.toneCurveShoulderAngle.value, base.settings.toneCurveGamma.value);
				propertySheet.properties.SetVector(ShaderIDs.CustomToneCurve, this.m_HableCurve.uniforms.curve);
				propertySheet.properties.SetVector(ShaderIDs.ToeSegmentA, this.m_HableCurve.uniforms.toeSegmentA);
				propertySheet.properties.SetVector(ShaderIDs.ToeSegmentB, this.m_HableCurve.uniforms.toeSegmentB);
				propertySheet.properties.SetVector(ShaderIDs.MidSegmentA, this.m_HableCurve.uniforms.midSegmentA);
				propertySheet.properties.SetVector(ShaderIDs.MidSegmentB, this.m_HableCurve.uniforms.midSegmentB);
				propertySheet.properties.SetVector(ShaderIDs.ShoSegmentA, this.m_HableCurve.uniforms.shoSegmentA);
				propertySheet.properties.SetVector(ShaderIDs.ShoSegmentB, this.m_HableCurve.uniforms.shoSegmentB);
			}
			else if (value == Tonemapper.ACES)
			{
				propertySheet.EnableKeyword("TONEMAPPING_ACES");
			}
			else if (value == Tonemapper.Neutral)
			{
				propertySheet.EnableKeyword("TONEMAPPING_NEUTRAL");
			}
			context.command.BeginSample("HdrColorGradingLut2D");
			context.command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, this.m_InternalLdrLut, propertySheet, 2, false);
			context.command.EndSample("HdrColorGradingLut2D");
			RenderTexture internalLdrLut = this.m_InternalLdrLut;
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("COLOR_GRADING_HDR_2D");
			uberSheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector3(1f / (float)internalLdrLut.width, 1f / (float)internalLdrLut.height, (float)internalLdrLut.height - 1f));
			uberSheet.properties.SetTexture(ShaderIDs.Lut2D, internalLdrLut);
			uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(base.settings.postExposure.value));
		}

		private void RenderLDRPipeline2D(PostProcessRenderContext context)
		{
			this.CheckInternalStripLut();
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lut2DBaker);
			propertySheet.ClearKeywords();
			propertySheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector4(32f, 0.00048828125f, 0.015625f, 1.032258f));
			Vector3 v = ColorUtilities.ComputeColorBalance(base.settings.temperature.value, base.settings.tint.value);
			propertySheet.properties.SetVector(ShaderIDs.ColorBalance, v);
			propertySheet.properties.SetVector(ShaderIDs.ColorFilter, base.settings.colorFilter.value);
			float x = base.settings.hueShift.value / 360f;
			float y = base.settings.saturation.value / 100f + 1f;
			float z = base.settings.contrast.value / 100f + 1f;
			propertySheet.properties.SetVector(ShaderIDs.HueSatCon, new Vector3(x, y, z));
			Vector3 a = new Vector3(base.settings.mixerRedOutRedIn, base.settings.mixerRedOutGreenIn, base.settings.mixerRedOutBlueIn);
			Vector3 a2 = new Vector3(base.settings.mixerGreenOutRedIn, base.settings.mixerGreenOutGreenIn, base.settings.mixerGreenOutBlueIn);
			Vector3 a3 = new Vector3(base.settings.mixerBlueOutRedIn, base.settings.mixerBlueOutGreenIn, base.settings.mixerBlueOutBlueIn);
			propertySheet.properties.SetVector(ShaderIDs.ChannelMixerRed, a / 100f);
			propertySheet.properties.SetVector(ShaderIDs.ChannelMixerGreen, a2 / 100f);
			propertySheet.properties.SetVector(ShaderIDs.ChannelMixerBlue, a3 / 100f);
			Vector3 v2 = ColorUtilities.ColorToLift(base.settings.lift.value);
			Vector3 v3 = ColorUtilities.ColorToGain(base.settings.gain.value);
			Vector3 v4 = ColorUtilities.ColorToInverseGamma(base.settings.gamma.value);
			propertySheet.properties.SetVector(ShaderIDs.Lift, v2);
			propertySheet.properties.SetVector(ShaderIDs.InvGamma, v4);
			propertySheet.properties.SetVector(ShaderIDs.Gain, v3);
			propertySheet.properties.SetFloat(ShaderIDs.Brightness, (base.settings.brightness.value + 100f) / 100f);
			propertySheet.properties.SetTexture(ShaderIDs.Curves, this.GetCurveTexture(false));
			context.command.BeginSample("LdrColorGradingLut2D");
			Texture value = base.settings.ldrLut.value;
			if (value == null)
			{
				context.command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, this.m_InternalLdrLut, propertySheet, 0, false);
			}
			else
			{
				context.command.BlitFullscreenTriangle(value, this.m_InternalLdrLut, propertySheet, 1, false);
			}
			context.command.EndSample("LdrColorGradingLut2D");
			RenderTexture internalLdrLut = this.m_InternalLdrLut;
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("COLOR_GRADING_LDR_2D");
			uberSheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector3(1f / (float)internalLdrLut.width, 1f / (float)internalLdrLut.height, (float)internalLdrLut.height - 1f));
			uberSheet.properties.SetTexture(ShaderIDs.Lut2D, internalLdrLut);
		}

		private void CheckInternalLogLut()
		{
			if (this.m_InternalLogLut == null || !this.m_InternalLogLut.IsCreated())
			{
				RuntimeUtilities.Destroy(this.m_InternalLogLut);
				RenderTextureFormat lutFormat = ColorGradingRenderer.GetLutFormat();
				this.m_InternalLogLut = new RenderTexture(33, 33, 0, lutFormat, RenderTextureReadWrite.Linear)
				{
					name = "Color Grading Log Lut",
					dimension = TextureDimension.Tex3D,
					hideFlags = HideFlags.DontSave,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					anisoLevel = 0,
					enableRandomWrite = true,
					volumeDepth = 33,
					autoGenerateMips = false,
					useMipMap = false
				};
				this.m_InternalLogLut.Create();
			}
		}

		private void CheckInternalStripLut()
		{
			if (this.m_InternalLdrLut == null || !this.m_InternalLdrLut.IsCreated())
			{
				RuntimeUtilities.Destroy(this.m_InternalLdrLut);
				RenderTextureFormat lutFormat = ColorGradingRenderer.GetLutFormat();
				this.m_InternalLdrLut = new RenderTexture(1024, 32, 0, lutFormat, RenderTextureReadWrite.Linear)
				{
					name = "Color Grading Strip Lut",
					hideFlags = HideFlags.DontSave,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					anisoLevel = 0,
					autoGenerateMips = false,
					useMipMap = false
				};
				this.m_InternalLdrLut.Create();
			}
		}

		private Texture2D GetCurveTexture(bool hdr)
		{
			if (this.m_GradingCurves == null)
			{
				TextureFormat curveFormat = ColorGradingRenderer.GetCurveFormat();
				this.m_GradingCurves = new Texture2D(128, 2, curveFormat, false, true)
				{
					name = "Internal Curves Texture",
					hideFlags = HideFlags.DontSave,
					anisoLevel = 0,
					wrapMode = TextureWrapMode.Clamp,
					filterMode = FilterMode.Bilinear
				};
			}
			Spline value = base.settings.hueVsHueCurve.value;
			Spline value2 = base.settings.hueVsSatCurve.value;
			Spline value3 = base.settings.satVsSatCurve.value;
			Spline value4 = base.settings.lumVsSatCurve.value;
			Spline value5 = base.settings.masterCurve.value;
			Spline value6 = base.settings.redCurve.value;
			Spline value7 = base.settings.greenCurve.value;
			Spline value8 = base.settings.blueCurve.value;
			Color[] pixels = this.m_Pixels;
			for (int i = 0; i < 128; i++)
			{
				float r = value.cachedData[i];
				float g = value2.cachedData[i];
				float b = value3.cachedData[i];
				float a = value4.cachedData[i];
				pixels[i] = new Color(r, g, b, a);
				if (!hdr)
				{
					float a2 = value5.cachedData[i];
					float r2 = value6.cachedData[i];
					float g2 = value7.cachedData[i];
					float b2 = value8.cachedData[i];
					pixels[i + 128] = new Color(r2, g2, b2, a2);
				}
			}
			this.m_GradingCurves.SetPixels(pixels);
			this.m_GradingCurves.Apply(false, false);
			return this.m_GradingCurves;
		}

		private static RenderTextureFormat GetLutFormat()
		{
			RenderTextureFormat renderTextureFormat = RenderTextureFormat.ARGBHalf;
			if (!renderTextureFormat.IsSupported())
			{
				renderTextureFormat = RenderTextureFormat.ARGB2101010;
				if (!renderTextureFormat.IsSupported())
				{
					renderTextureFormat = RenderTextureFormat.ARGB32;
				}
			}
			return renderTextureFormat;
		}

		private static TextureFormat GetCurveFormat()
		{
			TextureFormat textureFormat = TextureFormat.RGBAHalf;
			if (!SystemInfo.SupportsTextureFormat(textureFormat))
			{
				textureFormat = TextureFormat.ARGB32;
			}
			return textureFormat;
		}

		public override void Release()
		{
			RuntimeUtilities.Destroy(this.m_InternalLdrLut);
			this.m_InternalLdrLut = null;
			RuntimeUtilities.Destroy(this.m_InternalLogLut);
			this.m_InternalLogLut = null;
			RuntimeUtilities.Destroy(this.m_GradingCurves);
			this.m_GradingCurves = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum KernelSize
	{
		Small,
		Medium,
		Large,
		VeryLarge
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class KernelSizeParameter : ParameterOverride<KernelSize>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(DepthOfFieldRenderer), "Unity/Depth of Field", false)]
	[Serializable]
	public sealed class DepthOfField : PostProcessEffectSettings
	{
		[Min(0.1f), Tooltip("Distance to the point of focus.")]
		public FloatParameter focusDistance = new FloatParameter
		{
			value = 10f
		};

		[Range(0.05f, 32f), Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
		public FloatParameter aperture = new FloatParameter
		{
			value = 5.6f
		};

		[Range(1f, 300f), Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
		public FloatParameter focalLength = new FloatParameter
		{
			value = 50f
		};

		[DisplayName("Max Blur Size"), Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects performances (the larger the kernel is, the longer the GPU time is required).")]
		public KernelSizeParameter kernelSize = new KernelSizeParameter
		{
			value = KernelSize.Medium
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && SystemInfo.graphicsShaderLevel >= 35;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class DepthOfFieldRenderer : PostProcessEffectRenderer<DepthOfField>
	{
		private enum Pass
		{
			CoCCalculation,
			CoCTemporalFilter,
			DownsampleAndPrefilter,
			BokehSmallKernel,
			BokehMediumKernel,
			BokehLargeKernel,
			BokehVeryLargeKernel,
			PostFilter,
			Combine,
			DebugOverlay
		}

		private const int k_NumEyes = 2;

		private const int k_NumCoCHistoryTextures = 2;

		private readonly RenderTexture[][] m_CoCHistoryTextures = new RenderTexture[2][];

		private int[] m_HistoryPingPong = new int[2];

		private const float k_FilmHeight = 0.024f;

		public DepthOfFieldRenderer()
		{
			for (int i = 0; i < 2; i++)
			{
				this.m_CoCHistoryTextures[i] = new RenderTexture[2];
				this.m_HistoryPingPong[i] = 0;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
		{
			if (primary.IsSupported())
			{
				return primary;
			}
			if (secondary.IsSupported())
			{
				return secondary;
			}
			return RenderTextureFormat.Default;
		}

		private float CalculateMaxCoCRadius(int screenHeight)
		{
			float num = (float)base.settings.kernelSize.value * 4f + 6f;
			return Mathf.Min(0.05f, num / (float)screenHeight);
		}

		private RenderTexture CheckHistory(int eye, int id, PostProcessRenderContext context, RenderTextureFormat format)
		{
			RenderTexture renderTexture = this.m_CoCHistoryTextures[eye][id];
			if (this.m_ResetHistory || renderTexture == null || !renderTexture.IsCreated() || renderTexture.width != context.width || renderTexture.height != context.height)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = context.GetScreenSpaceTemporaryRT(0, format, RenderTextureReadWrite.Default, 0, 0);
				renderTexture.name = string.Concat(new object[]
				{
					"CoC History, Eye: ",
					eye,
					", ID: ",
					id
				});
				renderTexture.filterMode = FilterMode.Bilinear;
				renderTexture.Create();
				this.m_CoCHistoryTextures[eye][id] = renderTexture;
			}
			return renderTexture;
		}

		public override void Render(PostProcessRenderContext context)
		{
			RenderTextureFormat colorFormat = RenderTextureFormat.DefaultHDR;
			RenderTextureFormat renderTextureFormat = this.SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf);
			float num = base.settings.focalLength.value / 1000f;
			float num2 = Mathf.Max(base.settings.focusDistance.value, num);
			float num3 = (float)context.screenWidth / (float)context.screenHeight;
			float value = num * num / (base.settings.aperture.value * (num2 - num) * 0.024f * 2f);
			float num4 = this.CalculateMaxCoCRadius(context.screenHeight);
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.depthOfField);
			propertySheet.properties.Clear();
			propertySheet.properties.SetFloat(ShaderIDs.Distance, num2);
			propertySheet.properties.SetFloat(ShaderIDs.LensCoeff, value);
			propertySheet.properties.SetFloat(ShaderIDs.MaxCoC, num4);
			propertySheet.properties.SetFloat(ShaderIDs.RcpMaxCoC, 1f / num4);
			propertySheet.properties.SetFloat(ShaderIDs.RcpAspect, 1f / num3);
			CommandBuffer command = context.command;
			command.BeginSample("DepthOfField");
			context.GetScreenSpaceTemporaryRT(command, ShaderIDs.CoCTex, 0, renderTextureFormat, RenderTextureReadWrite.Linear, FilterMode.Bilinear, 0, 0);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, ShaderIDs.CoCTex, propertySheet, 0, false);
			if (context.IsTemporalAntialiasingActive())
			{
				float motionBlending = context.temporalAntialiasing.motionBlending;
				float z = (!this.m_ResetHistory) ? motionBlending : 0f;
				Vector2 jitter = context.temporalAntialiasing.jitter;
				propertySheet.properties.SetVector(ShaderIDs.TaaParams, new Vector3(jitter.x, jitter.y, z));
				int num5 = this.m_HistoryPingPong[context.xrActiveEye];
				RenderTexture tex = this.CheckHistory(context.xrActiveEye, ++num5 % 2, context, renderTextureFormat);
				RenderTexture tex2 = this.CheckHistory(context.xrActiveEye, ++num5 % 2, context, renderTextureFormat);
				this.m_HistoryPingPong[context.xrActiveEye] = (num5 + 1) % 2;
				command.BlitFullscreenTriangle(tex, tex2, propertySheet, 1, false);
				command.ReleaseTemporaryRT(ShaderIDs.CoCTex);
				command.SetGlobalTexture(ShaderIDs.CoCTex, tex2);
			}
			context.GetScreenSpaceTemporaryRT(command, ShaderIDs.DepthOfFieldTex, 0, colorFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, context.width / 2, context.height / 2);
			command.BlitFullscreenTriangle(context.source, ShaderIDs.DepthOfFieldTex, propertySheet, 2, false);
			context.GetScreenSpaceTemporaryRT(command, ShaderIDs.DepthOfFieldTemp, 0, colorFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, context.width / 2, context.height / 2);
			command.BlitFullscreenTriangle(ShaderIDs.DepthOfFieldTex, ShaderIDs.DepthOfFieldTemp, propertySheet, (int)(3 + base.settings.kernelSize.value), false);
			command.BlitFullscreenTriangle(ShaderIDs.DepthOfFieldTemp, ShaderIDs.DepthOfFieldTex, propertySheet, 7, false);
			command.ReleaseTemporaryRT(ShaderIDs.DepthOfFieldTemp);
			if (context.IsDebugOverlayEnabled(DebugOverlay.DepthOfField))
			{
				context.PushDebugOverlay(command, context.source, propertySheet, 9);
			}
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 8, false);
			command.ReleaseTemporaryRT(ShaderIDs.DepthOfFieldTex);
			if (!context.IsTemporalAntialiasingActive())
			{
				command.ReleaseTemporaryRT(ShaderIDs.CoCTex);
			}
			command.EndSample("DepthOfField");
			this.m_ResetHistory = false;
		}

		public override void Release()
		{
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < this.m_CoCHistoryTextures[i].Length; j++)
				{
					RenderTexture.ReleaseTemporary(this.m_CoCHistoryTextures[i][j]);
					this.m_CoCHistoryTextures[i][j] = null;
				}
				this.m_HistoryPingPong[i] = 0;
			}
			this.ResetHistory();
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class Dithering
	{
		private int m_NoiseTextureIndex;

		internal void Render(PostProcessRenderContext context)
		{
			Texture2D[] blueNoise = context.resources.blueNoise64;
			if (++this.m_NoiseTextureIndex >= blueNoise.Length)
			{
				this.m_NoiseTextureIndex = 0;
			}
			float value = UnityEngine.Random.value;
			float value2 = UnityEngine.Random.value;
			Texture2D texture2D = blueNoise[this.m_NoiseTextureIndex];
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.properties.SetTexture(ShaderIDs.DitheringTex, texture2D);
			uberSheet.properties.SetVector(ShaderIDs.Dithering_Coords, new Vector4((float)context.screenWidth / (float)texture2D.width, (float)context.screenHeight / (float)texture2D.height, value, value2));
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using UnityEngine.Serialization;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class FastApproximateAntialiasing
	{
		[FormerlySerializedAs("mobileOptimized"), Tooltip("Boost performances by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
		public bool fastMode;

		[Tooltip("Keep alpha channel. This will slightly lower the effect quality but allows rendering against a transparent background.")]
		public bool keepAlpha;
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class Fog
	{
		[Tooltip("Enables the internal deferred fog pass. Actual fog settings should be set in the Lighting panel.")]
		public bool enabled = true;

		[Tooltip("Should the fog affect the skybox?")]
		public bool excludeSkybox = true;

		internal DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		internal bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled && RenderSettings.fog && !RuntimeUtilities.scriptableRenderPipelineActive && context.camera.actualRenderingPath == RenderingPath.DeferredShading;
		}

		internal void Render(PostProcessRenderContext context)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.deferredFog);
			propertySheet.ClearKeywords();
			Color c = (!RuntimeUtilities.isLinearColorSpace) ? RenderSettings.fogColor : RenderSettings.fogColor.linear;
			propertySheet.properties.SetVector(ShaderIDs.FogColor, c);
			propertySheet.properties.SetVector(ShaderIDs.FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
			CommandBuffer command = context.command;
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, (!this.excludeSkybox) ? 0 : 1, false);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(GrainRenderer), "Unity/Grain", true)]
	[Serializable]
	public sealed class Grain : PostProcessEffectSettings
	{
		[Tooltip("Enable the use of colored grain.")]
		public BoolParameter colored = new BoolParameter
		{
			value = true
		};

		[Range(0f, 1f), Tooltip("Grain strength. Higher means more visible grain.")]
		public FloatParameter intensity = new FloatParameter
		{
			value = 0f
		};

		[Range(0.3f, 3f), Tooltip("Grain particle size.")]
		public FloatParameter size = new FloatParameter
		{
			value = 1f
		};

		[Range(0f, 1f), DisplayName("Luminance Contribution"), Tooltip("Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas.")]
		public FloatParameter lumContrib = new FloatParameter
		{
			value = 0.8f
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && this.intensity.value > 0f;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class GrainRenderer : PostProcessEffectRenderer<Grain>
	{
		private RenderTexture m_GrainLookupRT;

		private const int k_SampleCount = 1024;

		private int m_SampleIndex;

		public override void Render(PostProcessRenderContext context)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float z = HaltonSeq.Get(this.m_SampleIndex & 1023, 2);
			float w = HaltonSeq.Get(this.m_SampleIndex & 1023, 3);
			if (++this.m_SampleIndex >= 1024)
			{
				this.m_SampleIndex = 0;
			}
			if (this.m_GrainLookupRT == null || !this.m_GrainLookupRT.IsCreated())
			{
				RuntimeUtilities.Destroy(this.m_GrainLookupRT);
				this.m_GrainLookupRT = new RenderTexture(128, 128, 0, this.GetLookupFormat())
				{
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Repeat,
					anisoLevel = 0,
					name = "Grain Lookup Texture"
				};
				this.m_GrainLookupRT.Create();
			}
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.grainBaker);
			propertySheet.properties.Clear();
			propertySheet.properties.SetFloat(ShaderIDs.Phase, realtimeSinceStartup % 10f);
			context.command.BeginSample("GrainLookup");
			context.command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, this.m_GrainLookupRT, propertySheet, (!base.settings.colored.value) ? 0 : 1, false);
			context.command.EndSample("GrainLookup");
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("GRAIN");
			uberSheet.properties.SetTexture(ShaderIDs.GrainTex, this.m_GrainLookupRT);
			uberSheet.properties.SetVector(ShaderIDs.Grain_Params1, new Vector2(base.settings.lumContrib.value, base.settings.intensity.value * 20f));
			uberSheet.properties.SetVector(ShaderIDs.Grain_Params2, new Vector4((float)context.width / (float)this.m_GrainLookupRT.width / base.settings.size.value, (float)context.height / (float)this.m_GrainLookupRT.height / base.settings.size.value, z, w));
		}

		private RenderTextureFormat GetLookupFormat()
		{
			if (RenderTextureFormat.ARGBHalf.IsSupported())
			{
				return RenderTextureFormat.ARGBHalf;
			}
			return RenderTextureFormat.ARGB32;
		}

		public override void Release()
		{
			RuntimeUtilities.Destroy(this.m_GrainLookupRT);
			this.m_GrainLookupRT = null;
			this.m_SampleIndex = 0;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(MotionBlurRenderer), "Unity/Motion Blur", false)]
	[Serializable]
	public sealed class MotionBlur : PostProcessEffectSettings
	{
		[Range(0f, 360f), Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
		public FloatParameter shutterAngle = new FloatParameter
		{
			value = 270f
		};

		[Range(4f, 32f), Tooltip("The amount of sample points, which affects quality and performances.")]
		public IntParameter sampleCount = new IntParameter
		{
			value = 10
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && this.shutterAngle.value > 0f && SystemInfo.supportsMotionVectors && RenderTextureFormat.RGHalf.IsSupported() && !RuntimeUtilities.isVREnabled;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class MotionBlurRenderer : PostProcessEffectRenderer<MotionBlur>
	{
		private enum Pass
		{
			VelocitySetup,
			TileMax1,
			TileMax2,
			TileMaxV,
			NeighborMax,
			Reconstruction
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public override void Render(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			if (this.m_ResetHistory)
			{
				command.BlitFullscreenTriangle(context.source, context.destination, false);
				this.m_ResetHistory = false;
				return;
			}
			RenderTextureFormat format = RenderTextureFormat.RGHalf;
			RenderTextureFormat format2 = (!RenderTextureFormat.ARGB2101010.IsSupported()) ? RenderTextureFormat.ARGB32 : RenderTextureFormat.ARGB2101010;
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.motionBlur);
			command.BeginSample("MotionBlur");
			int num = (int)(5f * (float)context.height / 100f);
			int num2 = ((num - 1) / 8 + 1) * 8;
			float value = base.settings.shutterAngle / 360f;
			propertySheet.properties.SetFloat(ShaderIDs.VelocityScale, value);
			propertySheet.properties.SetFloat(ShaderIDs.MaxBlurRadius, (float)num);
			propertySheet.properties.SetFloat(ShaderIDs.RcpMaxBlurRadius, 1f / (float)num);
			int velocityTex = ShaderIDs.VelocityTex;
			command.GetTemporaryRT(velocityTex, context.width, context.height, 0, FilterMode.Point, format2, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, velocityTex, propertySheet, 0, false);
			int tile2RT = ShaderIDs.Tile2RT;
			command.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, FilterMode.Point, format, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(velocityTex, tile2RT, propertySheet, 1, false);
			int tile4RT = ShaderIDs.Tile4RT;
			command.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, FilterMode.Point, format, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(tile2RT, tile4RT, propertySheet, 2, false);
			command.ReleaseTemporaryRT(tile2RT);
			int tile8RT = ShaderIDs.Tile8RT;
			command.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, FilterMode.Point, format, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(tile4RT, tile8RT, propertySheet, 2, false);
			command.ReleaseTemporaryRT(tile4RT);
			Vector2 v = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
			propertySheet.properties.SetVector(ShaderIDs.TileMaxOffs, v);
			propertySheet.properties.SetFloat(ShaderIDs.TileMaxLoop, (float)((int)((float)num2 / 8f)));
			int tileVRT = ShaderIDs.TileVRT;
			command.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, FilterMode.Point, format, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(tile8RT, tileVRT, propertySheet, 3, false);
			command.ReleaseTemporaryRT(tile8RT);
			int neighborMaxTex = ShaderIDs.NeighborMaxTex;
			int width = context.width / num2;
			int height = context.height / num2;
			command.GetTemporaryRT(neighborMaxTex, width, height, 0, FilterMode.Point, format, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(tileVRT, neighborMaxTex, propertySheet, 4, false);
			command.ReleaseTemporaryRT(tileVRT);
			propertySheet.properties.SetFloat(ShaderIDs.LoopCount, (float)Mathf.Clamp(base.settings.sampleCount / 2, 1, 64));
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, false);
			command.ReleaseTemporaryRT(velocityTex);
			command.ReleaseTemporaryRT(neighborMaxTex);
			command.EndSample("MotionBlur");
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class MultiScaleVO : IAmbientOcclusionMethod
	{
		internal enum MipLevel
		{
			Original,
			L1,
			L2,
			L3,
			L4,
			L5,
			L6
		}

		private enum Pass
		{
			DepthCopy,
			CompositionDeferred,
			CompositionForward,
			DebugOverlay
		}

		private readonly float[] m_SampleThickness = new float[]
		{
			Mathf.Sqrt(0.96f),
			Mathf.Sqrt(0.84f),
			Mathf.Sqrt(0.64f),
			Mathf.Sqrt(0.359999985f),
			Mathf.Sqrt(0.92f),
			Mathf.Sqrt(0.8f),
			Mathf.Sqrt(0.599999964f),
			Mathf.Sqrt(0.32f),
			Mathf.Sqrt(0.68f),
			Mathf.Sqrt(0.479999959f),
			Mathf.Sqrt(0.199999973f),
			Mathf.Sqrt(0.279999942f)
		};

		private readonly float[] m_InvThicknessTable = new float[12];

		private readonly float[] m_SampleWeightTable = new float[12];

		private readonly int[] m_Widths = new int[7];

		private readonly int[] m_Heights = new int[7];

		private AmbientOcclusion m_Settings;

		private PropertySheet m_PropertySheet;

		private PostProcessResources m_Resources;

		private RenderTexture m_AmbientOnlyAO;

		private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[]
		{
			BuiltinRenderTextureType.GBuffer0,
			BuiltinRenderTextureType.CameraTarget
		};

		public MultiScaleVO(AmbientOcclusion settings)
		{
			this.m_Settings = settings;
		}

		public DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public void SetResources(PostProcessResources resources)
		{
			this.m_Resources = resources;
		}

		private void Alloc(CommandBuffer cmd, int id, MultiScaleVO.MipLevel size, RenderTextureFormat format, bool uav)
		{
			cmd.GetTemporaryRT(id, new RenderTextureDescriptor
			{
				width = this.m_Widths[(int)size],
				height = this.m_Heights[(int)size],
				colorFormat = format,
				depthBufferBits = 0,
				autoGenerateMips = false,
				msaaSamples = 1,
				enableRandomWrite = uav,
				dimension = TextureDimension.Tex2D,
				sRGB = false
			}, FilterMode.Point);
		}

		private void AllocArray(CommandBuffer cmd, int id, MultiScaleVO.MipLevel size, RenderTextureFormat format, bool uav)
		{
			cmd.GetTemporaryRT(id, new RenderTextureDescriptor
			{
				width = this.m_Widths[(int)size],
				height = this.m_Heights[(int)size],
				colorFormat = format,
				depthBufferBits = 0,
				volumeDepth = 16,
				autoGenerateMips = false,
				msaaSamples = 1,
				enableRandomWrite = uav,
				dimension = TextureDimension.Tex2DArray,
				sRGB = false
			}, FilterMode.Point);
		}

		private void Release(CommandBuffer cmd, int id)
		{
			cmd.ReleaseTemporaryRT(id);
		}

		private Vector4 CalculateZBufferParams(Camera camera)
		{
			float num = camera.farClipPlane / camera.nearClipPlane;
			if (SystemInfo.usesReversedZBuffer)
			{
				return new Vector4(num - 1f, 1f, 0f, 0f);
			}
			return new Vector4(1f - num, num, 0f, 0f);
		}

		private float CalculateTanHalfFovHeight(Camera camera)
		{
			return 1f / camera.projectionMatrix[0, 0];
		}

		private Vector2 GetSize(MultiScaleVO.MipLevel mip)
		{
			return new Vector2((float)this.m_Widths[(int)mip], (float)this.m_Heights[(int)mip]);
		}

		private Vector3 GetSizeArray(MultiScaleVO.MipLevel mip)
		{
			return new Vector3((float)this.m_Widths[(int)mip], (float)this.m_Heights[(int)mip], 16f);
		}

		public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert)
		{
			this.m_Widths[0] = camera.pixelWidth * ((!RuntimeUtilities.isSinglePassStereoEnabled) ? 1 : 2);
			this.m_Heights[0] = camera.pixelHeight;
			for (int i = 1; i < 7; i++)
			{
				int num = 1 << i;
				this.m_Widths[i] = (this.m_Widths[0] + (num - 1)) / num;
				this.m_Heights[i] = (this.m_Heights[0] + (num - 1)) / num;
			}
			this.PushAllocCommands(cmd);
			this.PushDownsampleCommands(cmd, camera, depthMap);
			float tanHalfFovH = this.CalculateTanHalfFovHeight(camera);
			this.PushRenderCommands(cmd, ShaderIDs.TiledDepth1, ShaderIDs.Occlusion1, this.GetSizeArray(MultiScaleVO.MipLevel.L3), tanHalfFovH);
			this.PushRenderCommands(cmd, ShaderIDs.TiledDepth2, ShaderIDs.Occlusion2, this.GetSizeArray(MultiScaleVO.MipLevel.L4), tanHalfFovH);
			this.PushRenderCommands(cmd, ShaderIDs.TiledDepth3, ShaderIDs.Occlusion3, this.GetSizeArray(MultiScaleVO.MipLevel.L5), tanHalfFovH);
			this.PushRenderCommands(cmd, ShaderIDs.TiledDepth4, ShaderIDs.Occlusion4, this.GetSizeArray(MultiScaleVO.MipLevel.L6), tanHalfFovH);
			this.PushUpsampleCommands(cmd, ShaderIDs.LowDepth4, ShaderIDs.Occlusion4, ShaderIDs.LowDepth3, new int?(ShaderIDs.Occlusion3), ShaderIDs.Combined3, this.GetSize(MultiScaleVO.MipLevel.L4), this.GetSize(MultiScaleVO.MipLevel.L3), false);
			this.PushUpsampleCommands(cmd, ShaderIDs.LowDepth3, ShaderIDs.Combined3, ShaderIDs.LowDepth2, new int?(ShaderIDs.Occlusion2), ShaderIDs.Combined2, this.GetSize(MultiScaleVO.MipLevel.L3), this.GetSize(MultiScaleVO.MipLevel.L2), false);
			this.PushUpsampleCommands(cmd, ShaderIDs.LowDepth2, ShaderIDs.Combined2, ShaderIDs.LowDepth1, new int?(ShaderIDs.Occlusion1), ShaderIDs.Combined1, this.GetSize(MultiScaleVO.MipLevel.L2), this.GetSize(MultiScaleVO.MipLevel.L1), false);
			this.PushUpsampleCommands(cmd, ShaderIDs.LowDepth1, ShaderIDs.Combined1, ShaderIDs.LinearDepth, null, destination, this.GetSize(MultiScaleVO.MipLevel.L1), this.GetSize(MultiScaleVO.MipLevel.Original), invert);
			this.PushReleaseCommands(cmd);
		}

		private void PushAllocCommands(CommandBuffer cmd)
		{
			this.Alloc(cmd, ShaderIDs.LinearDepth, MultiScaleVO.MipLevel.Original, RenderTextureFormat.RHalf, true);
			this.Alloc(cmd, ShaderIDs.LowDepth1, MultiScaleVO.MipLevel.L1, RenderTextureFormat.RFloat, true);
			this.Alloc(cmd, ShaderIDs.LowDepth2, MultiScaleVO.MipLevel.L2, RenderTextureFormat.RFloat, true);
			this.Alloc(cmd, ShaderIDs.LowDepth3, MultiScaleVO.MipLevel.L3, RenderTextureFormat.RFloat, true);
			this.Alloc(cmd, ShaderIDs.LowDepth4, MultiScaleVO.MipLevel.L4, RenderTextureFormat.RFloat, true);
			this.AllocArray(cmd, ShaderIDs.TiledDepth1, MultiScaleVO.MipLevel.L3, RenderTextureFormat.RHalf, true);
			this.AllocArray(cmd, ShaderIDs.TiledDepth2, MultiScaleVO.MipLevel.L4, RenderTextureFormat.RHalf, true);
			this.AllocArray(cmd, ShaderIDs.TiledDepth3, MultiScaleVO.MipLevel.L5, RenderTextureFormat.RHalf, true);
			this.AllocArray(cmd, ShaderIDs.TiledDepth4, MultiScaleVO.MipLevel.L6, RenderTextureFormat.RHalf, true);
			this.Alloc(cmd, ShaderIDs.Occlusion1, MultiScaleVO.MipLevel.L1, RenderTextureFormat.R8, true);
			this.Alloc(cmd, ShaderIDs.Occlusion2, MultiScaleVO.MipLevel.L2, RenderTextureFormat.R8, true);
			this.Alloc(cmd, ShaderIDs.Occlusion3, MultiScaleVO.MipLevel.L3, RenderTextureFormat.R8, true);
			this.Alloc(cmd, ShaderIDs.Occlusion4, MultiScaleVO.MipLevel.L4, RenderTextureFormat.R8, true);
			this.Alloc(cmd, ShaderIDs.Combined1, MultiScaleVO.MipLevel.L1, RenderTextureFormat.R8, true);
			this.Alloc(cmd, ShaderIDs.Combined2, MultiScaleVO.MipLevel.L2, RenderTextureFormat.R8, true);
			this.Alloc(cmd, ShaderIDs.Combined3, MultiScaleVO.MipLevel.L3, RenderTextureFormat.R8, true);
		}

		private void PushDownsampleCommands(CommandBuffer cmd, Camera camera, RenderTargetIdentifier? depthMap)
		{
			bool flag = false;
			RenderTargetIdentifier renderTargetIdentifier;
			if (depthMap.HasValue)
			{
				renderTargetIdentifier = depthMap.Value;
			}
			else if (!RuntimeUtilities.IsResolvedDepthAvailable(camera))
			{
				this.Alloc(cmd, ShaderIDs.DepthCopy, MultiScaleVO.MipLevel.Original, RenderTextureFormat.RFloat, false);
				renderTargetIdentifier = new RenderTargetIdentifier(ShaderIDs.DepthCopy);
				cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, renderTargetIdentifier, this.m_PropertySheet, 0, false);
				flag = true;
			}
			else
			{
				renderTargetIdentifier = BuiltinRenderTextureType.ResolvedDepth;
			}
			ComputeShader computeShader = this.m_Resources.computeShaders.multiScaleAODownsample1;
			int kernelIndex = computeShader.FindKernel("main");
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "LinearZ", ShaderIDs.LinearDepth);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS2x", ShaderIDs.LowDepth1);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS4x", ShaderIDs.LowDepth2);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS2xAtlas", ShaderIDs.TiledDepth1);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS4xAtlas", ShaderIDs.TiledDepth2);
			cmd.SetComputeVectorParam(computeShader, "ZBufferParams", this.CalculateZBufferParams(camera));
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "Depth", renderTargetIdentifier);
			cmd.DispatchCompute(computeShader, kernelIndex, this.m_Widths[4], this.m_Heights[4], 1);
			if (flag)
			{
				this.Release(cmd, ShaderIDs.DepthCopy);
			}
			computeShader = this.m_Resources.computeShaders.multiScaleAODownsample2;
			kernelIndex = computeShader.FindKernel("main");
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS4x", ShaderIDs.LowDepth2);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS8x", ShaderIDs.LowDepth3);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS16x", ShaderIDs.LowDepth4);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS8xAtlas", ShaderIDs.TiledDepth3);
			cmd.SetComputeTextureParam(computeShader, kernelIndex, "DS16xAtlas", ShaderIDs.TiledDepth4);
			cmd.DispatchCompute(computeShader, kernelIndex, this.m_Widths[6], this.m_Heights[6], 1);
		}

		private void PushRenderCommands(CommandBuffer cmd, int source, int destination, Vector3 sourceSize, float tanHalfFovH)
		{
			float num = 2f * tanHalfFovH * 10f / sourceSize.x;
			if (RuntimeUtilities.isSinglePassStereoEnabled)
			{
				num *= 2f;
			}
			float num2 = 1f / num;
			for (int i = 0; i < 12; i++)
			{
				this.m_InvThicknessTable[i] = num2 / this.m_SampleThickness[i];
			}
			this.m_SampleWeightTable[0] = 4f * this.m_SampleThickness[0];
			this.m_SampleWeightTable[1] = 4f * this.m_SampleThickness[1];
			this.m_SampleWeightTable[2] = 4f * this.m_SampleThickness[2];
			this.m_SampleWeightTable[3] = 4f * this.m_SampleThickness[3];
			this.m_SampleWeightTable[4] = 4f * this.m_SampleThickness[4];
			this.m_SampleWeightTable[5] = 8f * this.m_SampleThickness[5];
			this.m_SampleWeightTable[6] = 8f * this.m_SampleThickness[6];
			this.m_SampleWeightTable[7] = 8f * this.m_SampleThickness[7];
			this.m_SampleWeightTable[8] = 4f * this.m_SampleThickness[8];
			this.m_SampleWeightTable[9] = 8f * this.m_SampleThickness[9];
			this.m_SampleWeightTable[10] = 8f * this.m_SampleThickness[10];
			this.m_SampleWeightTable[11] = 4f * this.m_SampleThickness[11];
			this.m_SampleWeightTable[0] = 0f;
			this.m_SampleWeightTable[2] = 0f;
			this.m_SampleWeightTable[5] = 0f;
			this.m_SampleWeightTable[7] = 0f;
			this.m_SampleWeightTable[9] = 0f;
			float num3 = 0f;
			float[] sampleWeightTable = this.m_SampleWeightTable;
			for (int j = 0; j < sampleWeightTable.Length; j++)
			{
				float num4 = sampleWeightTable[j];
				num3 += num4;
			}
			for (int k = 0; k < this.m_SampleWeightTable.Length; k++)
			{
				this.m_SampleWeightTable[k] /= num3;
			}
			ComputeShader multiScaleAORender = this.m_Resources.computeShaders.multiScaleAORender;
			int kernelIndex = multiScaleAORender.FindKernel("main_interleaved");
			cmd.SetComputeFloatParams(multiScaleAORender, "gInvThicknessTable", this.m_InvThicknessTable);
			cmd.SetComputeFloatParams(multiScaleAORender, "gSampleWeightTable", this.m_SampleWeightTable);
			cmd.SetComputeVectorParam(multiScaleAORender, "gInvSliceDimension", new Vector2(1f / sourceSize.x, 1f / sourceSize.y));
			cmd.SetComputeVectorParam(multiScaleAORender, "AdditionalParams", new Vector2(-1f / this.m_Settings.thicknessModifier.value, this.m_Settings.intensity.value));
			cmd.SetComputeTextureParam(multiScaleAORender, kernelIndex, "DepthTex", source);
			cmd.SetComputeTextureParam(multiScaleAORender, kernelIndex, "Occlusion", destination);
			uint num5;
			uint num6;
			uint num7;
			multiScaleAORender.GetKernelThreadGroupSizes(kernelIndex, out num5, out num6, out num7);
			cmd.DispatchCompute(multiScaleAORender, kernelIndex, ((int)sourceSize.x + (int)num5 - 1) / (int)num5, ((int)sourceSize.y + (int)num6 - 1) / (int)num6, ((int)sourceSize.z + (int)num7 - 1) / (int)num7);
		}

		private void PushUpsampleCommands(CommandBuffer cmd, int lowResDepth, int interleavedAO, int highResDepth, int? highResAO, RenderTargetIdentifier dest, Vector3 lowResDepthSize, Vector2 highResDepthSize, bool invert = false)
		{
			ComputeShader multiScaleAOUpsample = this.m_Resources.computeShaders.multiScaleAOUpsample;
			int kernelIndex = multiScaleAOUpsample.FindKernel(highResAO.HasValue ? "main_blendout" : ((!invert) ? "main" : "main_invert"));
			float num = 1920f / lowResDepthSize.x;
			float num2 = 1f - Mathf.Pow(10f, this.m_Settings.blurTolerance.value) * num;
			num2 *= num2;
			float num3 = Mathf.Pow(10f, this.m_Settings.upsampleTolerance.value);
			float x = 1f / (Mathf.Pow(10f, this.m_Settings.noiseFilterTolerance.value) + num3);
			cmd.SetComputeVectorParam(multiScaleAOUpsample, "InvLowResolution", new Vector2(1f / lowResDepthSize.x, 1f / lowResDepthSize.y));
			cmd.SetComputeVectorParam(multiScaleAOUpsample, "InvHighResolution", new Vector2(1f / highResDepthSize.x, 1f / highResDepthSize.y));
			cmd.SetComputeVectorParam(multiScaleAOUpsample, "AdditionalParams", new Vector4(x, num, num2, num3));
			cmd.SetComputeTextureParam(multiScaleAOUpsample, kernelIndex, "LoResDB", lowResDepth);
			cmd.SetComputeTextureParam(multiScaleAOUpsample, kernelIndex, "HiResDB", highResDepth);
			cmd.SetComputeTextureParam(multiScaleAOUpsample, kernelIndex, "LoResAO1", interleavedAO);
			if (highResAO.HasValue)
			{
				cmd.SetComputeTextureParam(multiScaleAOUpsample, kernelIndex, "HiResAO", highResAO.Value);
			}
			cmd.SetComputeTextureParam(multiScaleAOUpsample, kernelIndex, "AoResult", dest);
			int threadGroupsX = ((int)highResDepthSize.x + 17) / 16;
			int threadGroupsY = ((int)highResDepthSize.y + 17) / 16;
			cmd.DispatchCompute(multiScaleAOUpsample, kernelIndex, threadGroupsX, threadGroupsY, 1);
		}

		private void PushReleaseCommands(CommandBuffer cmd)
		{
			this.Release(cmd, ShaderIDs.LinearDepth);
			this.Release(cmd, ShaderIDs.LowDepth1);
			this.Release(cmd, ShaderIDs.LowDepth1);
			this.Release(cmd, ShaderIDs.LowDepth1);
			this.Release(cmd, ShaderIDs.LowDepth1);
			this.Release(cmd, ShaderIDs.TiledDepth1);
			this.Release(cmd, ShaderIDs.TiledDepth2);
			this.Release(cmd, ShaderIDs.TiledDepth3);
			this.Release(cmd, ShaderIDs.TiledDepth4);
			this.Release(cmd, ShaderIDs.Occlusion1);
			this.Release(cmd, ShaderIDs.Occlusion2);
			this.Release(cmd, ShaderIDs.Occlusion3);
			this.Release(cmd, ShaderIDs.Occlusion4);
			this.Release(cmd, ShaderIDs.Combined1);
			this.Release(cmd, ShaderIDs.Combined2);
			this.Release(cmd, ShaderIDs.Combined3);
		}

		private void PreparePropertySheet(PostProcessRenderContext context)
		{
			PropertySheet propertySheet = context.propertySheets.Get(this.m_Resources.shaders.multiScaleAO);
			propertySheet.ClearKeywords();
			propertySheet.properties.SetVector(ShaderIDs.AOColor, Color.white - this.m_Settings.color.value);
			this.m_PropertySheet = propertySheet;
		}

		private void CheckAOTexture(PostProcessRenderContext context)
		{
			if (this.m_AmbientOnlyAO == null || !this.m_AmbientOnlyAO.IsCreated() || this.m_AmbientOnlyAO.width != context.width || this.m_AmbientOnlyAO.height != context.height)
			{
				RuntimeUtilities.Destroy(this.m_AmbientOnlyAO);
				this.m_AmbientOnlyAO = new RenderTexture(context.width, context.height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear)
				{
					hideFlags = HideFlags.DontSave,
					filterMode = FilterMode.Point,
					enableRandomWrite = true
				};
				this.m_AmbientOnlyAO.Create();
			}
		}

		private void PushDebug(PostProcessRenderContext context)
		{
			if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion))
			{
				context.PushDebugOverlay(context.command, this.m_AmbientOnlyAO, this.m_PropertySheet, 3);
			}
		}

		public void RenderAfterOpaque(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Ambient Occlusion");
			this.SetResources(context.resources);
			this.PreparePropertySheet(context);
			this.CheckAOTexture(context);
			if (context.camera.actualRenderingPath == RenderingPath.Forward && RenderSettings.fog)
			{
				this.m_PropertySheet.EnableKeyword("APPLY_FORWARD_FOG");
				this.m_PropertySheet.properties.SetVector(ShaderIDs.FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
			}
			this.GenerateAOMap(command, context.camera, this.m_AmbientOnlyAO, null, false);
			this.PushDebug(context);
			command.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, this.m_AmbientOnlyAO);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, BuiltinRenderTextureType.CameraTarget, this.m_PropertySheet, 2, false);
			command.EndSample("Ambient Occlusion");
		}

		public void RenderAmbientOnly(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Ambient Occlusion Render");
			this.SetResources(context.resources);
			this.PreparePropertySheet(context);
			this.CheckAOTexture(context);
			this.GenerateAOMap(command, context.camera, this.m_AmbientOnlyAO, null, false);
			this.PushDebug(context);
			command.EndSample("Ambient Occlusion Render");
		}

		public void CompositeAmbientOnly(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Ambient Occlusion Composite");
			command.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, this.m_AmbientOnlyAO);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, this.m_MRT, BuiltinRenderTextureType.CameraTarget, this.m_PropertySheet, 1, false);
			command.EndSample("Ambient Occlusion Composite");
		}

		public void Release()
		{
			RuntimeUtilities.Destroy(this.m_AmbientOnlyAO);
			this.m_AmbientOnlyAO = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class ScalableAO : IAmbientOcclusionMethod
	{
		private enum Pass
		{
			OcclusionEstimationForward,
			OcclusionEstimationDeferred,
			HorizontalBlurForward,
			HorizontalBlurDeferred,
			VerticalBlur,
			CompositionForward,
			CompositionDeferred,
			DebugOverlay
		}

		private RenderTexture m_Result;

		private PropertySheet m_PropertySheet;

		private AmbientOcclusion m_Settings;

		private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[]
		{
			BuiltinRenderTextureType.GBuffer0,
			BuiltinRenderTextureType.CameraTarget
		};

		private readonly int[] m_SampleCount = new int[]
		{
			4,
			6,
			10,
			8,
			12
		};

		public ScalableAO(AmbientOcclusion settings)
		{
			this.m_Settings = settings;
		}

		public DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.DepthNormals;
		}

		private void DoLazyInitialization(PostProcessRenderContext context)
		{
			this.m_PropertySheet = context.propertySheets.Get(context.resources.shaders.scalableAO);
			bool flag = false;
			if (this.m_Result == null || !this.m_Result.IsCreated())
			{
				this.m_Result = context.GetScreenSpaceTemporaryRT(0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear, 0, 0);
				this.m_Result.hideFlags = HideFlags.DontSave;
				this.m_Result.filterMode = FilterMode.Bilinear;
				flag = true;
			}
			else if (this.m_Result.width != context.width || this.m_Result.height != context.height)
			{
				this.m_Result.Release();
				this.m_Result.width = context.width;
				this.m_Result.height = context.height;
				flag = true;
			}
			if (flag)
			{
				this.m_Result.Create();
			}
		}

		private void Render(PostProcessRenderContext context, CommandBuffer cmd, int occlusionSource)
		{
			this.DoLazyInitialization(context);
			this.m_Settings.radius.value = Mathf.Max(this.m_Settings.radius.value, 0.0001f);
			bool flag = this.m_Settings.quality.value < AmbientOcclusionQuality.High;
			float value = this.m_Settings.intensity.value;
			float value2 = this.m_Settings.radius.value;
			float z = (!flag) ? 1f : 0.5f;
			float w = (float)this.m_SampleCount[(int)this.m_Settings.quality.value];
			PropertySheet propertySheet = this.m_PropertySheet;
			propertySheet.ClearKeywords();
			propertySheet.properties.SetVector(ShaderIDs.AOParams, new Vector4(value, value2, z, w));
			propertySheet.properties.SetVector(ShaderIDs.AOColor, Color.white - this.m_Settings.color.value);
			if (context.camera.actualRenderingPath == RenderingPath.Forward && RenderSettings.fog)
			{
				propertySheet.EnableKeyword("APPLY_FORWARD_FOG");
				propertySheet.properties.SetVector(ShaderIDs.FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
			}
			int num = (!flag) ? 1 : 2;
			int occlusionTexture = ShaderIDs.OcclusionTexture1;
			int widthOverride = context.width / num;
			int heightOverride = context.height / num;
			context.GetScreenSpaceTemporaryRT(cmd, occlusionTexture, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear, FilterMode.Bilinear, widthOverride, heightOverride);
			cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, occlusionTexture, propertySheet, occlusionSource, false);
			int occlusionTexture2 = ShaderIDs.OcclusionTexture2;
			context.GetScreenSpaceTemporaryRT(cmd, occlusionTexture2, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear, FilterMode.Bilinear, 0, 0);
			cmd.BlitFullscreenTriangle(occlusionTexture, occlusionTexture2, propertySheet, 2 + occlusionSource, false);
			cmd.ReleaseTemporaryRT(occlusionTexture);
			cmd.BlitFullscreenTriangle(occlusionTexture2, this.m_Result, propertySheet, 4, false);
			cmd.ReleaseTemporaryRT(occlusionTexture2);
			if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion))
			{
				context.PushDebugOverlay(cmd, this.m_Result, propertySheet, 7);
			}
		}

		public void RenderAfterOpaque(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Ambient Occlusion");
			this.Render(context, command, 0);
			command.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, this.m_Result);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, BuiltinRenderTextureType.CameraTarget, this.m_PropertySheet, 5, false);
			command.EndSample("Ambient Occlusion");
		}

		public void RenderAmbientOnly(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Ambient Occlusion Render");
			this.Render(context, command, 1);
			command.EndSample("Ambient Occlusion Render");
		}

		public void CompositeAmbientOnly(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Ambient Occlusion Composite");
			command.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, this.m_Result);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, this.m_MRT, BuiltinRenderTextureType.CameraTarget, this.m_PropertySheet, 6, false);
			command.EndSample("Ambient Occlusion Composite");
		}

		public void Release()
		{
			RuntimeUtilities.Destroy(this.m_Result);
			this.m_Result = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum ScreenSpaceReflectionPreset
	{
		Lower,
		Low,
		Medium,
		High,
		Higher,
		Ultra,
		Overkill,
		Custom
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum ScreenSpaceReflectionResolution
	{
		Downsampled,
		FullSize,
		Supersampled
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class ScreenSpaceReflectionPresetParameter : ParameterOverride<ScreenSpaceReflectionPreset>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class ScreenSpaceReflectionResolutionParameter : ParameterOverride<ScreenSpaceReflectionResolution>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(ScreenSpaceReflectionsRenderer), "Unity/Screen-space reflections", true)]
	[Serializable]
	public sealed class ScreenSpaceReflections : PostProcessEffectSettings
	{
		[Tooltip("Choose a quality preset, or use \"Custom\" to fine tune it. Don't use a preset higher than \"Medium\" if you care about performances on consoles.")]
		public ScreenSpaceReflectionPresetParameter preset = new ScreenSpaceReflectionPresetParameter
		{
			value = ScreenSpaceReflectionPreset.Medium
		};

		[Range(0f, 256f), Tooltip("Maximum iteration count.")]
		public IntParameter maximumIterationCount = new IntParameter
		{
			value = 16
		};

		[Tooltip("Changes the size of the SSR buffer. Downsample it to maximize performances or supersample it to get slow but higher quality results.")]
		public ScreenSpaceReflectionResolutionParameter resolution = new ScreenSpaceReflectionResolutionParameter
		{
			value = ScreenSpaceReflectionResolution.Downsampled
		};

		[Range(1f, 64f), Tooltip("Ray thickness. Lower values are more expensive but allow the effect to detect smaller details.")]
		public FloatParameter thickness = new FloatParameter
		{
			value = 8f
		};

		[Tooltip("Maximum distance to traverse after which it will stop drawing reflections.")]
		public FloatParameter maximumMarchDistance = new FloatParameter
		{
			value = 100f
		};

		[Range(0f, 1f), Tooltip("Fades reflections close to the near planes.")]
		public FloatParameter distanceFade = new FloatParameter
		{
			value = 0.5f
		};

		[Range(0f, 1f), Tooltip("Fades reflections close to the screen edges.")]
		public FloatParameter vignette = new FloatParameter
		{
			value = 0.5f
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled && context.camera.actualRenderingPath == RenderingPath.DeferredShading && SystemInfo.supportsMotionVectors && SystemInfo.supportsComputeShaders && SystemInfo.copyTextureSupport > CopyTextureSupport.None;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class ScreenSpaceReflectionsRenderer : PostProcessEffectRenderer<ScreenSpaceReflections>
	{
		private class QualityPreset
		{
			public int maximumIterationCount;

			public float thickness;

			public ScreenSpaceReflectionResolution downsampling;
		}

		private enum Pass
		{
			Test,
			Resolve,
			Reproject,
			Composite
		}

		private RenderTexture m_Resolve;

		private RenderTexture m_History;

		private int[] m_MipIDs;

		private readonly ScreenSpaceReflectionsRenderer.QualityPreset[] m_Presets = new ScreenSpaceReflectionsRenderer.QualityPreset[]
		{
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 10,
				thickness = 32f,
				downsampling = ScreenSpaceReflectionResolution.Downsampled
			},
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 16,
				thickness = 32f,
				downsampling = ScreenSpaceReflectionResolution.Downsampled
			},
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 32,
				thickness = 16f,
				downsampling = ScreenSpaceReflectionResolution.Downsampled
			},
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 48,
				thickness = 8f,
				downsampling = ScreenSpaceReflectionResolution.Downsampled
			},
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 16,
				thickness = 32f,
				downsampling = ScreenSpaceReflectionResolution.FullSize
			},
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 48,
				thickness = 16f,
				downsampling = ScreenSpaceReflectionResolution.FullSize
			},
			new ScreenSpaceReflectionsRenderer.QualityPreset
			{
				maximumIterationCount = 128,
				thickness = 12f,
				downsampling = ScreenSpaceReflectionResolution.Supersampled
			}
		};

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		internal void CheckRT(ref RenderTexture rt, int width, int height, RenderTextureFormat format, FilterMode filterMode, bool useMipMap)
		{
			if (rt == null || !rt.IsCreated() || rt.width != width || rt.height != height)
			{
				if (rt != null)
				{
					rt.Release();
				}
				rt = new RenderTexture(width, height, 0, format)
				{
					filterMode = filterMode,
					useMipMap = useMipMap,
					autoGenerateMips = false,
					hideFlags = HideFlags.HideAndDontSave
				};
				rt.Create();
			}
		}

		public override void Render(PostProcessRenderContext context)
		{
			CommandBuffer command = context.command;
			command.BeginSample("Screen-space Reflections");
			if (base.settings.preset.value != ScreenSpaceReflectionPreset.Custom)
			{
				int value = (int)base.settings.preset.value;
				base.settings.maximumIterationCount.value = this.m_Presets[value].maximumIterationCount;
				base.settings.thickness.value = this.m_Presets[value].thickness;
				base.settings.resolution.value = this.m_Presets[value].downsampling;
			}
			base.settings.maximumMarchDistance.value = Mathf.Max(0f, base.settings.maximumMarchDistance.value);
			int num = Mathf.ClosestPowerOfTwo(Mathf.Min(context.width, context.height));
			if (base.settings.resolution.value == ScreenSpaceReflectionResolution.Downsampled)
			{
				num >>= 1;
			}
			else if (base.settings.resolution.value == ScreenSpaceReflectionResolution.Supersampled)
			{
				num <<= 1;
			}
			int num2 = Mathf.FloorToInt(Mathf.Log((float)num, 2f) - 3f);
			num2 = Mathf.Min(num2, 12);
			this.CheckRT(ref this.m_Resolve, num, num, context.sourceFormat, FilterMode.Trilinear, true);
			Texture2D texture2D = context.resources.blueNoise256[0];
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.screenSpaceReflections);
			propertySheet.properties.SetTexture(ShaderIDs.Noise, texture2D);
			Matrix4x4 matrix4x = default(Matrix4x4);
			matrix4x.SetRow(0, new Vector4((float)num * 0.5f, 0f, 0f, (float)num * 0.5f));
			matrix4x.SetRow(1, new Vector4(0f, (float)num * 0.5f, 0f, (float)num * 0.5f));
			matrix4x.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
			matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
			Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(context.camera.projectionMatrix, false);
			matrix4x *= gPUProjectionMatrix;
			propertySheet.properties.SetMatrix(ShaderIDs.ViewMatrix, context.camera.worldToCameraMatrix);
			propertySheet.properties.SetMatrix(ShaderIDs.InverseViewMatrix, context.camera.worldToCameraMatrix.inverse);
			propertySheet.properties.SetMatrix(ShaderIDs.InverseProjectionMatrix, gPUProjectionMatrix.inverse);
			propertySheet.properties.SetMatrix(ShaderIDs.ScreenSpaceProjectionMatrix, matrix4x);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(base.settings.vignette.value, base.settings.distanceFade.value, base.settings.maximumMarchDistance.value, (float)num2));
			propertySheet.properties.SetVector(ShaderIDs.Params2, new Vector4((float)context.width / (float)context.height, (float)num / (float)texture2D.width, base.settings.thickness.value, (float)base.settings.maximumIterationCount.value));
			command.GetTemporaryRT(ShaderIDs.Test, num, num, 0, FilterMode.Point, context.sourceFormat);
			command.BlitFullscreenTriangle(context.source, ShaderIDs.Test, propertySheet, 0, false);
			if (context.isSceneView)
			{
				command.BlitFullscreenTriangle(context.source, this.m_Resolve, propertySheet, 1, false);
			}
			else
			{
				this.CheckRT(ref this.m_History, num, num, context.sourceFormat, FilterMode.Bilinear, false);
				if (this.m_ResetHistory)
				{
					context.command.BlitFullscreenTriangle(context.source, this.m_History, false);
					this.m_ResetHistory = false;
				}
				command.GetTemporaryRT(ShaderIDs.SSRResolveTemp, num, num, 0, FilterMode.Bilinear, context.sourceFormat);
				command.BlitFullscreenTriangle(context.source, ShaderIDs.SSRResolveTemp, propertySheet, 1, false);
				propertySheet.properties.SetTexture(ShaderIDs.History, this.m_History);
				command.BlitFullscreenTriangle(ShaderIDs.SSRResolveTemp, this.m_Resolve, propertySheet, 2, false);
				command.CopyTexture(this.m_Resolve, 0, 0, this.m_History, 0, 0);
				command.ReleaseTemporaryRT(ShaderIDs.SSRResolveTemp);
			}
			command.ReleaseTemporaryRT(ShaderIDs.Test);
			if (this.m_MipIDs == null || this.m_MipIDs.Length == 0)
			{
				this.m_MipIDs = new int[12];
				for (int i = 0; i < 12; i++)
				{
					this.m_MipIDs[i] = Shader.PropertyToID("_SSRGaussianMip" + i);
				}
			}
			ComputeShader gaussianDownsample = context.resources.computeShaders.gaussianDownsample;
			int kernelIndex = gaussianDownsample.FindKernel("KMain");
			RenderTargetIdentifier rt = new RenderTargetIdentifier(this.m_Resolve);
			for (int j = 0; j < num2; j++)
			{
				num >>= 1;
				command.GetTemporaryRT(this.m_MipIDs[j], num, num, 0, FilterMode.Bilinear, context.sourceFormat, RenderTextureReadWrite.Default, 1, true);
				command.SetComputeTextureParam(gaussianDownsample, kernelIndex, "_Source", rt);
				command.SetComputeTextureParam(gaussianDownsample, kernelIndex, "_Result", this.m_MipIDs[j]);
				command.SetComputeVectorParam(gaussianDownsample, "_Size", new Vector4((float)num, (float)num, 1f / (float)num, 1f / (float)num));
				command.DispatchCompute(gaussianDownsample, kernelIndex, num / 8, num / 8, 1);
				command.CopyTexture(this.m_MipIDs[j], 0, 0, this.m_Resolve, 0, j + 1);
				rt = this.m_MipIDs[j];
			}
			for (int k = 0; k < num2; k++)
			{
				command.ReleaseTemporaryRT(this.m_MipIDs[k]);
			}
			propertySheet.properties.SetTexture(ShaderIDs.Resolve, this.m_Resolve);
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 3, false);
			command.EndSample("Screen-space Reflections");
		}

		public override void Release()
		{
			RuntimeUtilities.Destroy(this.m_Resolve);
			RuntimeUtilities.Destroy(this.m_History);
			this.m_Resolve = null;
			this.m_History = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class SubpixelMorphologicalAntialiasing
	{
		private enum Pass
		{
			EdgeDetection,
			BlendWeights,
			NeighborhoodBlending
		}

		public bool IsSupported()
		{
			return !RuntimeUtilities.isSinglePassStereoEnabled;
		}

		internal void Render(PostProcessRenderContext context)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.subpixelMorphologicalAntialiasing);
			propertySheet.properties.SetTexture("_AreaTex", context.resources.smaaLuts.area);
			propertySheet.properties.SetTexture("_SearchTex", context.resources.smaaLuts.search);
			CommandBuffer command = context.command;
			command.BeginSample("SubpixelMorphologicalAntialiasing");
			command.GetTemporaryRT(ShaderIDs.SMAA_Flip, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat, RenderTextureReadWrite.Linear);
			command.GetTemporaryRT(ShaderIDs.SMAA_Flop, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat, RenderTextureReadWrite.Linear);
			command.BlitFullscreenTriangle(context.source, ShaderIDs.SMAA_Flip, propertySheet, 0, true);
			command.BlitFullscreenTriangle(ShaderIDs.SMAA_Flip, ShaderIDs.SMAA_Flop, propertySheet, 1, false);
			command.SetGlobalTexture("_BlendTex", ShaderIDs.SMAA_Flop);
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2, false);
			command.ReleaseTemporaryRT(ShaderIDs.SMAA_Flip);
			command.ReleaseTemporaryRT(ShaderIDs.SMAA_Flop);
			command.EndSample("SubpixelMorphologicalAntialiasing");
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class TemporalAntialiasing
	{
		private enum Pass
		{
			SolverDilate,
			SolverNoDilate
		}

		[Range(0.1f, 1f), Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable but blurrier output.")]
		public float jitterSpread = 0.75f;

		[Range(0f, 3f), Tooltip("Controls the amount of sharpening applied to the color buffer. High values may introduce dark-border artifacts.")]
		public float sharpness = 0.25f;

		[Range(0f, 0.99f), Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
		public float stationaryBlending = 0.95f;

		[Range(0f, 0.99f), Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
		public float motionBlending = 0.85f;

		public Func<Camera, Vector2, Matrix4x4> jitteredMatrixFunc;

		private readonly RenderTargetIdentifier[] m_Mrt = new RenderTargetIdentifier[2];

		private bool m_ResetHistory = true;

		private const int k_SampleCount = 8;

		private int m_SampleIndex;

		private const int k_NumEyes = 2;

		private const int k_NumHistoryTextures = 2;

		private readonly RenderTexture[][] m_HistoryTextures = new RenderTexture[2][];

		private int[] m_HistoryPingPong = new int[2];

		public Vector2 jitter
		{
			get;
			private set;
		}

		public bool IsSupported()
		{
			return SystemInfo.supportedRenderTargetCount >= 2 && SystemInfo.supportsMotionVectors && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2;
		}

		internal DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		internal void ResetHistory()
		{
			this.m_ResetHistory = true;
		}

		private Vector2 GenerateRandomOffset()
		{
			Vector2 result = new Vector2(HaltonSeq.Get((this.m_SampleIndex & 1023) + 1, 2) - 0.5f, HaltonSeq.Get((this.m_SampleIndex & 1023) + 1, 3) - 0.5f);
			if (++this.m_SampleIndex >= 8)
			{
				this.m_SampleIndex = 0;
			}
			return result;
		}

		public Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
		{
			this.jitter = this.GenerateRandomOffset();
			this.jitter *= this.jitterSpread;
			Matrix4x4 result;
			if (this.jitteredMatrixFunc != null)
			{
				result = this.jitteredMatrixFunc(camera, this.jitter);
			}
			else
			{
				result = ((!camera.orthographic) ? RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, this.jitter) : RuntimeUtilities.GetJitteredOrthographicProjectionMatrix(camera, this.jitter));
			}
			this.jitter = new Vector2(this.jitter.x / (float)camera.pixelWidth, this.jitter.y / (float)camera.pixelHeight);
			return result;
		}

		public void ConfigureJitteredProjectionMatrix(PostProcessRenderContext context)
		{
			Camera camera = context.camera;
			camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
			camera.projectionMatrix = this.GetJitteredProjectionMatrix(camera);
			camera.useJitteredProjectionMatrixForTransparentRendering = false;
		}

		public void ConfigureStereoJitteredProjectionMatrices(PostProcessRenderContext context)
		{
			Camera camera = context.camera;
			this.jitter = this.GenerateRandomOffset();
			this.jitter *= this.jitterSpread;
			for (Camera.StereoscopicEye stereoscopicEye = Camera.StereoscopicEye.Left; stereoscopicEye <= Camera.StereoscopicEye.Right; stereoscopicEye++)
			{
				context.camera.CopyStereoDeviceProjectionMatrixToNonJittered(stereoscopicEye);
				Matrix4x4 stereoNonJitteredProjectionMatrix = context.camera.GetStereoNonJitteredProjectionMatrix(stereoscopicEye);
				Matrix4x4 matrix = RuntimeUtilities.GenerateJitteredProjectionMatrixFromOriginal(context, stereoNonJitteredProjectionMatrix, this.jitter);
				context.camera.SetStereoProjectionMatrix(stereoscopicEye, matrix);
			}
			this.jitter = new Vector2(this.jitter.x / (float)context.screenWidth, this.jitter.y / (float)context.screenHeight);
			camera.useJitteredProjectionMatrixForTransparentRendering = false;
		}

		private void GenerateHistoryName(RenderTexture rt, int id, PostProcessRenderContext context)
		{
			rt.name = "Temporal Anti-aliasing History id #" + id;
			if (context.stereoActive)
			{
				rt.name = rt.name + " for eye " + context.xrActiveEye;
			}
		}

		private RenderTexture CheckHistory(int id, PostProcessRenderContext context)
		{
			int xrActiveEye = context.xrActiveEye;
			if (this.m_HistoryTextures[xrActiveEye] == null)
			{
				this.m_HistoryTextures[xrActiveEye] = new RenderTexture[2];
			}
			RenderTexture renderTexture = this.m_HistoryTextures[xrActiveEye][id];
			if (this.m_ResetHistory || renderTexture == null || !renderTexture.IsCreated())
			{
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat, RenderTextureReadWrite.Default, 0, 0);
				this.GenerateHistoryName(renderTexture, id, context);
				renderTexture.filterMode = FilterMode.Bilinear;
				this.m_HistoryTextures[xrActiveEye][id] = renderTexture;
				context.command.BlitFullscreenTriangle(context.source, renderTexture, false);
			}
			else if (renderTexture.width != context.width || renderTexture.height != context.height)
			{
				RenderTexture screenSpaceTemporaryRT = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat, RenderTextureReadWrite.Default, 0, 0);
				this.GenerateHistoryName(screenSpaceTemporaryRT, id, context);
				screenSpaceTemporaryRT.filterMode = FilterMode.Bilinear;
				this.m_HistoryTextures[xrActiveEye][id] = screenSpaceTemporaryRT;
				context.command.BlitFullscreenTriangle(renderTexture, screenSpaceTemporaryRT, false);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			return this.m_HistoryTextures[xrActiveEye][id];
		}

		internal void Render(PostProcessRenderContext context)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.temporalAntialiasing);
			CommandBuffer command = context.command;
			command.BeginSample("TemporalAntialiasing");
			int num = this.m_HistoryPingPong[context.xrActiveEye];
			RenderTexture value = this.CheckHistory(++num % 2, context);
			RenderTexture tex = this.CheckHistory(++num % 2, context);
			this.m_HistoryPingPong[context.xrActiveEye] = (num + 1) % 2;
			propertySheet.properties.SetVector(ShaderIDs.Jitter, this.jitter);
			propertySheet.properties.SetFloat(ShaderIDs.Sharpness, this.sharpness);
			propertySheet.properties.SetVector(ShaderIDs.FinalBlendParameters, new Vector4(this.stationaryBlending, this.motionBlending, 6000f, 0f));
			propertySheet.properties.SetTexture(ShaderIDs.HistoryTex, value);
			int pass = (!context.camera.orthographic) ? 0 : 1;
			this.m_Mrt[0] = context.destination;
			this.m_Mrt[1] = tex;
			command.BlitFullscreenTriangle(context.source, this.m_Mrt, context.source, propertySheet, pass, false);
			command.EndSample("TemporalAntialiasing");
			this.m_ResetHistory = false;
		}

		internal void Release()
		{
			if (this.m_HistoryTextures != null)
			{
				for (int i = 0; i < this.m_HistoryTextures.Length; i++)
				{
					if (this.m_HistoryTextures[i] != null)
					{
						for (int j = 0; j < this.m_HistoryTextures[i].Length; j++)
						{
							RenderTexture.ReleaseTemporary(this.m_HistoryTextures[i][j]);
							this.m_HistoryTextures[i][j] = null;
						}
						this.m_HistoryTextures[i] = null;
					}
				}
			}
			this.m_SampleIndex = 0;
			this.m_HistoryPingPong[0] = 0;
			this.m_HistoryPingPong[1] = 0;
			this.ResetHistory();
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum VignetteMode
	{
		Classic,
		Masked
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class VignetteModeParameter : ParameterOverride<VignetteMode>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[PostProcess(typeof(VignetteRenderer), "Unity/Vignette", true)]
	[Serializable]
	public sealed class Vignette : PostProcessEffectSettings
	{
		[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
		public VignetteModeParameter mode = new VignetteModeParameter
		{
			value = VignetteMode.Classic
		};

		[Tooltip("Vignette color. Use the alpha channel for transparency.")]
		public ColorParameter color = new ColorParameter
		{
			value = new Color(0f, 0f, 0f, 1f)
		};

		[Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
		public Vector2Parameter center = new Vector2Parameter
		{
			value = new Vector2(0.5f, 0.5f)
		};

		[Range(0f, 1f), Tooltip("Amount of vignetting on screen.")]
		public FloatParameter intensity = new FloatParameter
		{
			value = 0f
		};

		[Range(0.01f, 1f), Tooltip("Smoothness of the vignette borders.")]
		public FloatParameter smoothness = new FloatParameter
		{
			value = 0.2f
		};

		[Range(0f, 1f), Tooltip("Lower values will make a square-ish vignette.")]
		public FloatParameter roundness = new FloatParameter
		{
			value = 1f
		};

		[Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
		public BoolParameter rounded = new BoolParameter
		{
			value = false
		};

		[Tooltip("A black and white mask to use as a vignette.")]
		public TextureParameter mask = new TextureParameter
		{
			value = null
		};

		[Range(0f, 1f), Tooltip("Mask opacity.")]
		public FloatParameter opacity = new FloatParameter
		{
			value = 1f
		};

		public override bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value && ((this.mode.value == VignetteMode.Classic && this.intensity.value > 0f) || (this.mode.value == VignetteMode.Masked && this.opacity.value > 0f && this.mask.value != null));
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class VignetteRenderer : PostProcessEffectRenderer<Vignette>
	{
		public override void Render(PostProcessRenderContext context)
		{
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("VIGNETTE");
			uberSheet.properties.SetColor(ShaderIDs.Vignette_Color, base.settings.color.value);
			if (base.settings.mode == VignetteMode.Classic)
			{
				uberSheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 0f);
				uberSheet.properties.SetVector(ShaderIDs.Vignette_Center, base.settings.center.value);
				float z = (1f - base.settings.roundness.value) * 6f + base.settings.roundness.value;
				uberSheet.properties.SetVector(ShaderIDs.Vignette_Settings, new Vector4(base.settings.intensity.value * 3f, base.settings.smoothness.value * 5f, z, (!base.settings.rounded.value) ? 0f : 1f));
			}
			else
			{
				uberSheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 1f);
				uberSheet.properties.SetTexture(ShaderIDs.Vignette_Mask, base.settings.mask.value);
				uberSheet.properties.SetFloat(ShaderIDs.Vignette_Opacity, Mathf.Clamp01(base.settings.opacity.value));
			}
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class HistogramMonitor : Monitor
	{
		public enum Channel
		{
			Red,
			Green,
			Blue,
			Master
		}

		public int width = 512;

		public int height = 256;

		public HistogramMonitor.Channel channel = HistogramMonitor.Channel.Master;

		private ComputeBuffer m_Data;

		private int m_NumBins;

		private int m_ThreadGroupSizeX;

		private int m_ThreadGroupSizeY;

		internal override void OnEnable()
		{
			this.m_ThreadGroupSizeX = 16;
			if (RuntimeUtilities.isAndroidOpenGL)
			{
				this.m_NumBins = 128;
				this.m_ThreadGroupSizeY = 8;
			}
			else
			{
				this.m_NumBins = 256;
				this.m_ThreadGroupSizeY = 16;
			}
		}

		internal override void OnDisable()
		{
			base.OnDisable();
			if (this.m_Data != null)
			{
				this.m_Data.Release();
			}
			this.m_Data = null;
		}

		internal override bool NeedsHalfRes()
		{
			return true;
		}

		internal override void Render(PostProcessRenderContext context)
		{
			base.CheckOutput(this.width, this.height);
			if (this.m_Data == null)
			{
				this.m_Data = new ComputeBuffer(this.m_NumBins, 4);
			}
			ComputeShader gammaHistogram = context.resources.computeShaders.gammaHistogram;
			CommandBuffer command = context.command;
			command.BeginSample("GammaHistogram");
			int kernelIndex = gammaHistogram.FindKernel("KHistogramClear");
			command.SetComputeBufferParam(gammaHistogram, kernelIndex, "_HistogramBuffer", this.m_Data);
			command.DispatchCompute(gammaHistogram, kernelIndex, Mathf.CeilToInt((float)this.m_NumBins / (float)this.m_ThreadGroupSizeX), 1, 1);
			kernelIndex = gammaHistogram.FindKernel("KHistogramGather");
			Vector4 val = new Vector4((float)(context.width / 2), (float)(context.height / 2), (float)((!RuntimeUtilities.isLinearColorSpace) ? 0 : 1), (float)this.channel);
			command.SetComputeVectorParam(gammaHistogram, "_Params", val);
			command.SetComputeTextureParam(gammaHistogram, kernelIndex, "_Source", ShaderIDs.HalfResFinalCopy);
			command.SetComputeBufferParam(gammaHistogram, kernelIndex, "_HistogramBuffer", this.m_Data);
			command.DispatchCompute(gammaHistogram, kernelIndex, Mathf.CeilToInt(val.x / (float)this.m_ThreadGroupSizeX), Mathf.CeilToInt(val.y / (float)this.m_ThreadGroupSizeY), 1);
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.gammaHistogram);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)this.width, (float)this.height, 0f, 0f));
			propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, this.m_Data);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, base.output, propertySheet, 0, false);
			command.EndSample("GammaHistogram");
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class LightMeterMonitor : Monitor
	{
		public int width = 512;

		public int height = 256;

		public bool showCurves = true;

		internal override void Render(PostProcessRenderContext context)
		{
			base.CheckOutput(this.width, this.height);
			LogHistogram logHistogram = context.logHistogram;
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lightMeter);
			propertySheet.ClearKeywords();
			propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, logHistogram.data);
			Vector4 histogramScaleOffsetRes = logHistogram.GetHistogramScaleOffsetRes(context);
			histogramScaleOffsetRes.z = 1f / (float)this.width;
			histogramScaleOffsetRes.w = 1f / (float)this.height;
			propertySheet.properties.SetVector(ShaderIDs.ScaleOffsetRes, histogramScaleOffsetRes);
			if (context.logLut != null && this.showCurves)
			{
				propertySheet.EnableKeyword("COLOR_GRADING_HDR");
				propertySheet.properties.SetTexture(ShaderIDs.Lut3D, context.logLut);
			}
			AutoExposure autoExposure = context.autoExposure;
			if (autoExposure != null)
			{
				float num = autoExposure.filtering.value.x;
				float num2 = autoExposure.filtering.value.y;
				num2 = Mathf.Clamp(num2, 1.01f, 99f);
				num = Mathf.Clamp(num, 1f, num2 - 0.01f);
				Vector4 value = new Vector4(num * 0.01f, num2 * 0.01f, RuntimeUtilities.Exp2(autoExposure.minLuminance.value), RuntimeUtilities.Exp2(autoExposure.maxLuminance.value));
				propertySheet.EnableKeyword("AUTO_EXPOSURE");
				propertySheet.properties.SetVector(ShaderIDs.Params, value);
			}
			CommandBuffer command = context.command;
			command.BeginSample("LightMeter");
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, base.output, propertySheet, 0, false);
			command.EndSample("LightMeter");
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum MonitorType
	{
		LightMeter,
		Histogram,
		Waveform,
		Vectorscope
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public abstract class Monitor
	{
		internal bool requested;

		public RenderTexture output
		{
			get;
			protected set;
		}

		public bool IsRequestedAndSupported()
		{
			return this.requested && SystemInfo.supportsComputeShaders;
		}

		internal virtual bool NeedsHalfRes()
		{
			return false;
		}

		protected void CheckOutput(int width, int height)
		{
			if (this.output == null || !this.output.IsCreated() || this.output.width != width || this.output.height != height)
			{
				RuntimeUtilities.Destroy(this.output);
				this.output = new RenderTexture(width, height, 0, RenderTextureFormat.ARGB32)
				{
					anisoLevel = 0,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					useMipMap = false
				};
			}
		}

		internal virtual void OnEnable()
		{
		}

		internal virtual void OnDisable()
		{
			RuntimeUtilities.Destroy(this.output);
		}

		internal abstract void Render(PostProcessRenderContext context);
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class VectorscopeMonitor : Monitor
	{
		public int size = 256;

		public float exposure = 0.12f;

		private ComputeBuffer m_Data;

		private int m_ThreadGroupSizeX;

		private int m_ThreadGroupSizeY;

		internal override void OnEnable()
		{
			this.m_ThreadGroupSizeX = 16;
			this.m_ThreadGroupSizeY = ((!RuntimeUtilities.isAndroidOpenGL) ? 16 : 8);
		}

		internal override void OnDisable()
		{
			base.OnDisable();
			if (this.m_Data != null)
			{
				this.m_Data.Release();
			}
			this.m_Data = null;
		}

		internal override bool NeedsHalfRes()
		{
			return true;
		}

		internal override void Render(PostProcessRenderContext context)
		{
			base.CheckOutput(this.size, this.size);
			this.exposure = Mathf.Max(0f, this.exposure);
			int num = this.size * this.size;
			if (this.m_Data == null)
			{
				this.m_Data = new ComputeBuffer(num, 4);
			}
			else if (this.m_Data.count != num)
			{
				this.m_Data.Release();
				this.m_Data = new ComputeBuffer(num, 4);
			}
			ComputeShader vectorscope = context.resources.computeShaders.vectorscope;
			CommandBuffer command = context.command;
			command.BeginSample("Vectorscope");
			Vector4 val = new Vector4((float)(context.width / 2), (float)(context.height / 2), (float)this.size, (float)((!RuntimeUtilities.isLinearColorSpace) ? 0 : 1));
			int kernelIndex = vectorscope.FindKernel("KVectorscopeClear");
			command.SetComputeBufferParam(vectorscope, kernelIndex, "_VectorscopeBuffer", this.m_Data);
			command.SetComputeVectorParam(vectorscope, "_Params", val);
			command.DispatchCompute(vectorscope, kernelIndex, Mathf.CeilToInt((float)this.size / (float)this.m_ThreadGroupSizeX), Mathf.CeilToInt((float)this.size / (float)this.m_ThreadGroupSizeY), 1);
			kernelIndex = vectorscope.FindKernel("KVectorscopeGather");
			command.SetComputeBufferParam(vectorscope, kernelIndex, "_VectorscopeBuffer", this.m_Data);
			command.SetComputeTextureParam(vectorscope, kernelIndex, "_Source", ShaderIDs.HalfResFinalCopy);
			command.DispatchCompute(vectorscope, kernelIndex, Mathf.CeilToInt(val.x / (float)this.m_ThreadGroupSizeX), Mathf.CeilToInt(val.y / (float)this.m_ThreadGroupSizeY), 1);
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.vectorscope);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)this.size, (float)this.size, this.exposure, 0f));
			propertySheet.properties.SetBuffer(ShaderIDs.VectorscopeBuffer, this.m_Data);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, base.output, propertySheet, 0, false);
			command.EndSample("Vectorscope");
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class WaveformMonitor : Monitor
	{
		public float exposure = 0.12f;

		public int height = 256;

		private ComputeBuffer m_Data;

		private int m_ThreadGroupSize;

		private int m_ThreadGroupSizeX;

		private int m_ThreadGroupSizeY;

		internal override void OnEnable()
		{
			this.m_ThreadGroupSizeX = 16;
			if (RuntimeUtilities.isAndroidOpenGL)
			{
				this.m_ThreadGroupSize = 128;
				this.m_ThreadGroupSizeY = 8;
			}
			else
			{
				this.m_ThreadGroupSize = 256;
				this.m_ThreadGroupSizeY = 16;
			}
		}

		internal override void OnDisable()
		{
			base.OnDisable();
			if (this.m_Data != null)
			{
				this.m_Data.Release();
			}
			this.m_Data = null;
		}

		internal override bool NeedsHalfRes()
		{
			return true;
		}

		internal override void Render(PostProcessRenderContext context)
		{
			float num = (float)context.width / 2f / ((float)context.height / 2f);
			int num2 = Mathf.FloorToInt((float)this.height * num);
			base.CheckOutput(num2, this.height);
			this.exposure = Mathf.Max(0f, this.exposure);
			int num3 = num2 * this.height;
			if (this.m_Data == null)
			{
				this.m_Data = new ComputeBuffer(num3, 16);
			}
			else if (this.m_Data.count < num3)
			{
				this.m_Data.Release();
				this.m_Data = new ComputeBuffer(num3, 16);
			}
			ComputeShader waveform = context.resources.computeShaders.waveform;
			CommandBuffer command = context.command;
			command.BeginSample("Waveform");
			Vector4 val = new Vector4((float)num2, (float)this.height, (float)((!RuntimeUtilities.isLinearColorSpace) ? 0 : 1), 0f);
			int kernelIndex = waveform.FindKernel("KWaveformClear");
			command.SetComputeBufferParam(waveform, kernelIndex, "_WaveformBuffer", this.m_Data);
			command.SetComputeVectorParam(waveform, "_Params", val);
			command.DispatchCompute(waveform, kernelIndex, Mathf.CeilToInt((float)num2 / (float)this.m_ThreadGroupSizeX), Mathf.CeilToInt((float)this.height / (float)this.m_ThreadGroupSizeY), 1);
			command.GetTemporaryRT(ShaderIDs.WaveformSource, num2, this.height, 0, FilterMode.Bilinear, context.sourceFormat);
			command.BlitFullscreenTriangle(ShaderIDs.HalfResFinalCopy, ShaderIDs.WaveformSource, false);
			kernelIndex = waveform.FindKernel("KWaveformGather");
			command.SetComputeBufferParam(waveform, kernelIndex, "_WaveformBuffer", this.m_Data);
			command.SetComputeTextureParam(waveform, kernelIndex, "_Source", ShaderIDs.WaveformSource);
			command.SetComputeVectorParam(waveform, "_Params", val);
			command.DispatchCompute(waveform, kernelIndex, num2, Mathf.CeilToInt((float)this.height / (float)this.m_ThreadGroupSize), 1);
			command.ReleaseTemporaryRT(ShaderIDs.WaveformSource);
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.waveform);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)num2, (float)this.height, this.exposure, 0f));
			propertySheet.properties.SetBuffer(ShaderIDs.WaveformBuffer, this.m_Data);
			command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, base.output, propertySheet, 0, false);
			command.EndSample("Waveform");
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public abstract class ParameterOverride
	{
		public bool overrideState;

		internal abstract void Interp(ParameterOverride from, ParameterOverride to, float t);

		public abstract int GetHash();

		public T GetValue<T>()
		{
			return ((ParameterOverride<T>)this).value;
		}

		protected internal virtual void OnEnable()
		{
		}

		protected internal virtual void OnDisable()
		{
		}

		internal abstract void SetValue(ParameterOverride parameter);
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public class ParameterOverride<T> : ParameterOverride
	{
		public T value;

		public ParameterOverride() : this(default(T), false)
		{
		}

		public ParameterOverride(T value) : this(value, false)
		{
		}

		public ParameterOverride(T value, bool overrideState)
		{
			this.value = value;
			this.overrideState = overrideState;
		}

		internal override void Interp(ParameterOverride from, ParameterOverride to, float t)
		{
			this.Interp(from.GetValue<T>(), to.GetValue<T>(), t);
		}

		public virtual void Interp(T from, T to, float t)
		{
			this.value = ((t <= 0f) ? from : to);
		}

		public void Override(T x)
		{
			this.overrideState = true;
			this.value = x;
		}

		internal override void SetValue(ParameterOverride parameter)
		{
			this.value = parameter.GetValue<T>();
		}

		public override int GetHash()
		{
			int num = 17;
			num = num * 23 + this.overrideState.GetHashCode();
			return num * 23 + this.value.GetHashCode();
		}

		public static implicit operator T(ParameterOverride<T> prop)
		{
			return prop.value;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class FloatParameter : ParameterOverride<float>
	{
		public override void Interp(float from, float to, float t)
		{
			this.value = from + (to - from) * t;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class IntParameter : ParameterOverride<int>
	{
		public override void Interp(int from, int to, float t)
		{
			this.value = (int)((float)from + (float)(to - from) * t);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class BoolParameter : ParameterOverride<bool>
	{
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class ColorParameter : ParameterOverride<Color>
	{
		public override void Interp(Color from, Color to, float t)
		{
			this.value.r = from.r + (to.r - from.r) * t;
			this.value.g = from.g + (to.g - from.g) * t;
			this.value.b = from.b + (to.b - from.b) * t;
			this.value.a = from.a + (to.a - from.a) * t;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class Vector2Parameter : ParameterOverride<Vector2>
	{
		public override void Interp(Vector2 from, Vector2 to, float t)
		{
			this.value.x = from.x + (to.x - from.x) * t;
			this.value.y = from.y + (to.y - from.y) * t;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class Vector3Parameter : ParameterOverride<Vector3>
	{
		public override void Interp(Vector3 from, Vector3 to, float t)
		{
			this.value.x = from.x + (to.x - from.x) * t;
			this.value.y = from.y + (to.y - from.y) * t;
			this.value.z = from.z + (to.z - from.z) * t;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class Vector4Parameter : ParameterOverride<Vector4>
	{
		public override void Interp(Vector4 from, Vector4 to, float t)
		{
			this.value.x = from.x + (to.x - from.x) * t;
			this.value.y = from.y + (to.y - from.y) * t;
			this.value.z = from.z + (to.z - from.z) * t;
			this.value.w = from.w + (to.w - from.w) * t;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class SplineParameter : ParameterOverride<Spline>
	{
		protected internal override void OnEnable()
		{
			if (this.value != null)
			{
				this.value.Cache(-2147483648);
			}
		}

		public override void Interp(Spline from, Spline to, float t)
		{
			int renderedFrameCount = Time.renderedFrameCount;
			if (from == null || to == null)
			{
				base.Interp(from, to, t);
				return;
			}
			from.Cache(renderedFrameCount);
			to.Cache(renderedFrameCount);
			for (int i = 0; i < 128; i++)
			{
				float num = from.cachedData[i];
				float num2 = to.cachedData[i];
				this.value.cachedData[i] = num + (num2 - num) * t;
			}
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class TextureParameter : ParameterOverride<Texture>
	{
		public override void Interp(Texture from, Texture to, float t)
		{
			if (from == null || to == null)
			{
				base.Interp(from, to, t);
				return;
			}
			this.value = TextureLerper.instance.Lerp(from, to, t);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PostProcessBundle
	{
		private PostProcessEffectRenderer m_Renderer;

		public PostProcessAttribute attribute
		{
			get;
			private set;
		}

		public PostProcessEffectSettings settings
		{
			get;
			private set;
		}

		internal PostProcessEffectRenderer renderer
		{
			get
			{
				if (this.m_Renderer == null)
				{
					Type renderer = this.attribute.renderer;
					this.m_Renderer = (PostProcessEffectRenderer)Activator.CreateInstance(renderer);
					this.m_Renderer.SetSettings(this.settings);
					this.m_Renderer.Init();
				}
				return this.m_Renderer;
			}
		}

		internal PostProcessBundle(PostProcessEffectSettings settings)
		{
			this.settings = settings;
			this.attribute = settings.GetType().GetAttribute<PostProcessAttribute>();
		}

		internal void Release()
		{
			if (this.m_Renderer != null)
			{
				this.m_Renderer.Release();
			}
			RuntimeUtilities.Destroy(this.settings);
		}

		internal void ResetHistory()
		{
			if (this.m_Renderer != null)
			{
				this.m_Renderer.ResetHistory();
			}
		}

		internal T CastSettings<T>() where T : PostProcessEffectSettings
		{
			return (T)((object)this.settings);
		}

		internal T CastRenderer<T>() where T : PostProcessEffectRenderer
		{
			return (T)((object)this.renderer);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[AddComponentMenu("Rendering/Post-process Debug", 1002), ExecuteInEditMode]
	public sealed class PostProcessDebug : MonoBehaviour
	{
		public PostProcessLayer postProcessLayer;

		private PostProcessLayer m_PreviousPostProcessLayer;

		public bool lightMeter;

		public bool histogram;

		public bool waveform;

		public bool vectorscope;

		public DebugOverlay debugOverlay;

		private Camera m_CurrentCamera;

		private CommandBuffer m_CmdAfterEverything;

		private void OnEnable()
		{
			this.m_CmdAfterEverything = new CommandBuffer
			{
				name = "Post-processing Debug Overlay"
			};
		}

		private void OnDisable()
		{
			if (this.m_CurrentCamera != null)
			{
				this.m_CurrentCamera.RemoveCommandBuffer(CameraEvent.AfterImageEffects, this.m_CmdAfterEverything);
			}
			this.m_CurrentCamera = null;
			this.m_PreviousPostProcessLayer = null;
		}

		private void Update()
		{
			this.UpdateStates();
		}

		private void Reset()
		{
			this.postProcessLayer = base.GetComponent<PostProcessLayer>();
		}

		private void UpdateStates()
		{
			if (this.m_PreviousPostProcessLayer != this.postProcessLayer)
			{
				if (this.m_CurrentCamera != null)
				{
					this.m_CurrentCamera.RemoveCommandBuffer(CameraEvent.AfterImageEffects, this.m_CmdAfterEverything);
					this.m_CurrentCamera = null;
				}
				this.m_PreviousPostProcessLayer = this.postProcessLayer;
				if (this.postProcessLayer != null)
				{
					this.m_CurrentCamera = this.postProcessLayer.GetComponent<Camera>();
					this.m_CurrentCamera.AddCommandBuffer(CameraEvent.AfterImageEffects, this.m_CmdAfterEverything);
				}
			}
			if (this.postProcessLayer == null || !this.postProcessLayer.enabled)
			{
				return;
			}
			if (this.lightMeter)
			{
				this.postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.LightMeter);
			}
			if (this.histogram)
			{
				this.postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Histogram);
			}
			if (this.waveform)
			{
				this.postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Waveform);
			}
			if (this.vectorscope)
			{
				this.postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Vectorscope);
			}
			this.postProcessLayer.debugLayer.RequestDebugOverlay(this.debugOverlay);
		}

		private void OnPostRender()
		{
			this.m_CmdAfterEverything.Clear();
			if (this.postProcessLayer == null || !this.postProcessLayer.enabled || !this.postProcessLayer.debugLayer.debugOverlayActive)
			{
				return;
			}
			this.m_CmdAfterEverything.Blit(this.postProcessLayer.debugLayer.debugOverlayTarget, BuiltinRenderTextureType.CameraTarget);
		}

		private void OnGUI()
		{
			if (this.postProcessLayer == null || !this.postProcessLayer.enabled)
			{
				return;
			}
			Rect rect = new Rect(5f, 5f, 0f, 0f);
			PostProcessDebugLayer debugLayer = this.postProcessLayer.debugLayer;
			this.DrawMonitor(ref rect, debugLayer.lightMeter, this.lightMeter);
			this.DrawMonitor(ref rect, debugLayer.histogram, this.histogram);
			this.DrawMonitor(ref rect, debugLayer.waveform, this.waveform);
			this.DrawMonitor(ref rect, debugLayer.vectorscope, this.vectorscope);
		}

		private void DrawMonitor(ref Rect rect, Monitor monitor, bool enabled)
		{
			if (!enabled || monitor.output == null)
			{
				return;
			}
			rect.width = (float)monitor.output.width;
			rect.height = (float)monitor.output.height;
			GUI.DrawTexture(rect, monitor.output);
			rect.x += (float)monitor.output.width + 5f;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum DebugOverlay
	{
		None,
		Depth,
		Normals,
		MotionVectors,
		NANTracker,
		ColorBlindnessSimulation,
		_,
		AmbientOcclusion,
		BloomBuffer,
		BloomThreshold,
		DepthOfField
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum ColorBlindnessType
	{
		Deuteranopia,
		Protanopia,
		Tritanopia
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class PostProcessDebugLayer
	{
		[Serializable]
		public class OverlaySettings
		{
			[Range(0f, 16f)]
			public float motionColorIntensity = 4f;

			[Range(4f, 128f)]
			public int motionGridSize = 64;

			public ColorBlindnessType colorBlindnessType;

			[Range(0f, 1f)]
			public float colorBlindnessStrength = 1f;
		}

		public LightMeterMonitor lightMeter;

		public HistogramMonitor histogram;

		public WaveformMonitor waveform;

		public VectorscopeMonitor vectorscope;

		private Dictionary<MonitorType, Monitor> m_Monitors;

		private int frameWidth;

		private int frameHeight;

		public PostProcessDebugLayer.OverlaySettings overlaySettings;

		public RenderTexture debugOverlayTarget
		{
			get;
			private set;
		}

		public bool debugOverlayActive
		{
			get;
			private set;
		}

		public DebugOverlay debugOverlay
		{
			get;
			private set;
		}

		internal void OnEnable()
		{
			RuntimeUtilities.CreateIfNull<LightMeterMonitor>(ref this.lightMeter);
			RuntimeUtilities.CreateIfNull<HistogramMonitor>(ref this.histogram);
			RuntimeUtilities.CreateIfNull<WaveformMonitor>(ref this.waveform);
			RuntimeUtilities.CreateIfNull<VectorscopeMonitor>(ref this.vectorscope);
			RuntimeUtilities.CreateIfNull<PostProcessDebugLayer.OverlaySettings>(ref this.overlaySettings);
			this.m_Monitors = new Dictionary<MonitorType, Monitor>
			{
				{
					MonitorType.LightMeter,
					this.lightMeter
				},
				{
					MonitorType.Histogram,
					this.histogram
				},
				{
					MonitorType.Waveform,
					this.waveform
				},
				{
					MonitorType.Vectorscope,
					this.vectorscope
				}
			};
			foreach (KeyValuePair<MonitorType, Monitor> current in this.m_Monitors)
			{
				current.Value.OnEnable();
			}
		}

		internal void OnDisable()
		{
			foreach (KeyValuePair<MonitorType, Monitor> current in this.m_Monitors)
			{
				current.Value.OnDisable();
			}
			this.DestroyDebugOverlayTarget();
		}

		private void DestroyDebugOverlayTarget()
		{
			RuntimeUtilities.Destroy(this.debugOverlayTarget);
			this.debugOverlayTarget = null;
		}

		public void RequestMonitorPass(MonitorType monitor)
		{
			this.m_Monitors[monitor].requested = true;
		}

		public void RequestDebugOverlay(DebugOverlay mode)
		{
			this.debugOverlay = mode;
		}

		internal void SetFrameSize(int width, int height)
		{
			this.frameWidth = width;
			this.frameHeight = height;
			this.debugOverlayActive = false;
		}

		public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
		{
			if (this.debugOverlayTarget == null || !this.debugOverlayTarget.IsCreated() || this.debugOverlayTarget.width != this.frameWidth || this.debugOverlayTarget.height != this.frameHeight)
			{
				RuntimeUtilities.Destroy(this.debugOverlayTarget);
				this.debugOverlayTarget = new RenderTexture(this.frameWidth, this.frameHeight, 0, RenderTextureFormat.ARGB32)
				{
					name = "Debug Overlay Target",
					anisoLevel = 1,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					hideFlags = HideFlags.HideAndDontSave
				};
				this.debugOverlayTarget.Create();
			}
			cmd.BlitFullscreenTriangle(source, this.debugOverlayTarget, sheet, pass, false);
			this.debugOverlayActive = true;
		}

		internal DepthTextureMode GetCameraFlags()
		{
			if (this.debugOverlay == DebugOverlay.Depth)
			{
				return DepthTextureMode.Depth;
			}
			if (this.debugOverlay == DebugOverlay.Normals)
			{
				return DepthTextureMode.DepthNormals;
			}
			if (this.debugOverlay == DebugOverlay.MotionVectors)
			{
				return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
			}
			return DepthTextureMode.None;
		}

		internal void RenderMonitors(PostProcessRenderContext context)
		{
			bool flag = false;
			bool flag2 = false;
			foreach (KeyValuePair<MonitorType, Monitor> current in this.m_Monitors)
			{
				bool flag3 = current.Value.IsRequestedAndSupported();
				flag |= flag3;
				flag2 |= (flag3 && current.Value.NeedsHalfRes());
			}
			if (!flag)
			{
				return;
			}
			CommandBuffer command = context.command;
			command.BeginSample("Monitors");
			if (flag2)
			{
				command.GetTemporaryRT(ShaderIDs.HalfResFinalCopy, context.width / 2, context.height / 2, 0, FilterMode.Bilinear, context.sourceFormat);
				command.Blit(context.destination, ShaderIDs.HalfResFinalCopy);
			}
			foreach (KeyValuePair<MonitorType, Monitor> current2 in this.m_Monitors)
			{
				Monitor value = current2.Value;
				if (value.requested)
				{
					value.Render(context);
				}
			}
			if (flag2)
			{
				command.ReleaseTemporaryRT(ShaderIDs.HalfResFinalCopy);
			}
			command.EndSample("Monitors");
		}

		internal void RenderSpecialOverlays(PostProcessRenderContext context)
		{
			if (this.debugOverlay == DebugOverlay.Depth)
			{
				PropertySheet sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays);
				this.PushDebugOverlay(context.command, BuiltinRenderTextureType.None, sheet, 0);
			}
			else if (this.debugOverlay == DebugOverlay.Normals)
			{
				PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.debugOverlays);
				propertySheet.ClearKeywords();
				if (context.camera.actualRenderingPath == RenderingPath.DeferredLighting)
				{
					propertySheet.EnableKeyword("SOURCE_GBUFFER");
				}
				this.PushDebugOverlay(context.command, BuiltinRenderTextureType.None, propertySheet, 1);
			}
			else if (this.debugOverlay == DebugOverlay.MotionVectors)
			{
				PropertySheet propertySheet2 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
				propertySheet2.properties.SetVector(ShaderIDs.Params, new Vector4(this.overlaySettings.motionColorIntensity, (float)this.overlaySettings.motionGridSize, 0f, 0f));
				this.PushDebugOverlay(context.command, context.source, propertySheet2, 2);
			}
			else if (this.debugOverlay == DebugOverlay.NANTracker)
			{
				PropertySheet sheet2 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
				this.PushDebugOverlay(context.command, context.source, sheet2, 3);
			}
			else if (this.debugOverlay == DebugOverlay.ColorBlindnessSimulation)
			{
				PropertySheet propertySheet3 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
				propertySheet3.properties.SetVector(ShaderIDs.Params, new Vector4(this.overlaySettings.colorBlindnessStrength, 0f, 0f, 0f));
				this.PushDebugOverlay(context.command, context.source, propertySheet3, (int)(4 + this.overlaySettings.colorBlindnessType));
			}
		}

		internal void EndFrame()
		{
			foreach (KeyValuePair<MonitorType, Monitor> current in this.m_Monitors)
			{
				current.Value.requested = false;
			}
			if (!this.debugOverlayActive)
			{
				this.DestroyDebugOverlayTarget();
			}
			this.debugOverlay = DebugOverlay.None;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public abstract class PostProcessEffectRenderer
	{
		protected bool m_ResetHistory = true;

		public virtual void Init()
		{
		}

		public virtual DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.None;
		}

		public virtual void ResetHistory()
		{
			this.m_ResetHistory = true;
		}

		public virtual void Release()
		{
			this.ResetHistory();
		}

		public abstract void Render(PostProcessRenderContext context);

		internal abstract void SetSettings(PostProcessEffectSettings settings);
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public abstract class PostProcessEffectRenderer<T> : PostProcessEffectRenderer where T : PostProcessEffectSettings
	{
		public T settings
		{
			get;
			internal set;
		}

		internal override void SetSettings(PostProcessEffectSettings settings)
		{
			this.settings = (T)((object)settings);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public class PostProcessEffectSettings : ScriptableObject
	{
		public bool active = true;

		public BoolParameter enabled = new BoolParameter
		{
			overrideState = true,
			value = false
		};

		internal ReadOnlyCollection<ParameterOverride> parameters;

		private static Func<FieldInfo, bool> __f__am_cache0;

		private static Func<FieldInfo, int> __f__am_cache1;

		private void OnEnable()
		{
			IEnumerable<FieldInfo> arg_2B_0 = base.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public);
			if (PostProcessEffectSettings.__f__am_cache0 == null)
			{
				PostProcessEffectSettings.__f__am_cache0 = new Func<FieldInfo, bool>(PostProcessEffectSettings._OnEnable_m__0);
			}
			IEnumerable<FieldInfo> arg_4D_0 = arg_2B_0.Where(PostProcessEffectSettings.__f__am_cache0);
			if (PostProcessEffectSettings.__f__am_cache1 == null)
			{
				PostProcessEffectSettings.__f__am_cache1 = new Func<FieldInfo, int>(PostProcessEffectSettings._OnEnable_m__1);
			}
			this.parameters = arg_4D_0.OrderBy(PostProcessEffectSettings.__f__am_cache1).Select(new Func<FieldInfo, ParameterOverride>(this._OnEnable_m__2)).ToList<ParameterOverride>().AsReadOnly();
			foreach (ParameterOverride current in this.parameters)
			{
				current.OnEnable();
			}
		}

		private void OnDisable()
		{
			if (this.parameters == null)
			{
				return;
			}
			foreach (ParameterOverride current in this.parameters)
			{
				current.OnDisable();
			}
		}

		public void SetAllOverridesTo(bool state, bool excludeEnabled = true)
		{
			foreach (ParameterOverride current in this.parameters)
			{
				if (!excludeEnabled || current != this.enabled)
				{
					current.overrideState = state;
				}
			}
		}

		public virtual bool IsEnabledAndSupported(PostProcessRenderContext context)
		{
			return this.enabled.value;
		}

		public int GetHash()
		{
			int num = 17;
			foreach (ParameterOverride current in this.parameters)
			{
				num = num * 23 + current.GetHash();
			}
			return num;
		}

		private static bool _OnEnable_m__0(FieldInfo t)
		{
			return t.FieldType.IsSubclassOf(typeof(ParameterOverride));
		}

		private static int _OnEnable_m__1(FieldInfo t)
		{
			return t.MetadataToken;
		}

		private ParameterOverride _OnEnable_m__2(FieldInfo t)
		{
			return (ParameterOverride)t.GetValue(this);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public enum PostProcessEvent
	{
		BeforeTransparent,
		BeforeStack,
		AfterStack
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace UnityEngine.Rendering.PostProcessing
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PostProcessEventComparer : IEqualityComparer<PostProcessEvent>
	{
		public bool Equals(PostProcessEvent x, PostProcessEvent y)
		{
			return x == y;
		}

		public int GetHashCode(PostProcessEvent obj)
		{
			return (int)obj;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine.XR;

namespace UnityEngine.Rendering.PostProcessing
{
	[AddComponentMenu("Rendering/Post-process Layer", 1000), DisallowMultipleComponent, ExecuteInEditMode, ImageEffectAllowedInSceneView, RequireComponent(typeof(Camera))]
	public sealed class PostProcessLayer : MonoBehaviour
	{
		public enum Antialiasing
		{
			None,
			FastApproximateAntialiasing,
			SubpixelMorphologicalAntialiasing,
			TemporalAntialiasing
		}

		[Serializable]
		public sealed class SerializedBundleRef
		{
			public string assemblyQualifiedName;

			public PostProcessBundle bundle;
		}

		private sealed class _UpdateBundleSortList_c__AnonStorey0
		{
			private sealed class _UpdateBundleSortList_c__AnonStorey1
			{
				internal string searchStr;

				internal PostProcessLayer._UpdateBundleSortList_c__AnonStorey0 __f__ref_0;

				internal bool __m__0(PostProcessBundle b)
				{
					return b.settings.GetType().AssemblyQualifiedName == this.searchStr;
				}
			}

			internal PostProcessEvent evt;

			internal List<PostProcessBundle> effects;

			internal bool __m__0(KeyValuePair<Type, PostProcessBundle> kvp)
			{
				return kvp.Value.attribute.eventType == this.evt && !kvp.Value.attribute.builtinEffect;
			}

			internal bool __m__1(PostProcessLayer.SerializedBundleRef x)
			{
				PostProcessLayer._UpdateBundleSortList_c__AnonStorey0._UpdateBundleSortList_c__AnonStorey1 _UpdateBundleSortList_c__AnonStorey = new PostProcessLayer._UpdateBundleSortList_c__AnonStorey0._UpdateBundleSortList_c__AnonStorey1();
				_UpdateBundleSortList_c__AnonStorey.__f__ref_0 = this;
				_UpdateBundleSortList_c__AnonStorey.searchStr = x.assemblyQualifiedName;
				return !this.effects.Exists(new Predicate<PostProcessBundle>(_UpdateBundleSortList_c__AnonStorey.__m__0));
			}
		}

		private sealed class _UpdateBundleSortList_c__AnonStorey2
		{
			internal string typeName;

			internal bool __m__0(PostProcessLayer.SerializedBundleRef b)
			{
				return b.assemblyQualifiedName == this.typeName;
			}
		}

		private sealed class _UpdateBundleSortList_c__AnonStorey3
		{
			internal string typeName;

			internal bool __m__0(PostProcessBundle b)
			{
				return b.settings.GetType().AssemblyQualifiedName == this.typeName;
			}
		}

		public Transform volumeTrigger;

		public LayerMask volumeLayer;

		public bool stopNaNPropagation = true;

		public PostProcessLayer.Antialiasing antialiasingMode;

		public TemporalAntialiasing temporalAntialiasing;

		public SubpixelMorphologicalAntialiasing subpixelMorphologicalAntialiasing;

		public FastApproximateAntialiasing fastApproximateAntialiasing;

		public Fog fog;

		public Dithering dithering;

		public PostProcessDebugLayer debugLayer;

		[SerializeField]
		private PostProcessResources m_Resources;

		[SerializeField]
		private bool m_ShowToolkit;

		[SerializeField]
		private bool m_ShowCustomSorter;

		public bool breakBeforeColorGrading;

		[SerializeField]
		private List<PostProcessLayer.SerializedBundleRef> m_BeforeTransparentBundles;

		[SerializeField]
		private List<PostProcessLayer.SerializedBundleRef> m_BeforeStackBundles;

		[SerializeField]
		private List<PostProcessLayer.SerializedBundleRef> m_AfterStackBundles;

		private Dictionary<Type, PostProcessBundle> m_Bundles;

		private PropertySheetFactory m_PropertySheetFactory;

		private CommandBuffer m_LegacyCmdBufferBeforeReflections;

		private CommandBuffer m_LegacyCmdBufferBeforeLighting;

		private CommandBuffer m_LegacyCmdBufferOpaque;

		private CommandBuffer m_LegacyCmdBuffer;

		private Camera m_Camera;

		private PostProcessRenderContext m_CurrentContext;

		private LogHistogram m_LogHistogram;

		private bool m_SettingsUpdateNeeded = true;

		private bool m_IsRenderingInSceneView;

		private TargetPool m_TargetPool;

		private bool m_NaNKilled;

		private readonly List<PostProcessEffectRenderer> m_ActiveEffects = new List<PostProcessEffectRenderer>();

		private readonly List<RenderTargetIdentifier> m_Targets = new List<RenderTargetIdentifier>();

		private static Func<KeyValuePair<Type, PostProcessBundle>, PostProcessBundle> __f__am_cache0;

		public Dictionary<PostProcessEvent, List<PostProcessLayer.SerializedBundleRef>> sortedBundles
		{
			get;
			private set;
		}

		public bool haveBundlesBeenInited
		{
			get;
			private set;
		}

		private void OnEnable()
		{
			this.Init(null);
			if (!this.haveBundlesBeenInited)
			{
				this.InitBundles();
			}
			this.m_LogHistogram = new LogHistogram();
			this.m_PropertySheetFactory = new PropertySheetFactory();
			this.m_TargetPool = new TargetPool();
			this.debugLayer.OnEnable();
			if (RuntimeUtilities.scriptableRenderPipelineActive)
			{
				return;
			}
			this.InitLegacy();
		}

		private void InitLegacy()
		{
			this.m_LegacyCmdBufferBeforeReflections = new CommandBuffer
			{
				name = "Deferred Ambient Occlusion"
			};
			this.m_LegacyCmdBufferBeforeLighting = new CommandBuffer
			{
				name = "Deferred Ambient Occlusion"
			};
			this.m_LegacyCmdBufferOpaque = new CommandBuffer
			{
				name = "Opaque Only Post-processing"
			};
			this.m_LegacyCmdBuffer = new CommandBuffer
			{
				name = "Post-processing"
			};
			this.m_Camera = base.GetComponent<Camera>();
			this.m_Camera.forceIntoRenderTexture = true;
			this.m_Camera.AddCommandBuffer(CameraEvent.BeforeReflections, this.m_LegacyCmdBufferBeforeReflections);
			this.m_Camera.AddCommandBuffer(CameraEvent.BeforeLighting, this.m_LegacyCmdBufferBeforeLighting);
			this.m_Camera.AddCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, this.m_LegacyCmdBufferOpaque);
			this.m_Camera.AddCommandBuffer(CameraEvent.BeforeImageEffects, this.m_LegacyCmdBuffer);
			this.m_CurrentContext = new PostProcessRenderContext();
		}

		public void Init(PostProcessResources resources)
		{
			if (resources != null)
			{
				this.m_Resources = resources;
			}
			RuntimeUtilities.CreateIfNull<TemporalAntialiasing>(ref this.temporalAntialiasing);
			RuntimeUtilities.CreateIfNull<SubpixelMorphologicalAntialiasing>(ref this.subpixelMorphologicalAntialiasing);
			RuntimeUtilities.CreateIfNull<FastApproximateAntialiasing>(ref this.fastApproximateAntialiasing);
			RuntimeUtilities.CreateIfNull<Dithering>(ref this.dithering);
			RuntimeUtilities.CreateIfNull<Fog>(ref this.fog);
			RuntimeUtilities.CreateIfNull<PostProcessDebugLayer>(ref this.debugLayer);
		}

		public void InitBundles()
		{
			if (this.haveBundlesBeenInited)
			{
				return;
			}
			RuntimeUtilities.CreateIfNull<List<PostProcessLayer.SerializedBundleRef>>(ref this.m_BeforeTransparentBundles);
			RuntimeUtilities.CreateIfNull<List<PostProcessLayer.SerializedBundleRef>>(ref this.m_BeforeStackBundles);
			RuntimeUtilities.CreateIfNull<List<PostProcessLayer.SerializedBundleRef>>(ref this.m_AfterStackBundles);
			this.m_Bundles = new Dictionary<Type, PostProcessBundle>();
			foreach (Type current in PostProcessManager.instance.settingsTypes.Keys)
			{
				PostProcessEffectSettings settings = (PostProcessEffectSettings)ScriptableObject.CreateInstance(current);
				PostProcessBundle value = new PostProcessBundle(settings);
				this.m_Bundles.Add(current, value);
			}
			this.UpdateBundleSortList(this.m_BeforeTransparentBundles, PostProcessEvent.BeforeTransparent);
			this.UpdateBundleSortList(this.m_BeforeStackBundles, PostProcessEvent.BeforeStack);
			this.UpdateBundleSortList(this.m_AfterStackBundles, PostProcessEvent.AfterStack);
			this.sortedBundles = new Dictionary<PostProcessEvent, List<PostProcessLayer.SerializedBundleRef>>(default(PostProcessEventComparer))
			{
				{
					PostProcessEvent.BeforeTransparent,
					this.m_BeforeTransparentBundles
				},
				{
					PostProcessEvent.BeforeStack,
					this.m_BeforeStackBundles
				},
				{
					PostProcessEvent.AfterStack,
					this.m_AfterStackBundles
				}
			};
			this.haveBundlesBeenInited = true;
		}

		private void UpdateBundleSortList(List<PostProcessLayer.SerializedBundleRef> sortedList, PostProcessEvent evt)
		{
			PostProcessLayer._UpdateBundleSortList_c__AnonStorey0 _UpdateBundleSortList_c__AnonStorey = new PostProcessLayer._UpdateBundleSortList_c__AnonStorey0();
			_UpdateBundleSortList_c__AnonStorey.evt = evt;
			PostProcessLayer._UpdateBundleSortList_c__AnonStorey0 arg_4C_0 = _UpdateBundleSortList_c__AnonStorey;
			IEnumerable<KeyValuePair<Type, PostProcessBundle>> arg_42_0 = this.m_Bundles.Where(new Func<KeyValuePair<Type, PostProcessBundle>, bool>(_UpdateBundleSortList_c__AnonStorey.__m__0));
			if (PostProcessLayer.__f__am_cache0 == null)
			{
				PostProcessLayer.__f__am_cache0 = new Func<KeyValuePair<Type, PostProcessBundle>, PostProcessBundle>(PostProcessLayer._UpdateBundleSortList_m__0);
			}
			arg_4C_0.effects = arg_42_0.Select(PostProcessLayer.__f__am_cache0).ToList<PostProcessBundle>();
			sortedList.RemoveAll(new Predicate<PostProcessLayer.SerializedBundleRef>(_UpdateBundleSortList_c__AnonStorey.__m__1));
			foreach (PostProcessBundle current in _UpdateBundleSortList_c__AnonStorey.effects)
			{
				PostProcessLayer._UpdateBundleSortList_c__AnonStorey2 _UpdateBundleSortList_c__AnonStorey2 = new PostProcessLayer._UpdateBundleSortList_c__AnonStorey2();
				_UpdateBundleSortList_c__AnonStorey2.typeName = current.settings.GetType().AssemblyQualifiedName;
				if (!sortedList.Exists(new Predicate<PostProcessLayer.SerializedBundleRef>(_UpdateBundleSortList_c__AnonStorey2.__m__0)))
				{
					PostProcessLayer.SerializedBundleRef item = new PostProcessLayer.SerializedBundleRef
					{
						assemblyQualifiedName = _UpdateBundleSortList_c__AnonStorey2.typeName
					};
					sortedList.Add(item);
				}
			}
			foreach (PostProcessLayer.SerializedBundleRef current2 in sortedList)
			{
				PostProcessLayer._UpdateBundleSortList_c__AnonStorey3 _UpdateBundleSortList_c__AnonStorey3 = new PostProcessLayer._UpdateBundleSortList_c__AnonStorey3();
				_UpdateBundleSortList_c__AnonStorey3.typeName = current2.assemblyQualifiedName;
				PostProcessBundle bundle = _UpdateBundleSortList_c__AnonStorey.effects.Find(new Predicate<PostProcessBundle>(_UpdateBundleSortList_c__AnonStorey3.__m__0));
				current2.bundle = bundle;
			}
		}

		private void OnDisable()
		{
			if (!RuntimeUtilities.scriptableRenderPipelineActive)
			{
				this.m_Camera.RemoveCommandBuffer(CameraEvent.BeforeReflections, this.m_LegacyCmdBufferBeforeReflections);
				this.m_Camera.RemoveCommandBuffer(CameraEvent.BeforeLighting, this.m_LegacyCmdBufferBeforeLighting);
				this.m_Camera.RemoveCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, this.m_LegacyCmdBufferOpaque);
				this.m_Camera.RemoveCommandBuffer(CameraEvent.BeforeImageEffects, this.m_LegacyCmdBuffer);
			}
			this.temporalAntialiasing.Release();
			this.m_LogHistogram.Release();
			foreach (PostProcessBundle current in this.m_Bundles.Values)
			{
				current.Release();
			}
			this.m_Bundles.Clear();
			this.m_PropertySheetFactory.Release();
			if (this.debugLayer != null)
			{
				this.debugLayer.OnDisable();
			}
			TextureLerper.instance.Clear();
			this.haveBundlesBeenInited = false;
		}

		private void Reset()
		{
			this.volumeTrigger = base.transform;
		}

		private void OnPreCull()
		{
			if (RuntimeUtilities.scriptableRenderPipelineActive)
			{
				return;
			}
			if (this.m_Camera == null || this.m_CurrentContext == null)
			{
				this.InitLegacy();
			}
			this.m_Camera.ResetProjectionMatrix();
			this.m_Camera.nonJitteredProjectionMatrix = this.m_Camera.projectionMatrix;
			if (this.m_Camera.stereoEnabled)
			{
				this.m_Camera.ResetStereoProjectionMatrices();
				Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, XRSettings.renderViewportScale);
			}
			else
			{
				Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, 1f);
			}
			this.BuildCommandBuffers();
		}

		private void OnPreRender()
		{
			if (RuntimeUtilities.scriptableRenderPipelineActive || this.m_Camera.stereoActiveEye != Camera.MonoOrStereoscopicEye.Right)
			{
				return;
			}
			this.BuildCommandBuffers();
		}

		private void BuildCommandBuffers()
		{
			PostProcessRenderContext currentContext = this.m_CurrentContext;
			RenderTextureFormat renderTextureFormat = (!this.m_Camera.allowHDR) ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR;
			currentContext.Reset();
			currentContext.camera = this.m_Camera;
			currentContext.sourceFormat = renderTextureFormat;
			this.m_LegacyCmdBufferBeforeReflections.Clear();
			this.m_LegacyCmdBufferBeforeLighting.Clear();
			this.m_LegacyCmdBufferOpaque.Clear();
			this.m_LegacyCmdBuffer.Clear();
			this.SetupContext(currentContext);
			currentContext.command = this.m_LegacyCmdBufferOpaque;
			this.UpdateSettingsIfNeeded(currentContext);
			PostProcessBundle bundle = this.GetBundle<AmbientOcclusion>();
			AmbientOcclusion ambientOcclusion = bundle.CastSettings<AmbientOcclusion>();
			AmbientOcclusionRenderer ambientOcclusionRenderer = bundle.CastRenderer<AmbientOcclusionRenderer>();
			bool flag = ambientOcclusion.IsEnabledAndSupported(currentContext);
			bool flag2 = ambientOcclusionRenderer.IsAmbientOnly(currentContext);
			bool flag3 = flag && flag2;
			bool flag4 = flag && !flag2;
			PostProcessBundle bundle2 = this.GetBundle<ScreenSpaceReflections>();
			PostProcessEffectSettings settings = bundle2.settings;
			PostProcessEffectRenderer renderer = bundle2.renderer;
			bool flag5 = settings.IsEnabledAndSupported(currentContext);
			if (flag3)
			{
				IAmbientOcclusionMethod ambientOcclusionMethod = ambientOcclusionRenderer.Get();
				currentContext.command = this.m_LegacyCmdBufferBeforeReflections;
				ambientOcclusionMethod.RenderAmbientOnly(currentContext);
				currentContext.command = this.m_LegacyCmdBufferBeforeLighting;
				ambientOcclusionMethod.CompositeAmbientOnly(currentContext);
			}
			else if (flag4)
			{
				currentContext.command = this.m_LegacyCmdBufferOpaque;
				ambientOcclusionRenderer.Get().RenderAfterOpaque(currentContext);
			}
			bool flag6 = this.fog.IsEnabledAndSupported(currentContext);
			bool flag7 = this.HasOpaqueOnlyEffects(currentContext);
			int num = 0;
			num += ((!flag5) ? 0 : 1);
			num += ((!flag6) ? 0 : 1);
			num += ((!flag7) ? 0 : 1);
			RenderTargetIdentifier renderTargetIdentifier = new RenderTargetIdentifier(BuiltinRenderTextureType.CameraTarget);
			if (num > 0)
			{
				CommandBuffer legacyCmdBufferOpaque = this.m_LegacyCmdBufferOpaque;
				currentContext.command = legacyCmdBufferOpaque;
				int nameID = this.m_TargetPool.Get();
				currentContext.GetScreenSpaceTemporaryRT(legacyCmdBufferOpaque, nameID, 0, renderTextureFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
				legacyCmdBufferOpaque.Blit(renderTargetIdentifier, nameID);
				currentContext.source = nameID;
				int nameID2 = -1;
				if (num > 1)
				{
					nameID2 = this.m_TargetPool.Get();
					currentContext.GetScreenSpaceTemporaryRT(legacyCmdBufferOpaque, nameID2, 0, renderTextureFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
					currentContext.destination = nameID2;
				}
				else
				{
					currentContext.destination = renderTargetIdentifier;
				}
				if (flag5)
				{
					renderer.Render(currentContext);
					num--;
					RenderTargetIdentifier source = currentContext.source;
					currentContext.source = currentContext.destination;
					currentContext.destination = ((num != 1) ? source : renderTargetIdentifier);
				}
				if (flag6)
				{
					this.fog.Render(currentContext);
					num--;
					RenderTargetIdentifier source2 = currentContext.source;
					currentContext.source = currentContext.destination;
					currentContext.destination = ((num != 1) ? source2 : renderTargetIdentifier);
				}
				if (flag7)
				{
					this.RenderOpaqueOnly(currentContext);
				}
				if (num > 1)
				{
					legacyCmdBufferOpaque.ReleaseTemporaryRT(nameID2);
				}
				legacyCmdBufferOpaque.ReleaseTemporaryRT(nameID);
			}
			int nameID3 = this.m_TargetPool.Get();
			currentContext.GetScreenSpaceTemporaryRT(this.m_LegacyCmdBuffer, nameID3, 0, renderTextureFormat, RenderTextureReadWrite.sRGB, FilterMode.Bilinear, 0, 0);
			this.m_LegacyCmdBuffer.Blit(renderTargetIdentifier, nameID3, RuntimeUtilities.copyStdMaterial, (!this.stopNaNPropagation) ? 0 : 1);
			this.m_NaNKilled = this.stopNaNPropagation;
			currentContext.command = this.m_LegacyCmdBuffer;
			currentContext.source = nameID3;
			currentContext.destination = renderTargetIdentifier;
			this.Render(currentContext);
			this.m_LegacyCmdBuffer.ReleaseTemporaryRT(nameID3);
		}

		private void OnPostRender()
		{
			if (RuntimeUtilities.scriptableRenderPipelineActive)
			{
				return;
			}
			if (this.m_CurrentContext.IsTemporalAntialiasingActive())
			{
				this.m_Camera.ResetProjectionMatrix();
				if (this.m_CurrentContext.stereoActive && (RuntimeUtilities.isSinglePassStereoEnabled || this.m_Camera.stereoActiveEye == Camera.MonoOrStereoscopicEye.Right))
				{
					this.m_Camera.ResetStereoProjectionMatrices();
				}
			}
		}

		public PostProcessBundle GetBundle<T>() where T : PostProcessEffectSettings
		{
			return this.GetBundle(typeof(T));
		}

		public PostProcessBundle GetBundle(Type settingsType)
		{
			return this.m_Bundles[settingsType];
		}

		public T GetSettings<T>() where T : PostProcessEffectSettings
		{
			return this.GetBundle<T>().CastSettings<T>();
		}

		public void BakeMSVOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert)
		{
			PostProcessBundle bundle = this.GetBundle<AmbientOcclusion>();
			MultiScaleVO multiScaleVO = bundle.CastRenderer<AmbientOcclusionRenderer>().GetMultiScaleVO();
			multiScaleVO.SetResources(this.m_Resources);
			multiScaleVO.GenerateAOMap(cmd, camera, destination, depthMap, invert);
		}

		internal void OverrideSettings(List<PostProcessEffectSettings> baseSettings, float interpFactor)
		{
			foreach (PostProcessEffectSettings current in baseSettings)
			{
				if (current.active)
				{
					PostProcessEffectSettings settings = this.GetBundle(current.GetType()).settings;
					int count = current.parameters.Count;
					for (int i = 0; i < count; i++)
					{
						ParameterOverride parameterOverride = current.parameters[i];
						if (parameterOverride.overrideState)
						{
							ParameterOverride parameterOverride2 = settings.parameters[i];
							parameterOverride2.Interp(parameterOverride2, parameterOverride, interpFactor);
						}
					}
				}
			}
		}

		private void SetLegacyCameraFlags(PostProcessRenderContext context)
		{
			DepthTextureMode depthTextureMode = context.camera.depthTextureMode;
			foreach (KeyValuePair<Type, PostProcessBundle> current in this.m_Bundles)
			{
				if (current.Value.settings.IsEnabledAndSupported(context))
				{
					depthTextureMode |= current.Value.renderer.GetCameraFlags();
				}
			}
			if (context.IsTemporalAntialiasingActive())
			{
				depthTextureMode |= this.temporalAntialiasing.GetCameraFlags();
			}
			if (this.fog.IsEnabledAndSupported(context))
			{
				depthTextureMode |= this.fog.GetCameraFlags();
			}
			if (this.debugLayer.debugOverlay != DebugOverlay.None)
			{
				depthTextureMode |= this.debugLayer.GetCameraFlags();
			}
			context.camera.depthTextureMode = depthTextureMode;
		}

		public void ResetHistory()
		{
			foreach (KeyValuePair<Type, PostProcessBundle> current in this.m_Bundles)
			{
				current.Value.ResetHistory();
			}
			this.temporalAntialiasing.ResetHistory();
		}

		public bool HasOpaqueOnlyEffects(PostProcessRenderContext context)
		{
			return this.HasActiveEffects(PostProcessEvent.BeforeTransparent, context);
		}

		public bool HasActiveEffects(PostProcessEvent evt, PostProcessRenderContext context)
		{
			List<PostProcessLayer.SerializedBundleRef> list = this.sortedBundles[evt];
			foreach (PostProcessLayer.SerializedBundleRef current in list)
			{
				if (current.bundle.settings.IsEnabledAndSupported(context))
				{
					return true;
				}
			}
			return false;
		}

		private void SetupContext(PostProcessRenderContext context)
		{
			this.m_IsRenderingInSceneView = (context.camera.cameraType == CameraType.SceneView);
			context.isSceneView = this.m_IsRenderingInSceneView;
			context.resources = this.m_Resources;
			context.propertySheets = this.m_PropertySheetFactory;
			context.debugLayer = this.debugLayer;
			context.antialiasing = this.antialiasingMode;
			context.temporalAntialiasing = this.temporalAntialiasing;
			context.logHistogram = this.m_LogHistogram;
			this.SetLegacyCameraFlags(context);
			this.debugLayer.SetFrameSize(context.width, context.height);
			this.m_CurrentContext = context;
		}

		private void UpdateSettingsIfNeeded(PostProcessRenderContext context)
		{
			if (this.m_SettingsUpdateNeeded)
			{
				context.command.BeginSample("VolumeBlending");
				PostProcessManager.instance.UpdateSettings(this);
				context.command.EndSample("VolumeBlending");
				this.m_TargetPool.Reset();
				if (RuntimeUtilities.scriptableRenderPipelineActive)
				{
					Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, 1f);
				}
			}
			this.m_SettingsUpdateNeeded = false;
		}

		public void RenderOpaqueOnly(PostProcessRenderContext context)
		{
			if (RuntimeUtilities.scriptableRenderPipelineActive)
			{
				this.SetupContext(context);
			}
			TextureLerper.instance.BeginFrame(context);
			this.UpdateSettingsIfNeeded(context);
			this.RenderList(this.sortedBundles[PostProcessEvent.BeforeTransparent], context, "OpaqueOnly");
		}

		public void Render(PostProcessRenderContext context)
		{
			if (RuntimeUtilities.scriptableRenderPipelineActive)
			{
				this.SetupContext(context);
			}
			TextureLerper.instance.BeginFrame(context);
			CommandBuffer command = context.command;
			this.UpdateSettingsIfNeeded(context);
			int num = -1;
			if (this.stopNaNPropagation && !this.m_NaNKilled)
			{
				num = this.m_TargetPool.Get();
				context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
				command.BlitFullscreenTriangle(context.source, num, RuntimeUtilities.copySheet, 1, false);
				context.source = num;
				this.m_NaNKilled = true;
			}
			if (context.IsTemporalAntialiasingActive())
			{
				if (!RuntimeUtilities.scriptableRenderPipelineActive)
				{
					if (context.stereoActive)
					{
						if (context.camera.stereoActiveEye != Camera.MonoOrStereoscopicEye.Right)
						{
							this.temporalAntialiasing.ConfigureStereoJitteredProjectionMatrices(context);
						}
					}
					else
					{
						this.temporalAntialiasing.ConfigureJitteredProjectionMatrix(context);
					}
				}
				int num2 = this.m_TargetPool.Get();
				RenderTargetIdentifier destination = context.destination;
				context.GetScreenSpaceTemporaryRT(command, num2, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
				context.destination = num2;
				this.temporalAntialiasing.Render(context);
				context.source = num2;
				context.destination = destination;
				if (num > -1)
				{
					command.ReleaseTemporaryRT(num);
				}
				num = num2;
			}
			bool flag = this.HasActiveEffects(PostProcessEvent.BeforeStack, context);
			bool flag2 = this.HasActiveEffects(PostProcessEvent.AfterStack, context) && !this.breakBeforeColorGrading;
			bool flag3 = (flag2 || this.antialiasingMode == PostProcessLayer.Antialiasing.FastApproximateAntialiasing || (this.antialiasingMode == PostProcessLayer.Antialiasing.SubpixelMorphologicalAntialiasing && this.subpixelMorphologicalAntialiasing.IsSupported())) && !this.breakBeforeColorGrading;
			if (flag)
			{
				num = this.RenderInjectionPoint(PostProcessEvent.BeforeStack, context, "BeforeStack", num);
			}
			num = this.RenderBuiltins(context, !flag3, num);
			if (flag2)
			{
				num = this.RenderInjectionPoint(PostProcessEvent.AfterStack, context, "AfterStack", num);
			}
			if (flag3)
			{
				this.RenderFinalPass(context, num);
			}
			this.debugLayer.RenderSpecialOverlays(context);
			this.debugLayer.RenderMonitors(context);
			TextureLerper.instance.EndFrame();
			this.debugLayer.EndFrame();
			this.m_SettingsUpdateNeeded = true;
			this.m_NaNKilled = false;
		}

		private int RenderInjectionPoint(PostProcessEvent evt, PostProcessRenderContext context, string marker, int releaseTargetAfterUse = -1)
		{
			int num = this.m_TargetPool.Get();
			RenderTargetIdentifier destination = context.destination;
			CommandBuffer command = context.command;
			context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
			context.destination = num;
			this.RenderList(this.sortedBundles[evt], context, marker);
			context.source = num;
			context.destination = destination;
			if (releaseTargetAfterUse > -1)
			{
				command.ReleaseTemporaryRT(releaseTargetAfterUse);
			}
			return num;
		}

		private void RenderList(List<PostProcessLayer.SerializedBundleRef> list, PostProcessRenderContext context, string marker)
		{
			CommandBuffer command = context.command;
			command.BeginSample(marker);
			this.m_ActiveEffects.Clear();
			for (int i = 0; i < list.Count; i++)
			{
				PostProcessBundle bundle = list[i].bundle;
				if (bundle.settings.IsEnabledAndSupported(context) && (!context.isSceneView || (context.isSceneView && bundle.attribute.allowInSceneView)))
				{
					this.m_ActiveEffects.Add(bundle.renderer);
				}
			}
			int count = this.m_ActiveEffects.Count;
			if (count == 1)
			{
				this.m_ActiveEffects[0].Render(context);
			}
			else
			{
				this.m_Targets.Clear();
				this.m_Targets.Add(context.source);
				int num = this.m_TargetPool.Get();
				int num2 = this.m_TargetPool.Get();
				for (int j = 0; j < count - 1; j++)
				{
					this.m_Targets.Add((j % 2 != 0) ? num2 : num);
				}
				this.m_Targets.Add(context.destination);
				context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
				if (count > 2)
				{
					context.GetScreenSpaceTemporaryRT(command, num2, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
				}
				for (int k = 0; k < count; k++)
				{
					context.source = this.m_Targets[k];
					context.destination = this.m_Targets[k + 1];
					this.m_ActiveEffects[k].Render(context);
				}
				command.ReleaseTemporaryRT(num);
				if (count > 2)
				{
					command.ReleaseTemporaryRT(num2);
				}
			}
			command.EndSample(marker);
		}

		private int RenderBuiltins(PostProcessRenderContext context, bool isFinalPass, int releaseTargetAfterUse = -1)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.uber);
			propertySheet.ClearKeywords();
			propertySheet.properties.Clear();
			context.uberSheet = propertySheet;
			context.autoExposureTexture = RuntimeUtilities.whiteTexture;
			context.bloomBufferNameID = -1;
			CommandBuffer command = context.command;
			command.BeginSample("BuiltinStack");
			int num = -1;
			RenderTargetIdentifier destination = context.destination;
			if (!isFinalPass)
			{
				num = this.m_TargetPool.Get();
				context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
				context.destination = num;
				if (this.antialiasingMode == PostProcessLayer.Antialiasing.FastApproximateAntialiasing && !this.fastApproximateAntialiasing.keepAlpha)
				{
					propertySheet.properties.SetFloat(ShaderIDs.LumaInAlpha, 1f);
				}
			}
			int num2 = this.RenderEffect<DepthOfField>(context, true);
			int num3 = this.RenderEffect<MotionBlur>(context, true);
			if (this.ShouldGenerateLogHistogram(context))
			{
				this.m_LogHistogram.Generate(context);
			}
			this.RenderEffect<AutoExposure>(context, false);
			propertySheet.properties.SetTexture(ShaderIDs.AutoExposureTex, context.autoExposureTexture);
			this.RenderEffect<ChromaticAberration>(context, false);
			this.RenderEffect<Bloom>(context, false);
			this.RenderEffect<Vignette>(context, false);
			this.RenderEffect<Grain>(context, false);
			if (!this.breakBeforeColorGrading)
			{
				this.RenderEffect<ColorGrading>(context, false);
			}
			int pass = 0;
			if (isFinalPass)
			{
				propertySheet.EnableKeyword("FINALPASS");
				this.dithering.Render(context);
				if (context.flip && !context.isSceneView)
				{
					pass = 1;
				}
			}
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, pass, false);
			context.source = context.destination;
			context.destination = destination;
			if (releaseTargetAfterUse > -1)
			{
				command.ReleaseTemporaryRT(releaseTargetAfterUse);
			}
			if (num3 > -1)
			{
				command.ReleaseTemporaryRT(num3);
			}
			if (num2 > -1)
			{
				command.ReleaseTemporaryRT(num2);
			}
			if (context.bloomBufferNameID > -1)
			{
				command.ReleaseTemporaryRT(context.bloomBufferNameID);
			}
			command.EndSample("BuiltinStack");
			return num;
		}

		private void RenderFinalPass(PostProcessRenderContext context, int releaseTargetAfterUse = -1)
		{
			CommandBuffer command = context.command;
			command.BeginSample("FinalPass");
			if (this.breakBeforeColorGrading)
			{
				PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.discardAlpha);
				command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, false);
			}
			else
			{
				PropertySheet propertySheet2 = context.propertySheets.Get(context.resources.shaders.finalPass);
				propertySheet2.ClearKeywords();
				propertySheet2.properties.Clear();
				context.uberSheet = propertySheet2;
				int num = -1;
				if (this.antialiasingMode == PostProcessLayer.Antialiasing.FastApproximateAntialiasing)
				{
					propertySheet2.EnableKeyword((!this.fastApproximateAntialiasing.fastMode) ? "FXAA" : "FXAA_LOW");
					if (this.fastApproximateAntialiasing.keepAlpha)
					{
						propertySheet2.EnableKeyword("FXAA_KEEP_ALPHA");
					}
				}
				else if (this.antialiasingMode == PostProcessLayer.Antialiasing.SubpixelMorphologicalAntialiasing && this.subpixelMorphologicalAntialiasing.IsSupported())
				{
					num = this.m_TargetPool.Get();
					RenderTargetIdentifier destination = context.destination;
					context.GetScreenSpaceTemporaryRT(context.command, num, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
					context.destination = num;
					this.subpixelMorphologicalAntialiasing.Render(context);
					context.source = num;
					context.destination = destination;
				}
				this.dithering.Render(context);
				command.BlitFullscreenTriangle(context.source, context.destination, propertySheet2, (!context.flip || context.isSceneView) ? 0 : 1, false);
				if (num > -1)
				{
					command.ReleaseTemporaryRT(num);
				}
			}
			if (releaseTargetAfterUse > -1)
			{
				command.ReleaseTemporaryRT(releaseTargetAfterUse);
			}
			command.EndSample("FinalPass");
		}

		private int RenderEffect<T>(PostProcessRenderContext context, bool useTempTarget = false) where T : PostProcessEffectSettings
		{
			PostProcessBundle bundle = this.GetBundle<T>();
			if (!bundle.settings.IsEnabledAndSupported(context))
			{
				return -1;
			}
			if (this.m_IsRenderingInSceneView && !bundle.attribute.allowInSceneView)
			{
				return -1;
			}
			if (!useTempTarget)
			{
				bundle.renderer.Render(context);
				return -1;
			}
			RenderTargetIdentifier destination = context.destination;
			int num = this.m_TargetPool.Get();
			context.GetScreenSpaceTemporaryRT(context.command, num, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, 0, 0);
			context.destination = num;
			bundle.renderer.Render(context);
			context.source = num;
			context.destination = destination;
			return num;
		}

		private bool ShouldGenerateLogHistogram(PostProcessRenderContext context)
		{
			bool flag = this.GetBundle<AutoExposure>().settings.IsEnabledAndSupported(context);
			bool flag2 = this.debugLayer.lightMeter.IsRequestedAndSupported();
			return flag || flag2;
		}

		private static PostProcessBundle _UpdateBundleSortList_m__0(KeyValuePair<Type, PostProcessBundle> kvp)
		{
			return kvp.Value;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PostProcessManager
	{
		private static PostProcessManager s_Instance;

		private const int k_MaxLayerCount = 32;

		private readonly Dictionary<int, List<PostProcessVolume>> m_SortedVolumes;

		private readonly List<PostProcessVolume> m_Volumes;

		private readonly Dictionary<int, bool> m_SortNeeded;

		private readonly List<PostProcessEffectSettings> m_BaseSettings;

		private readonly List<Collider> m_TempColliders;

		public readonly Dictionary<Type, PostProcessAttribute> settingsTypes;

		private static Func<Type, bool> __f__am_cache0;

		public static PostProcessManager instance
		{
			get
			{
				if (PostProcessManager.s_Instance == null)
				{
					PostProcessManager.s_Instance = new PostProcessManager();
				}
				return PostProcessManager.s_Instance;
			}
		}

		private PostProcessManager()
		{
			this.m_SortedVolumes = new Dictionary<int, List<PostProcessVolume>>();
			this.m_Volumes = new List<PostProcessVolume>();
			this.m_SortNeeded = new Dictionary<int, bool>();
			this.m_BaseSettings = new List<PostProcessEffectSettings>();
			this.m_TempColliders = new List<Collider>(5);
			this.settingsTypes = new Dictionary<Type, PostProcessAttribute>();
			this.ReloadBaseTypes();
		}

		private void CleanBaseTypes()
		{
			this.settingsTypes.Clear();
			foreach (PostProcessEffectSettings current in this.m_BaseSettings)
			{
				RuntimeUtilities.Destroy(current);
			}
			this.m_BaseSettings.Clear();
		}

		private void ReloadBaseTypes()
		{
			this.CleanBaseTypes();
			IEnumerable<Type> arg_28_0 = RuntimeUtilities.GetAllAssemblyTypes();
			if (PostProcessManager.__f__am_cache0 == null)
			{
				PostProcessManager.__f__am_cache0 = new Func<Type, bool>(PostProcessManager._ReloadBaseTypes_m__0);
			}
			IEnumerable<Type> enumerable = arg_28_0.Where(PostProcessManager.__f__am_cache0);
			foreach (Type current in enumerable)
			{
				this.settingsTypes.Add(current, current.GetAttribute<PostProcessAttribute>());
				PostProcessEffectSettings postProcessEffectSettings = (PostProcessEffectSettings)ScriptableObject.CreateInstance(current);
				postProcessEffectSettings.SetAllOverridesTo(true, false);
				this.m_BaseSettings.Add(postProcessEffectSettings);
			}
		}

		public void GetActiveVolumes(PostProcessLayer layer, List<PostProcessVolume> results, bool skipDisabled = true, bool skipZeroWeight = true)
		{
			int value = layer.volumeLayer.value;
			Transform volumeTrigger = layer.volumeTrigger;
			bool flag = volumeTrigger == null;
			Vector3 vector = (!flag) ? volumeTrigger.position : Vector3.zero;
			List<PostProcessVolume> list = this.GrabVolumes(value);
			foreach (PostProcessVolume current in list)
			{
				if ((!skipDisabled || current.enabled) && !(current.profileRef == null) && (!skipZeroWeight || current.weight > 0f))
				{
					if (current.isGlobal)
					{
						results.Add(current);
					}
					else if (!flag)
					{
						List<Collider> tempColliders = this.m_TempColliders;
						current.GetComponents<Collider>(tempColliders);
						if (tempColliders.Count != 0)
						{
							float num = float.PositiveInfinity;
							foreach (Collider current2 in tempColliders)
							{
								if (current2.enabled)
								{
									Vector3 a = current2.ClosestPoint(vector);
									float sqrMagnitude = ((a - vector) / 2f).sqrMagnitude;
									if (sqrMagnitude < num)
									{
										num = sqrMagnitude;
									}
								}
							}
							tempColliders.Clear();
							float num2 = current.blendDistance * current.blendDistance;
							if (num <= num2)
							{
								results.Add(current);
							}
						}
					}
				}
			}
		}

		public PostProcessVolume GetHighestPriorityVolume(PostProcessLayer layer)
		{
			if (layer == null)
			{
				throw new ArgumentNullException("layer");
			}
			return this.GetHighestPriorityVolume(layer.volumeLayer);
		}

		public PostProcessVolume GetHighestPriorityVolume(LayerMask mask)
		{
			float num = float.NegativeInfinity;
			PostProcessVolume result = null;
			List<PostProcessVolume> list;
			if (this.m_SortedVolumes.TryGetValue(mask, out list))
			{
				foreach (PostProcessVolume current in list)
				{
					if (current.priority > num)
					{
						num = current.priority;
						result = current;
					}
				}
			}
			return result;
		}

		public PostProcessVolume QuickVolume(int layer, float priority, params PostProcessEffectSettings[] settings)
		{
			GameObject gameObject = new GameObject
			{
				name = "Quick Volume",
				layer = layer,
				hideFlags = HideFlags.HideAndDontSave
			};
			PostProcessVolume postProcessVolume = gameObject.AddComponent<PostProcessVolume>();
			postProcessVolume.priority = priority;
			postProcessVolume.isGlobal = true;
			PostProcessProfile profile = postProcessVolume.profile;
			for (int i = 0; i < settings.Length; i++)
			{
				PostProcessEffectSettings effect = settings[i];
				profile.AddSettings(effect);
			}
			return postProcessVolume;
		}

		internal void SetLayerDirty(int layer)
		{
			foreach (KeyValuePair<int, List<PostProcessVolume>> current in this.m_SortedVolumes)
			{
				int key = current.Key;
				if ((key & 1 << layer) != 0)
				{
					this.m_SortNeeded[key] = true;
				}
			}
		}

		internal void UpdateVolumeLayer(PostProcessVolume volume, int prevLayer, int newLayer)
		{
			this.Unregister(volume, prevLayer);
			this.Register(volume, newLayer);
		}

		private void Register(PostProcessVolume volume, int layer)
		{
			this.m_Volumes.Add(volume);
			foreach (KeyValuePair<int, List<PostProcessVolume>> current in this.m_SortedVolumes)
			{
				int key = current.Key;
				if ((key & 1 << layer) != 0)
				{
					current.Value.Add(volume);
				}
			}
			this.SetLayerDirty(layer);
		}

		internal void Register(PostProcessVolume volume)
		{
			int layer = volume.gameObject.layer;
			this.Register(volume, layer);
		}

		private void Unregister(PostProcessVolume volume, int layer)
		{
			this.m_Volumes.Remove(volume);
			foreach (KeyValuePair<int, List<PostProcessVolume>> current in this.m_SortedVolumes)
			{
				int key = current.Key;
				if ((key & 1 << layer) != 0)
				{
					current.Value.Remove(volume);
				}
			}
		}

		internal void Unregister(PostProcessVolume volume)
		{
			int layer = volume.gameObject.layer;
			this.Unregister(volume, layer);
		}

		private void ReplaceData(PostProcessLayer postProcessLayer)
		{
			foreach (PostProcessEffectSettings current in this.m_BaseSettings)
			{
				PostProcessEffectSettings settings = postProcessLayer.GetBundle(current.GetType()).settings;
				int count = current.parameters.Count;
				for (int i = 0; i < count; i++)
				{
					settings.parameters[i].SetValue(current.parameters[i]);
				}
			}
		}

		internal void UpdateSettings(PostProcessLayer postProcessLayer)
		{
			this.ReplaceData(postProcessLayer);
			int value = postProcessLayer.volumeLayer.value;
			Transform volumeTrigger = postProcessLayer.volumeTrigger;
			bool flag = volumeTrigger == null;
			Vector3 vector = (!flag) ? volumeTrigger.position : Vector3.zero;
			List<PostProcessVolume> list = this.GrabVolumes(value);
			foreach (PostProcessVolume current in list)
			{
				if (current.enabled && !(current.profileRef == null) && current.weight > 0f)
				{
					List<PostProcessEffectSettings> settings = current.profileRef.settings;
					if (current.isGlobal)
					{
						postProcessLayer.OverrideSettings(settings, Mathf.Clamp01(current.weight));
					}
					else if (!flag)
					{
						List<Collider> tempColliders = this.m_TempColliders;
						current.GetComponents<Collider>(tempColliders);
						if (tempColliders.Count != 0)
						{
							float num = float.PositiveInfinity;
							foreach (Collider current2 in tempColliders)
							{
								if (current2.enabled)
								{
									Vector3 a = current2.ClosestPoint(vector);
									float sqrMagnitude = ((a - vector) / 2f).sqrMagnitude;
									if (sqrMagnitude < num)
									{
										num = sqrMagnitude;
									}
								}
							}
							tempColliders.Clear();
							float num2 = current.blendDistance * current.blendDistance;
							if (num <= num2)
							{
								float num3 = 1f;
								if (num2 > 0f)
								{
									num3 = 1f - num / num2;
								}
								postProcessLayer.OverrideSettings(settings, num3 * Mathf.Clamp01(current.weight));
							}
						}
					}
				}
			}
		}

		private List<PostProcessVolume> GrabVolumes(LayerMask mask)
		{
			List<PostProcessVolume> list;
			if (!this.m_SortedVolumes.TryGetValue(mask, out list))
			{
				list = new List<PostProcessVolume>();
				foreach (PostProcessVolume current in this.m_Volumes)
				{
					if ((mask & 1 << current.gameObject.layer) != 0)
					{
						list.Add(current);
						this.m_SortNeeded[mask] = true;
					}
				}
				this.m_SortedVolumes.Add(mask, list);
			}
			bool flag;
			if (this.m_SortNeeded.TryGetValue(mask, out flag) && flag)
			{
				this.m_SortNeeded[mask] = false;
				PostProcessManager.SortByPriority(list);
			}
			return list;
		}

		private static void SortByPriority(List<PostProcessVolume> volumes)
		{
			for (int i = 1; i < volumes.Count; i++)
			{
				PostProcessVolume postProcessVolume = volumes[i];
				int num = i - 1;
				while (num >= 0 && volumes[num].priority > postProcessVolume.priority)
				{
					volumes[num + 1] = volumes[num];
					num--;
				}
				volumes[num + 1] = postProcessVolume;
			}
		}

		private static bool _ReloadBaseTypes_m__0(Type t)
		{
			return t.IsSubclassOf(typeof(PostProcessEffectSettings)) && t.IsDefined(typeof(PostProcessAttribute), false) && !t.IsAbstract;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PostProcessProfile : ScriptableObject
	{
		[Tooltip("A list of all settings & overrides.")]
		public List<PostProcessEffectSettings> settings = new List<PostProcessEffectSettings>();

		[NonSerialized]
		public bool isDirty = true;

		private static Predicate<PostProcessEffectSettings> __f__am_cache0;

		private void OnEnable()
		{
			List<PostProcessEffectSettings> arg_23_0 = this.settings;
			if (PostProcessProfile.__f__am_cache0 == null)
			{
				PostProcessProfile.__f__am_cache0 = new Predicate<PostProcessEffectSettings>(PostProcessProfile._OnEnable_m__0);
			}
			arg_23_0.RemoveAll(PostProcessProfile.__f__am_cache0);
		}

		public void Reset()
		{
			this.isDirty = true;
		}

		public T AddSettings<T>() where T : PostProcessEffectSettings
		{
			return (T)((object)this.AddSettings(typeof(T)));
		}

		public PostProcessEffectSettings AddSettings(Type type)
		{
			if (this.HasSettings(type))
			{
				throw new InvalidOperationException("Effect already exists in the stack");
			}
			PostProcessEffectSettings postProcessEffectSettings = (PostProcessEffectSettings)ScriptableObject.CreateInstance(type);
			postProcessEffectSettings.hideFlags = (HideFlags.HideInHierarchy | HideFlags.HideInInspector);
			postProcessEffectSettings.name = type.Name;
			postProcessEffectSettings.enabled.value = true;
			this.settings.Add(postProcessEffectSettings);
			this.isDirty = true;
			return postProcessEffectSettings;
		}

		public PostProcessEffectSettings AddSettings(PostProcessEffectSettings effect)
		{
			if (this.HasSettings(this.settings.GetType()))
			{
				throw new InvalidOperationException("Effect already exists in the stack");
			}
			this.settings.Add(effect);
			this.isDirty = true;
			return effect;
		}

		public void RemoveSettings<T>() where T : PostProcessEffectSettings
		{
			this.RemoveSettings(typeof(T));
		}

		public void RemoveSettings(Type type)
		{
			int num = -1;
			for (int i = 0; i < this.settings.Count; i++)
			{
				if (this.settings[i].GetType() == type)
				{
					num = i;
					break;
				}
			}
			if (num < 0)
			{
				throw new InvalidOperationException("Effect doesn't exist in the stack");
			}
			this.settings.RemoveAt(num);
			this.isDirty = true;
		}

		public bool HasSettings<T>() where T : PostProcessEffectSettings
		{
			return this.HasSettings(typeof(T));
		}

		public bool HasSettings(Type type)
		{
			foreach (PostProcessEffectSettings current in this.settings)
			{
				if (current.GetType() == type)
				{
					return true;
				}
			}
			return false;
		}

		public bool TryGetSettings<T>(out T outSetting) where T : PostProcessEffectSettings
		{
			Type typeFromHandle = typeof(T);
			outSetting = (T)((object)null);
			foreach (PostProcessEffectSettings current in this.settings)
			{
				if (current.GetType() == typeFromHandle)
				{
					outSetting = (T)((object)current);
					return true;
				}
			}
			return false;
		}

		private static bool _OnEnable_m__0(PostProcessEffectSettings x)
		{
			return x == null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using UnityEngine.XR;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PostProcessRenderContext
	{
		private Camera m_Camera;

		internal PropertySheet uberSheet;

		internal Texture autoExposureTexture;

		internal LogHistogram logHistogram;

		internal Texture logLut;

		internal AutoExposure autoExposure;

		internal int bloomBufferNameID;

		private RenderTextureDescriptor m_sourceDescriptor;

		public Camera camera
		{
			get
			{
				return this.m_Camera;
			}
			set
			{
				this.m_Camera = value;
				if (this.m_Camera.stereoEnabled)
				{
					RenderTextureDescriptor eyeTextureDesc = XRSettings.eyeTextureDesc;
					this.width = eyeTextureDesc.width;
					this.height = eyeTextureDesc.height;
					this.m_sourceDescriptor = eyeTextureDesc;
					if (this.m_Camera.stereoActiveEye == Camera.MonoOrStereoscopicEye.Right)
					{
						this.xrActiveEye = 1;
					}
					this.screenWidth = XRSettings.eyeTextureWidth;
					this.screenHeight = XRSettings.eyeTextureHeight;
					this.stereoActive = true;
				}
				else
				{
					this.width = this.m_Camera.pixelWidth;
					this.height = this.m_Camera.pixelHeight;
					this.m_sourceDescriptor.width = this.width;
					this.m_sourceDescriptor.height = this.height;
					this.screenWidth = this.width;
					this.screenHeight = this.height;
					this.stereoActive = false;
				}
			}
		}

		public CommandBuffer command
		{
			get;
			set;
		}

		public RenderTargetIdentifier source
		{
			get;
			set;
		}

		public RenderTargetIdentifier destination
		{
			get;
			set;
		}

		public RenderTextureFormat sourceFormat
		{
			get;
			set;
		}

		public bool flip
		{
			get;
			set;
		}

		public PostProcessResources resources
		{
			get;
			internal set;
		}

		public PropertySheetFactory propertySheets
		{
			get;
			internal set;
		}

		public Dictionary<string, object> userData
		{
			get;
			private set;
		}

		public PostProcessDebugLayer debugLayer
		{
			get;
			internal set;
		}

		public int width
		{
			get;
			private set;
		}

		public int height
		{
			get;
			private set;
		}

		public bool stereoActive
		{
			get;
			private set;
		}

		public int xrActiveEye
		{
			get;
			private set;
		}

		public int screenWidth
		{
			get;
			private set;
		}

		public int screenHeight
		{
			get;
			private set;
		}

		public bool isSceneView
		{
			get;
			internal set;
		}

		public PostProcessLayer.Antialiasing antialiasing
		{
			get;
			internal set;
		}

		public TemporalAntialiasing temporalAntialiasing
		{
			get;
			internal set;
		}

		public void Reset()
		{
			this.m_Camera = null;
			this.width = 0;
			this.height = 0;
			this.m_sourceDescriptor = new RenderTextureDescriptor(0, 0);
			this.stereoActive = false;
			this.xrActiveEye = 0;
			this.screenWidth = 0;
			this.screenHeight = 0;
			this.command = null;
			this.source = 0;
			this.destination = 0;
			this.sourceFormat = RenderTextureFormat.ARGB32;
			this.flip = false;
			this.resources = null;
			this.propertySheets = null;
			this.debugLayer = null;
			this.isSceneView = false;
			this.antialiasing = PostProcessLayer.Antialiasing.None;
			this.temporalAntialiasing = null;
			this.uberSheet = null;
			this.autoExposureTexture = null;
			this.logLut = null;
			this.autoExposure = null;
			this.bloomBufferNameID = -1;
			if (this.userData == null)
			{
				this.userData = new Dictionary<string, object>();
			}
			this.userData.Clear();
		}

		public bool IsTemporalAntialiasingActive()
		{
			return this.antialiasing == PostProcessLayer.Antialiasing.TemporalAntialiasing && !this.isSceneView && this.temporalAntialiasing.IsSupported();
		}

		public bool IsDebugOverlayEnabled(DebugOverlay overlay)
		{
			return this.debugLayer.debugOverlay == overlay;
		}

		public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
		{
			this.debugLayer.PushDebugOverlay(cmd, source, sheet, pass);
		}

		private RenderTextureDescriptor GetDescriptor(int depthBufferBits = 0, RenderTextureFormat colorFormat = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default)
		{
			RenderTextureDescriptor result = new RenderTextureDescriptor(this.m_sourceDescriptor.width, this.m_sourceDescriptor.height, this.m_sourceDescriptor.colorFormat, depthBufferBits);
			result.dimension = this.m_sourceDescriptor.dimension;
			result.volumeDepth = this.m_sourceDescriptor.volumeDepth;
			result.vrUsage = this.m_sourceDescriptor.vrUsage;
			result.msaaSamples = this.m_sourceDescriptor.msaaSamples;
			result.memoryless = this.m_sourceDescriptor.memoryless;
			result.useMipMap = this.m_sourceDescriptor.useMipMap;
			result.autoGenerateMips = this.m_sourceDescriptor.autoGenerateMips;
			result.enableRandomWrite = this.m_sourceDescriptor.enableRandomWrite;
			result.shadowSamplingMode = this.m_sourceDescriptor.shadowSamplingMode;
			if (colorFormat != RenderTextureFormat.Default)
			{
				result.colorFormat = colorFormat;
			}
			result.sRGB = (readWrite != RenderTextureReadWrite.Linear);
			return result;
		}

		public void GetScreenSpaceTemporaryRT(CommandBuffer cmd, int nameID, int depthBufferBits = 0, RenderTextureFormat colorFormat = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default, FilterMode filter = FilterMode.Bilinear, int widthOverride = 0, int heightOverride = 0)
		{
			RenderTextureDescriptor descriptor = this.GetDescriptor(depthBufferBits, colorFormat, readWrite);
			if (widthOverride > 0)
			{
				descriptor.width = widthOverride;
			}
			if (heightOverride > 0)
			{
				descriptor.height = heightOverride;
			}
			cmd.GetTemporaryRT(nameID, descriptor, filter);
		}

		public RenderTexture GetScreenSpaceTemporaryRT(int depthBufferBits = 0, RenderTextureFormat colorFormat = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default, int widthOverride = 0, int heightOverride = 0)
		{
			RenderTextureDescriptor descriptor = this.GetDescriptor(depthBufferBits, colorFormat, readWrite);
			if (widthOverride > 0)
			{
				descriptor.width = widthOverride;
			}
			if (heightOverride > 0)
			{
				descriptor.height = heightOverride;
			}
			return RenderTexture.GetTemporary(descriptor);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PostProcessResources : ScriptableObject
	{
		[Serializable]
		public sealed class Shaders
		{
			public Shader autoExposure;

			public Shader bloom;

			public Shader copy;

			public Shader copyStd;

			public Shader discardAlpha;

			public Shader depthOfField;

			public Shader finalPass;

			public Shader grainBaker;

			public Shader motionBlur;

			public Shader temporalAntialiasing;

			public Shader subpixelMorphologicalAntialiasing;

			public Shader texture2dLerp;

			public Shader uber;

			public Shader lut2DBaker;

			public Shader lightMeter;

			public Shader gammaHistogram;

			public Shader waveform;

			public Shader vectorscope;

			public Shader debugOverlays;

			public Shader deferredFog;

			public Shader scalableAO;

			public Shader multiScaleAO;

			public Shader screenSpaceReflections;
		}

		[Serializable]
		public sealed class ComputeShaders
		{
			public ComputeShader exposureHistogram;

			public ComputeShader lut3DBaker;

			public ComputeShader texture3dLerp;

			public ComputeShader gammaHistogram;

			public ComputeShader waveform;

			public ComputeShader vectorscope;

			public ComputeShader multiScaleAODownsample1;

			public ComputeShader multiScaleAODownsample2;

			public ComputeShader multiScaleAORender;

			public ComputeShader multiScaleAOUpsample;

			public ComputeShader gaussianDownsample;
		}

		[Serializable]
		public sealed class SMAALuts
		{
			public Texture2D area;

			public Texture2D search;
		}

		public Texture2D[] blueNoise64;

		public Texture2D[] blueNoise256;

		public PostProcessResources.SMAALuts smaaLuts;

		public PostProcessResources.Shaders shaders;

		public PostProcessResources.ComputeShaders computeShaders;
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering.PostProcessing
{
	[AddComponentMenu("Rendering/Post-process Volume", 1001), ExecuteInEditMode]
	public sealed class PostProcessVolume : MonoBehaviour
	{
		public PostProcessProfile sharedProfile;

		[Tooltip("A global volume is applied to the whole scene.")]
		public bool isGlobal;

		[Min(0f), Tooltip("Outer distance to start blending from. A value of 0 means no blending and the volume overrides will be applied immediatly upon entry.")]
		public float blendDistance;

		[Range(0f, 1f), Tooltip("Total weight of this volume in the scene. 0 means it won't do anything, 1 means full effect.")]
		public float weight = 1f;

		[Tooltip("Volume priority in the stack. Higher number means higher priority. Negative values are supported.")]
		public float priority;

		private int m_PreviousLayer;

		private float m_PreviousPriority;

		private List<Collider> m_TempColliders;

		private PostProcessProfile m_InternalProfile;

		public PostProcessProfile profile
		{
			get
			{
				if (this.m_InternalProfile == null)
				{
					this.m_InternalProfile = ScriptableObject.CreateInstance<PostProcessProfile>();
					if (this.sharedProfile != null)
					{
						foreach (PostProcessEffectSettings current in this.sharedProfile.settings)
						{
							PostProcessEffectSettings item = UnityEngine.Object.Instantiate<PostProcessEffectSettings>(current);
							this.m_InternalProfile.settings.Add(item);
						}
					}
				}
				return this.m_InternalProfile;
			}
			set
			{
				this.m_InternalProfile = value;
			}
		}

		internal PostProcessProfile profileRef
		{
			get
			{
				return (!(this.m_InternalProfile == null)) ? this.m_InternalProfile : this.sharedProfile;
			}
		}

		private void OnEnable()
		{
			PostProcessManager.instance.Register(this);
			this.m_PreviousLayer = base.gameObject.layer;
			this.m_TempColliders = new List<Collider>();
		}

		private void OnDisable()
		{
			PostProcessManager.instance.Unregister(this);
		}

		private void Update()
		{
			int layer = base.gameObject.layer;
			if (layer != this.m_PreviousLayer)
			{
				PostProcessManager.instance.UpdateVolumeLayer(this, this.m_PreviousLayer, layer);
				this.m_PreviousLayer = layer;
			}
			if (this.priority != this.m_PreviousPriority)
			{
				PostProcessManager.instance.SetLayerDirty(layer);
				this.m_PreviousPriority = this.priority;
			}
		}

		private void OnDrawGizmos()
		{
			List<Collider> tempColliders = this.m_TempColliders;
			base.GetComponents<Collider>(tempColliders);
			if (this.isGlobal || tempColliders == null)
			{
				return;
			}
			Vector3 localScale = base.transform.localScale;
			Vector3 a = new Vector3(1f / localScale.x, 1f / localScale.y, 1f / localScale.z);
			Gizmos.matrix = Matrix4x4.TRS(base.transform.position, base.transform.rotation, localScale);
			foreach (Collider current in tempColliders)
			{
				if (current.enabled)
				{
					Type type = current.GetType();
					if (type == typeof(BoxCollider))
					{
						BoxCollider boxCollider = (BoxCollider)current;
						Gizmos.DrawCube(boxCollider.center, boxCollider.size);
						Gizmos.DrawWireCube(boxCollider.center, boxCollider.size + a * this.blendDistance * 4f);
					}
					else if (type == typeof(SphereCollider))
					{
						SphereCollider sphereCollider = (SphereCollider)current;
						Gizmos.DrawSphere(sphereCollider.center, sphereCollider.radius);
						Gizmos.DrawWireSphere(sphereCollider.center, sphereCollider.radius + a.x * this.blendDistance * 2f);
					}
					else if (type == typeof(MeshCollider))
					{
						MeshCollider meshCollider = (MeshCollider)current;
						if (!meshCollider.convex)
						{
							meshCollider.convex = true;
						}
						Gizmos.DrawMesh(meshCollider.sharedMesh);
						Gizmos.DrawWireMesh(meshCollider.sharedMesh, Vector3.zero, Quaternion.identity, Vector3.one + a * this.blendDistance * 4f);
					}
				}
			}
			tempColliders.Clear();
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public static class ColorUtilities
	{
		private const float logC_cut = 0.011361f;

		private const float logC_a = 5.555556f;

		private const float logC_b = 0.047996f;

		private const float logC_c = 0.244161f;

		private const float logC_d = 0.386036f;

		private const float logC_e = 5.301883f;

		private const float logC_f = 0.092819f;

		public static float StandardIlluminantY(float x)
		{
			return 2.87f * x - 3f * x * x - 0.275095075f;
		}

		public static Vector3 CIExyToLMS(float x, float y)
		{
			float num = 1f;
			float num2 = num * x / y;
			float num3 = num * (1f - x - y) / y;
			float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
			float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
			float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
			return new Vector3(x2, y2, z);
		}

		public static Vector3 ComputeColorBalance(float temperature, float tint)
		{
			float num = temperature / 60f;
			float num2 = tint / 60f;
			float x = 0.31271f - num * ((num >= 0f) ? 0.05f : 0.1f);
			float y = ColorUtilities.StandardIlluminantY(x) + num2 * 0.05f;
			Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
			Vector3 vector2 = ColorUtilities.CIExyToLMS(x, y);
			return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
		}

		public static Vector3 ColorToLift(Vector4 color)
		{
			Vector3 vector = new Vector3(color.x, color.y, color.z);
			float num = vector.x * 0.2126f + vector.y * 0.7152f + vector.z * 0.0722f;
			vector = new Vector3(vector.x - num, vector.y - num, vector.z - num);
			float w = color.w;
			return new Vector3(vector.x + w, vector.y + w, vector.z + w);
		}

		public static Vector3 ColorToInverseGamma(Vector4 color)
		{
			Vector3 vector = new Vector3(color.x, color.y, color.z);
			float num = vector.x * 0.2126f + vector.y * 0.7152f + vector.z * 0.0722f;
			vector = new Vector3(vector.x - num, vector.y - num, vector.z - num);
			float num2 = color.w + 1f;
			return new Vector3(1f / Mathf.Max(vector.x + num2, 0.001f), 1f / Mathf.Max(vector.y + num2, 0.001f), 1f / Mathf.Max(vector.z + num2, 0.001f));
		}

		public static Vector3 ColorToGain(Vector4 color)
		{
			Vector3 vector = new Vector3(color.x, color.y, color.z);
			float num = vector.x * 0.2126f + vector.y * 0.7152f + vector.z * 0.0722f;
			vector = new Vector3(vector.x - num, vector.y - num, vector.z - num);
			float num2 = color.w + 1f;
			return new Vector3(vector.x + num2, vector.y + num2, vector.z + num2);
		}

		public static float LogCToLinear(float x)
		{
			return (x <= 0.1530537f) ? ((x - 0.092819f) / 5.301883f) : ((Mathf.Pow(10f, (x - 0.386036f) / 0.244161f) - 0.047996f) / 5.555556f);
		}

		public static float LinearToLogC(float x)
		{
			return (x <= 0.011361f) ? (5.301883f * x + 0.092819f) : (0.244161f * Mathf.Log10(5.555556f * x + 0.047996f) + 0.386036f);
		}

		public static uint ToHex(Color c)
		{
			return (uint)(c.a * 255f) << 24 | (uint)(c.r * 255f) << 16 | (uint)(c.g * 255f) << 8 | (uint)(c.b * 255f);
		}

		public static Color ToRGBA(uint hex)
		{
			return new Color((hex >> 16 & 255u) / 255f, (hex >> 8 & 255u) / 255f, (hex & 255u) / 255f, (hex >> 24 & 255u) / 255f);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public class HableCurve
	{
		public class Segment
		{
			public float offsetX;

			public float offsetY;

			public float scaleX;

			public float scaleY;

			public float lnA;

			public float B;

			public float Eval(float x)
			{
				float num = (x - this.offsetX) * this.scaleX;
				float num2 = 0f;
				if (num > 0f)
				{
					num2 = Mathf.Exp(this.lnA + this.B * Mathf.Log(num));
				}
				return num2 * this.scaleY + this.offsetY;
			}
		}

		private struct DirectParams
		{
			internal float x0;

			internal float y0;

			internal float x1;

			internal float y1;

			internal float W;

			internal float overshootX;

			internal float overshootY;

			internal float gamma;
		}

		public class Uniforms
		{
			private HableCurve parent;

			public Vector4 curve
			{
				get
				{
					return new Vector4(this.parent.inverseWhitePoint, this.parent.x0, this.parent.x1, 0f);
				}
			}

			public Vector4 toeSegmentA
			{
				get
				{
					HableCurve.Segment segment = this.parent.segments[0];
					return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
				}
			}

			public Vector4 toeSegmentB
			{
				get
				{
					HableCurve.Segment segment = this.parent.segments[0];
					return new Vector4(segment.lnA, segment.B, 0f, 0f);
				}
			}

			public Vector4 midSegmentA
			{
				get
				{
					HableCurve.Segment segment = this.parent.segments[1];
					return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
				}
			}

			public Vector4 midSegmentB
			{
				get
				{
					HableCurve.Segment segment = this.parent.segments[1];
					return new Vector4(segment.lnA, segment.B, 0f, 0f);
				}
			}

			public Vector4 shoSegmentA
			{
				get
				{
					HableCurve.Segment segment = this.parent.segments[2];
					return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
				}
			}

			public Vector4 shoSegmentB
			{
				get
				{
					HableCurve.Segment segment = this.parent.segments[2];
					return new Vector4(segment.lnA, segment.B, 0f, 0f);
				}
			}

			internal Uniforms(HableCurve parent)
			{
				this.parent = parent;
			}
		}

		public readonly HableCurve.Segment[] segments = new HableCurve.Segment[3];

		public readonly HableCurve.Uniforms uniforms;

		public float whitePoint
		{
			get;
			private set;
		}

		public float inverseWhitePoint
		{
			get;
			private set;
		}

		public float x0
		{
			get;
			private set;
		}

		public float x1
		{
			get;
			private set;
		}

		public HableCurve()
		{
			for (int i = 0; i < 3; i++)
			{
				this.segments[i] = new HableCurve.Segment();
			}
			this.uniforms = new HableCurve.Uniforms(this);
		}

		public float Eval(float x)
		{
			float num = x * this.inverseWhitePoint;
			int num2 = (num >= this.x0) ? ((num >= this.x1) ? 2 : 1) : 0;
			HableCurve.Segment segment = this.segments[num2];
			return segment.Eval(num);
		}

		public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma)
		{
			HableCurve.DirectParams srcParams = default(HableCurve.DirectParams);
			toeLength = Mathf.Pow(Mathf.Clamp01(toeLength), 2.2f);
			toeStrength = Mathf.Clamp01(toeStrength);
			shoulderAngle = Mathf.Clamp01(shoulderAngle);
			shoulderStrength = Mathf.Clamp(shoulderStrength, 1E-05f, 0.99999f);
			shoulderLength = Mathf.Max(0f, shoulderLength);
			gamma = Mathf.Max(1E-05f, gamma);
			float num = toeLength * 0.5f;
			float num2 = (1f - toeStrength) * num;
			float num3 = 1f - num2;
			float num4 = num + num3;
			float num5 = (1f - shoulderStrength) * num3;
			float x = num + num5;
			float y = num2 + num5;
			float num6 = RuntimeUtilities.Exp2(shoulderLength) - 1f;
			float w = num4 + num6;
			srcParams.x0 = num;
			srcParams.y0 = num2;
			srcParams.x1 = x;
			srcParams.y1 = y;
			srcParams.W = w;
			srcParams.gamma = gamma;
			srcParams.overshootX = srcParams.W * 2f * shoulderAngle * shoulderLength;
			srcParams.overshootY = 0.5f * shoulderAngle * shoulderLength;
			this.InitSegments(srcParams);
		}

		private void InitSegments(HableCurve.DirectParams srcParams)
		{
			HableCurve.DirectParams directParams = srcParams;
			this.whitePoint = srcParams.W;
			this.inverseWhitePoint = 1f / srcParams.W;
			directParams.W = 1f;
			directParams.x0 /= srcParams.W;
			directParams.x1 /= srcParams.W;
			directParams.overshootX = srcParams.overshootX / srcParams.W;
			float num;
			float num2;
			this.AsSlopeIntercept(out num, out num2, directParams.x0, directParams.x1, directParams.y0, directParams.y1);
			float gamma = srcParams.gamma;
			HableCurve.Segment segment = this.segments[1];
			segment.offsetX = -(num2 / num);
			segment.offsetY = 0f;
			segment.scaleX = 1f;
			segment.scaleY = 1f;
			segment.lnA = gamma * Mathf.Log(num);
			segment.B = gamma;
			float m = this.EvalDerivativeLinearGamma(num, num2, gamma, directParams.x0);
			float m2 = this.EvalDerivativeLinearGamma(num, num2, gamma, directParams.x1);
			directParams.y0 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y0, directParams.gamma));
			directParams.y1 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y1, directParams.gamma));
			directParams.overshootY = Mathf.Pow(1f + directParams.overshootY, directParams.gamma) - 1f;
			this.x0 = directParams.x0;
			this.x1 = directParams.x1;
			HableCurve.Segment segment2 = this.segments[0];
			segment2.offsetX = 0f;
			segment2.offsetY = 0f;
			segment2.scaleX = 1f;
			segment2.scaleY = 1f;
			float lnA;
			float b;
			this.SolveAB(out lnA, out b, directParams.x0, directParams.y0, m);
			segment2.lnA = lnA;
			segment2.B = b;
			HableCurve.Segment segment3 = this.segments[2];
			float x = 1f + directParams.overshootX - directParams.x1;
			float y = 1f + directParams.overshootY - directParams.y1;
			float lnA2;
			float b2;
			this.SolveAB(out lnA2, out b2, x, y, m2);
			segment3.offsetX = 1f + directParams.overshootX;
			segment3.offsetY = 1f + directParams.overshootY;
			segment3.scaleX = -1f;
			segment3.scaleY = -1f;
			segment3.lnA = lnA2;
			segment3.B = b2;
			float num3 = this.segments[2].Eval(1f);
			float num4 = 1f / num3;
			this.segments[0].offsetY *= num4;
			this.segments[0].scaleY *= num4;
			this.segments[1].offsetY *= num4;
			this.segments[1].scaleY *= num4;
			this.segments[2].offsetY *= num4;
			this.segments[2].scaleY *= num4;
		}

		private void SolveAB(out float lnA, out float B, float x0, float y0, float m)
		{
			B = m * x0 / y0;
			lnA = Mathf.Log(y0) - B * Mathf.Log(x0);
		}

		private void AsSlopeIntercept(out float m, out float b, float x0, float x1, float y0, float y1)
		{
			float num = y1 - y0;
			float num2 = x1 - x0;
			if (num2 == 0f)
			{
				m = 1f;
			}
			else
			{
				m = num / num2;
			}
			b = y0 - x0 * m;
		}

		private float EvalDerivativeLinearGamma(float m, float b, float g, float x)
		{
			return g * m * Mathf.Pow(m * x + b, g - 1f);
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public static class HaltonSeq
	{
		public static float Get(int index, int radix)
		{
			float num = 0f;
			float num2 = 1f / (float)radix;
			while (index > 0)
			{
				num += (float)(index % radix) * num2;
				index /= radix;
				num2 /= (float)radix;
			}
			return num;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class LogHistogram
	{
		public const int rangeMin = -9;

		public const int rangeMax = 9;

		private const int k_Bins = 128;

		private int m_ThreadX;

		private int m_ThreadY;

		public ComputeBuffer data
		{
			get;
			private set;
		}

		public void Generate(PostProcessRenderContext context)
		{
			if (this.data == null)
			{
				this.m_ThreadX = 16;
				this.m_ThreadY = ((!RuntimeUtilities.isAndroidOpenGL) ? 16 : 8);
				this.data = new ComputeBuffer(128, 4);
			}
			Vector4 histogramScaleOffsetRes = this.GetHistogramScaleOffsetRes(context);
			ComputeShader exposureHistogram = context.resources.computeShaders.exposureHistogram;
			CommandBuffer command = context.command;
			command.BeginSample("LogHistogram");
			int kernelIndex = exposureHistogram.FindKernel("KEyeHistogramClear");
			command.SetComputeBufferParam(exposureHistogram, kernelIndex, "_HistogramBuffer", this.data);
			command.DispatchCompute(exposureHistogram, kernelIndex, Mathf.CeilToInt(128f / (float)this.m_ThreadX), 1, 1);
			kernelIndex = exposureHistogram.FindKernel("KEyeHistogram");
			command.SetComputeBufferParam(exposureHistogram, kernelIndex, "_HistogramBuffer", this.data);
			command.SetComputeTextureParam(exposureHistogram, kernelIndex, "_Source", context.source);
			command.SetComputeVectorParam(exposureHistogram, "_ScaleOffsetRes", histogramScaleOffsetRes);
			command.DispatchCompute(exposureHistogram, kernelIndex, Mathf.CeilToInt(histogramScaleOffsetRes.z / (float)this.m_ThreadX), Mathf.CeilToInt(histogramScaleOffsetRes.w / (float)this.m_ThreadY), 1);
			command.EndSample("LogHistogram");
		}

		public Vector4 GetHistogramScaleOffsetRes(PostProcessRenderContext context)
		{
			float num = 18f;
			float num2 = 1f / num;
			float y = 9f * num2;
			return new Vector4(num2, y, (float)context.width, (float)context.height);
		}

		public void Release()
		{
			if (this.data != null)
			{
				this.data.Release();
			}
			this.data = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering.PostProcessing
{
	internal static class MeshUtilities
	{
		private static Dictionary<PrimitiveType, Mesh> s_Primitives;

		private static Dictionary<Type, PrimitiveType> s_ColliderPrimitives;

		static MeshUtilities()
		{
			MeshUtilities.s_Primitives = new Dictionary<PrimitiveType, Mesh>();
			MeshUtilities.s_ColliderPrimitives = new Dictionary<Type, PrimitiveType>
			{
				{
					typeof(BoxCollider),
					PrimitiveType.Cube
				},
				{
					typeof(SphereCollider),
					PrimitiveType.Sphere
				},
				{
					typeof(CapsuleCollider),
					PrimitiveType.Capsule
				}
			};
		}

		internal static Mesh GetColliderMesh(Collider collider)
		{
			Type type = collider.GetType();
			if (type == typeof(MeshCollider))
			{
				return ((MeshCollider)collider).sharedMesh;
			}
			return MeshUtilities.GetPrimitive(MeshUtilities.s_ColliderPrimitives[type]);
		}

		internal static Mesh GetPrimitive(PrimitiveType primitiveType)
		{
			Mesh builtinMesh;
			if (!MeshUtilities.s_Primitives.TryGetValue(primitiveType, out builtinMesh))
			{
				builtinMesh = MeshUtilities.GetBuiltinMesh(primitiveType);
				MeshUtilities.s_Primitives.Add(primitiveType, builtinMesh);
			}
			return builtinMesh;
		}

		private static Mesh GetBuiltinMesh(PrimitiveType primitiveType)
		{
			GameObject gameObject = GameObject.CreatePrimitive(primitiveType);
			Mesh sharedMesh = gameObject.GetComponent<MeshFilter>().sharedMesh;
			RuntimeUtilities.Destroy(gameObject);
			return sharedMesh;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PropertySheet
	{
		public MaterialPropertyBlock properties
		{
			get;
			private set;
		}

		internal Material material
		{
			get;
			private set;
		}

		internal PropertySheet(Material material)
		{
			this.material = material;
			this.properties = new MaterialPropertyBlock();
		}

		public void ClearKeywords()
		{
			this.material.shaderKeywords = null;
		}

		public void EnableKeyword(string keyword)
		{
			this.material.EnableKeyword(keyword);
		}

		public void DisableKeyword(string keyword)
		{
			this.material.DisableKeyword(keyword);
		}

		internal void Release()
		{
			RuntimeUtilities.Destroy(this.material);
			this.material = null;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering.PostProcessing
{
	public sealed class PropertySheetFactory
	{
		private readonly Dictionary<Shader, PropertySheet> m_Sheets;

		public PropertySheetFactory()
		{
			this.m_Sheets = new Dictionary<Shader, PropertySheet>();
		}

		public PropertySheet Get(string shaderName)
		{
			return this.Get(Shader.Find(shaderName));
		}

		public PropertySheet Get(Shader shader)
		{
			PropertySheet propertySheet;
			if (this.m_Sheets.TryGetValue(shader, out propertySheet))
			{
				return propertySheet;
			}
			if (shader == null)
			{
				throw new ArgumentException(string.Format("Invalid shader ({0})", shader));
			}
			string name = shader.name;
			Material material = new Material(shader)
			{
				name = string.Format("PostProcess - {0}", name.Substring(name.LastIndexOf('/') + 1)),
				hideFlags = HideFlags.DontSave
			};
			propertySheet = new PropertySheet(material);
			this.m_Sheets.Add(shader, propertySheet);
			return propertySheet;
		}

		public void Release()
		{
			foreach (PropertySheet current in this.m_Sheets.Values)
			{
				current.Release();
			}
			this.m_Sheets.Clear();
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using UnityEngine.SceneManagement;
using UnityEngine.XR;

namespace UnityEngine.Rendering.PostProcessing
{
	public static class RuntimeUtilities
	{
		private sealed class _GetAllSceneObjects_c__Iterator0<T> : IEnumerable, IEnumerable<T>, IEnumerator, IDisposable, IEnumerator<T> where T : Component
		{
			internal Queue<Transform> _queue___0;

			internal GameObject[] _roots___0;

			internal GameObject[] _locvar0;

			internal int _locvar1;

			internal GameObject _root___1;

			internal T _comp___2;

			internal IEnumerator _locvar2;

			internal Transform _child___3;

			internal IDisposable _locvar3;

			internal T _comp___4;

			internal T _current;

			internal bool _disposing;

			internal int _PC;

			T IEnumerator<T>.Current
			{
				get
				{
					return this._current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this._current;
				}
			}

			public _GetAllSceneObjects_c__Iterator0()
			{
			}

			public bool MoveNext()
			{
				uint num = (uint)this._PC;
				this._PC = -1;
				bool flag = false;
				switch (num)
				{
				case 0u:
					this._queue___0 = new Queue<Transform>();
					this._roots___0 = SceneManager.GetActiveScene().GetRootGameObjects();
					this._locvar0 = this._roots___0;
					this._locvar1 = 0;
					break;
				case 1u:
					IL_CD:
					this._locvar1++;
					break;
				case 2u:
					Block_5:
					try
					{
						switch (num)
						{
						}
						while (this._locvar2.MoveNext())
						{
							this._child___3 = (Transform)this._locvar2.Current;
							this._queue___0.Enqueue(this._child___3);
							this._comp___4 = this._child___3.GetComponent<T>();
							if (this._comp___4 != null)
							{
								this._current = this._comp___4;
								if (!this._disposing)
								{
									this._PC = 2;
								}
								flag = true;
								return true;
							}
						}
					}
					finally
					{
						if (!flag)
						{
							if ((this._locvar3 = (this._locvar2 as IDisposable)) != null)
							{
								this._locvar3.Dispose();
							}
						}
					}
					goto IL_1CB;
				default:
					return false;
				}
				if (this._locvar1 < this._locvar0.Length)
				{
					this._root___1 = this._locvar0[this._locvar1];
					this._queue___0.Enqueue(this._root___1.transform);
					this._comp___2 = this._root___1.GetComponent<T>();
					if (this._comp___2 != null)
					{
						this._current = this._comp___2;
						if (!this._disposing)
						{
							this._PC = 1;
						}
						return true;
					}
					goto IL_CD;
				}
				IL_1CB:
				if (this._queue___0.Count > 0)
				{
					this._locvar2 = this._queue___0.Dequeue().GetEnumerator();
					num = 4294967293u;
					goto Block_5;
				}
				this._PC = -1;
				return false;
			}

			public void Dispose()
			{
				uint num = (uint)this._PC;
				this._disposing = true;
				this._PC = -1;
				switch (num)
				{
				case 2u:
					try
					{
					}
					finally
					{
						if ((this._locvar3 = (this._locvar2 as IDisposable)) != null)
						{
							this._locvar3.Dispose();
						}
					}
					break;
				}
			}

			public void Reset()
			{
				throw new NotSupportedException();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return this.System.Collections.Generic.IEnumerable<T>.GetEnumerator();
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				if (Interlocked.CompareExchange(ref this._PC, 0, -2) == -2)
				{
					return this;
				}
				return new RuntimeUtilities._GetAllSceneObjects_c__Iterator0<T>();
			}
		}

		private static Texture2D m_WhiteTexture;

		private static Texture2D m_BlackTexture;

		private static Texture2D m_TransparentTexture;

		private static Mesh s_FullscreenTriangle;

		private static Material s_CopyStdMaterial;

		private static Material s_CopyMaterial;

		private static PropertySheet s_CopySheet;

		private static Func<Assembly, IEnumerable<Type>> __f__am_cache0;

		public static Texture2D whiteTexture
		{
			get
			{
				if (RuntimeUtilities.m_WhiteTexture == null)
				{
					RuntimeUtilities.m_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, false);
					RuntimeUtilities.m_WhiteTexture.SetPixel(0, 0, Color.white);
					RuntimeUtilities.m_WhiteTexture.Apply();
				}
				return RuntimeUtilities.m_WhiteTexture;
			}
		}

		public static Texture2D blackTexture
		{
			get
			{
				if (RuntimeUtilities.m_BlackTexture == null)
				{
					RuntimeUtilities.m_BlackTexture = new Texture2D(1, 1, TextureFormat.ARGB32, false);
					RuntimeUtilities.m_BlackTexture.SetPixel(0, 0, Color.black);
					RuntimeUtilities.m_BlackTexture.Apply();
				}
				return RuntimeUtilities.m_BlackTexture;
			}
		}

		public static Texture2D transparentTexture
		{
			get
			{
				if (RuntimeUtilities.m_TransparentTexture == null)
				{
					RuntimeUtilities.m_TransparentTexture = new Texture2D(1, 1, TextureFormat.ARGB32, false);
					RuntimeUtilities.m_TransparentTexture.SetPixel(0, 0, Color.clear);
					RuntimeUtilities.m_TransparentTexture.Apply();
				}
				return RuntimeUtilities.m_TransparentTexture;
			}
		}

		public static Mesh fullscreenTriangle
		{
			get
			{
				if (RuntimeUtilities.s_FullscreenTriangle != null)
				{
					return RuntimeUtilities.s_FullscreenTriangle;
				}
				RuntimeUtilities.s_FullscreenTriangle = new Mesh
				{
					name = "Fullscreen Triangle"
				};
				RuntimeUtilities.s_FullscreenTriangle.SetVertices(new List<Vector3>
				{
					new Vector3(-1f, -1f, 0f),
					new Vector3(-1f, 3f, 0f),
					new Vector3(3f, -1f, 0f)
				});
				RuntimeUtilities.s_FullscreenTriangle.SetIndices(new int[]
				{
					0,
					1,
					2
				}, MeshTopology.Triangles, 0, false);
				RuntimeUtilities.s_FullscreenTriangle.UploadMeshData(false);
				return RuntimeUtilities.s_FullscreenTriangle;
			}
		}

		public static Material copyStdMaterial
		{
			get
			{
				if (RuntimeUtilities.s_CopyStdMaterial != null)
				{
					return RuntimeUtilities.s_CopyStdMaterial;
				}
				Shader shader = Shader.Find("Hidden/PostProcessing/CopyStd");
				RuntimeUtilities.s_CopyStdMaterial = new Material(shader)
				{
					name = "PostProcess - CopyStd",
					hideFlags = HideFlags.HideAndDontSave
				};
				return RuntimeUtilities.s_CopyStdMaterial;
			}
		}

		public static Material copyMaterial
		{
			get
			{
				if (RuntimeUtilities.s_CopyMaterial != null)
				{
					return RuntimeUtilities.s_CopyMaterial;
				}
				Shader shader = Shader.Find("Hidden/PostProcessing/Copy");
				RuntimeUtilities.s_CopyMaterial = new Material(shader)
				{
					name = "PostProcess - Copy",
					hideFlags = HideFlags.HideAndDontSave
				};
				return RuntimeUtilities.s_CopyMaterial;
			}
		}

		public static PropertySheet copySheet
		{
			get
			{
				if (RuntimeUtilities.s_CopySheet == null)
				{
					RuntimeUtilities.s_CopySheet = new PropertySheet(RuntimeUtilities.copyMaterial);
				}
				return RuntimeUtilities.s_CopySheet;
			}
		}

		public static bool scriptableRenderPipelineActive
		{
			get
			{
				return GraphicsSettings.renderPipelineAsset != null;
			}
		}

		public static bool isSinglePassStereoEnabled
		{
			get
			{
				return XRSettings.eyeTextureDesc.vrUsage == VRTextureUsage.TwoEyes;
			}
		}

		public static bool isVREnabled
		{
			get
			{
				return XRSettings.enabled;
			}
		}

		public static bool isAndroidOpenGL
		{
			get
			{
				return Application.platform == RuntimePlatform.Android && SystemInfo.graphicsDeviceType != GraphicsDeviceType.Vulkan;
			}
		}

		public static bool isLinearColorSpace
		{
			get
			{
				return QualitySettings.activeColorSpace == ColorSpace.Linear;
			}
		}

		public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, bool clear = false)
		{
			cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
			cmd.SetRenderTarget(destination);
			if (clear)
			{
				cmd.ClearRenderTarget(true, true, Color.clear);
			}
			cmd.DrawMesh(RuntimeUtilities.fullscreenTriangle, Matrix4x4.identity, RuntimeUtilities.copyMaterial, 0, 0);
		}

		public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false)
		{
			cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
			cmd.SetRenderTarget(destination);
			if (clear)
			{
				cmd.ClearRenderTarget(true, true, Color.clear);
			}
			cmd.DrawMesh(RuntimeUtilities.fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
		}

		public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false)
		{
			cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
			cmd.SetRenderTarget(destination, depth);
			if (clear)
			{
				cmd.ClearRenderTarget(true, true, Color.clear);
			}
			cmd.DrawMesh(RuntimeUtilities.fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
		}

		public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier[] destinations, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false)
		{
			cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
			cmd.SetRenderTarget(destinations, depth);
			if (clear)
			{
				cmd.ClearRenderTarget(true, true, Color.clear);
			}
			cmd.DrawMesh(RuntimeUtilities.fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
		}

		public static void BlitFullscreenTriangle(Texture source, RenderTexture destination, Material material, int pass)
		{
			RenderTexture active = RenderTexture.active;
			material.SetPass(pass);
			if (source != null)
			{
				material.SetTexture(ShaderIDs.MainTex, source);
			}
			Graphics.SetRenderTarget(destination);
			Graphics.DrawMeshNow(RuntimeUtilities.fullscreenTriangle, Matrix4x4.identity);
			RenderTexture.active = active;
		}

		public static void CopyTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
		{
			if (SystemInfo.copyTextureSupport > CopyTextureSupport.None)
			{
				cmd.CopyTexture(source, destination);
				return;
			}
			cmd.BlitFullscreenTriangle(source, destination, false);
		}

		public static void Destroy(UnityEngine.Object obj)
		{
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}

		public static bool IsResolvedDepthAvailable(Camera camera)
		{
			GraphicsDeviceType graphicsDeviceType = SystemInfo.graphicsDeviceType;
			return camera.actualRenderingPath == RenderingPath.DeferredShading && (graphicsDeviceType == GraphicsDeviceType.Direct3D11 || graphicsDeviceType == GraphicsDeviceType.Direct3D12 || graphicsDeviceType == GraphicsDeviceType.XboxOne);
		}

		public static void DestroyProfile(PostProcessProfile profile, bool destroyEffects)
		{
			if (destroyEffects)
			{
				foreach (PostProcessEffectSettings current in profile.settings)
				{
					RuntimeUtilities.Destroy(current);
				}
			}
			RuntimeUtilities.Destroy(profile);
		}

		public static void DestroyVolume(PostProcessVolume volume, bool destroySharedProfile)
		{
			if (destroySharedProfile)
			{
				RuntimeUtilities.DestroyProfile(volume.sharedProfile, true);
			}
			RuntimeUtilities.Destroy(volume);
		}

		public static IEnumerable<T> GetAllSceneObjects<T>() where T : Component
		{
			RuntimeUtilities._GetAllSceneObjects_c__Iterator0<T> _GetAllSceneObjects_c__Iterator = new RuntimeUtilities._GetAllSceneObjects_c__Iterator0<T>();
			RuntimeUtilities._GetAllSceneObjects_c__Iterator0<T> expr_07 = _GetAllSceneObjects_c__Iterator;
			expr_07._PC = -2;
			return expr_07;
		}

		public static void CreateIfNull<T>(ref T obj) where T : class, new()
		{
			if (obj == null)
			{
				obj = Activator.CreateInstance<T>();
			}
		}

		public static float Exp2(float x)
		{
			return Mathf.Exp(x * 0.6931472f);
		}

		public static Matrix4x4 GetJitteredPerspectiveProjectionMatrix(Camera camera, Vector2 offset)
		{
			float num = Mathf.Tan(0.008726646f * camera.fieldOfView);
			float num2 = num * camera.aspect;
			float nearClipPlane = camera.nearClipPlane;
			float farClipPlane = camera.farClipPlane;
			offset.x *= num2 / (0.5f * (float)camera.pixelWidth);
			offset.y *= num / (0.5f * (float)camera.pixelHeight);
			float num3 = (offset.x - num2) * nearClipPlane;
			float num4 = (offset.x + num2) * nearClipPlane;
			float num5 = (offset.y + num) * nearClipPlane;
			float num6 = (offset.y - num) * nearClipPlane;
			Matrix4x4 result = default(Matrix4x4);
			result[0, 0] = 2f * nearClipPlane / (num4 - num3);
			result[0, 1] = 0f;
			result[0, 2] = (num4 + num3) / (num4 - num3);
			result[0, 3] = 0f;
			result[1, 0] = 0f;
			result[1, 1] = 2f * nearClipPlane / (num5 - num6);
			result[1, 2] = (num5 + num6) / (num5 - num6);
			result[1, 3] = 0f;
			result[2, 0] = 0f;
			result[2, 1] = 0f;
			result[2, 2] = -(farClipPlane + nearClipPlane) / (farClipPlane - nearClipPlane);
			result[2, 3] = -(2f * farClipPlane * nearClipPlane) / (farClipPlane - nearClipPlane);
			result[3, 0] = 0f;
			result[3, 1] = 0f;
			result[3, 2] = -1f;
			result[3, 3] = 0f;
			return result;
		}

		public static Matrix4x4 GetJitteredOrthographicProjectionMatrix(Camera camera, Vector2 offset)
		{
			float orthographicSize = camera.orthographicSize;
			float num = orthographicSize * camera.aspect;
			offset.x *= num / (0.5f * (float)camera.pixelWidth);
			offset.y *= orthographicSize / (0.5f * (float)camera.pixelHeight);
			float left = offset.x - num;
			float right = offset.x + num;
			float top = offset.y + orthographicSize;
			float bottom = offset.y - orthographicSize;
			return Matrix4x4.Ortho(left, right, bottom, top, camera.nearClipPlane, camera.farClipPlane);
		}

		public static Matrix4x4 GenerateJitteredProjectionMatrixFromOriginal(PostProcessRenderContext context, Matrix4x4 origProj, Vector2 jitter)
		{
			FrustumPlanes decomposeProjection = origProj.decomposeProjection;
			float num = Math.Abs(decomposeProjection.top) + Math.Abs(decomposeProjection.bottom);
			float num2 = Math.Abs(decomposeProjection.left) + Math.Abs(decomposeProjection.right);
			Vector2 vector = new Vector2(jitter.x * num2 / (float)context.screenWidth, jitter.y * num / (float)context.screenHeight);
			decomposeProjection.left += vector.x;
			decomposeProjection.right += vector.x;
			decomposeProjection.top += vector.y;
			decomposeProjection.bottom += vector.y;
			return Matrix4x4.Frustum(decomposeProjection);
		}

		public static IEnumerable<Type> GetAllAssemblyTypes()
		{
			IEnumerable<Assembly> arg_27_0 = AppDomain.CurrentDomain.GetAssemblies();
			if (RuntimeUtilities.__f__am_cache0 == null)
			{
				RuntimeUtilities.__f__am_cache0 = new Func<Assembly, IEnumerable<Type>>(RuntimeUtilities._GetAllAssemblyTypes_m__0);
			}
			return arg_27_0.SelectMany(RuntimeUtilities.__f__am_cache0);
		}

		public static T GetAttribute<T>(this Type type) where T : Attribute
		{
			return (T)((object)type.GetCustomAttributes(typeof(T), false)[0]);
		}

		public static Attribute[] GetMemberAttributes<TType, TValue>(Expression<Func<TType, TValue>> expr)
		{
			Expression expression = expr;
			if (expression is LambdaExpression)
			{
				expression = ((LambdaExpression)expression).Body;
			}
			ExpressionType nodeType = expression.NodeType;
			if (nodeType != ExpressionType.MemberAccess)
			{
				throw new InvalidOperationException();
			}
			FieldInfo fieldInfo = (FieldInfo)((MemberExpression)expression).Member;
			return fieldInfo.GetCustomAttributes(false).Cast<Attribute>().ToArray<Attribute>();
		}

		public static string GetFieldPath<TType, TValue>(Expression<Func<TType, TValue>> expr)
		{
			ExpressionType nodeType = expr.Body.NodeType;
			if (nodeType != ExpressionType.MemberAccess)
			{
				throw new InvalidOperationException();
			}
			MemberExpression memberExpression = expr.Body as MemberExpression;
			List<string> list = new List<string>();
			while (memberExpression != null)
			{
				list.Add(memberExpression.Member.Name);
				memberExpression = (memberExpression.Expression as MemberExpression);
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = list.Count - 1; i >= 0; i--)
			{
				stringBuilder.Append(list[i]);
				if (i > 0)
				{
					stringBuilder.Append('.');
				}
			}
			return stringBuilder.ToString();
		}

		public static object GetParentObject(string path, object obj)
		{
			string[] array = path.Split(new char[]
			{
				'.'
			});
			if (array.Length == 1)
			{
				return obj;
			}
			FieldInfo field = obj.GetType().GetField(array[0], BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			obj = field.GetValue(obj);
			return RuntimeUtilities.GetParentObject(string.Join(".", array, 1, array.Length - 1), obj);
		}

		private static IEnumerable<Type> _GetAllAssemblyTypes_m__0(Assembly t)
		{
			Type[] result = new Type[0];
			try
			{
				result = t.GetTypes();
			}
			catch
			{
			}
			return result;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	internal static class ShaderIDs
	{
		internal static readonly int MainTex = Shader.PropertyToID("_MainTex");

		internal static readonly int Jitter = Shader.PropertyToID("_Jitter");

		internal static readonly int Sharpness = Shader.PropertyToID("_Sharpness");

		internal static readonly int FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

		internal static readonly int HistoryTex = Shader.PropertyToID("_HistoryTex");

		internal static readonly int SMAA_Flip = Shader.PropertyToID("_SMAA_Flip");

		internal static readonly int SMAA_Flop = Shader.PropertyToID("_SMAA_Flop");

		internal static readonly int AOParams = Shader.PropertyToID("_AOParams");

		internal static readonly int AOColor = Shader.PropertyToID("_AOColor");

		internal static readonly int OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

		internal static readonly int OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

		internal static readonly int SAOcclusionTexture = Shader.PropertyToID("_SAOcclusionTexture");

		internal static readonly int MSVOcclusionTexture = Shader.PropertyToID("_MSVOcclusionTexture");

		internal static readonly int DepthCopy = Shader.PropertyToID("DepthCopy");

		internal static readonly int LinearDepth = Shader.PropertyToID("LinearDepth");

		internal static readonly int LowDepth1 = Shader.PropertyToID("LowDepth1");

		internal static readonly int LowDepth2 = Shader.PropertyToID("LowDepth2");

		internal static readonly int LowDepth3 = Shader.PropertyToID("LowDepth3");

		internal static readonly int LowDepth4 = Shader.PropertyToID("LowDepth4");

		internal static readonly int TiledDepth1 = Shader.PropertyToID("TiledDepth1");

		internal static readonly int TiledDepth2 = Shader.PropertyToID("TiledDepth2");

		internal static readonly int TiledDepth3 = Shader.PropertyToID("TiledDepth3");

		internal static readonly int TiledDepth4 = Shader.PropertyToID("TiledDepth4");

		internal static readonly int Occlusion1 = Shader.PropertyToID("Occlusion1");

		internal static readonly int Occlusion2 = Shader.PropertyToID("Occlusion2");

		internal static readonly int Occlusion3 = Shader.PropertyToID("Occlusion3");

		internal static readonly int Occlusion4 = Shader.PropertyToID("Occlusion4");

		internal static readonly int Combined1 = Shader.PropertyToID("Combined1");

		internal static readonly int Combined2 = Shader.PropertyToID("Combined2");

		internal static readonly int Combined3 = Shader.PropertyToID("Combined3");

		internal static readonly int SSRResolveTemp = Shader.PropertyToID("_SSRResolveTemp");

		internal static readonly int Noise = Shader.PropertyToID("_Noise");

		internal static readonly int Test = Shader.PropertyToID("_Test");

		internal static readonly int Resolve = Shader.PropertyToID("_Resolve");

		internal static readonly int History = Shader.PropertyToID("_History");

		internal static readonly int ViewMatrix = Shader.PropertyToID("_ViewMatrix");

		internal static readonly int InverseViewMatrix = Shader.PropertyToID("_InverseViewMatrix");

		internal static readonly int InverseProjectionMatrix = Shader.PropertyToID("_InverseProjectionMatrix");

		internal static readonly int ScreenSpaceProjectionMatrix = Shader.PropertyToID("_ScreenSpaceProjectionMatrix");

		internal static readonly int Params2 = Shader.PropertyToID("_Params2");

		internal static readonly int FogColor = Shader.PropertyToID("_FogColor");

		internal static readonly int FogParams = Shader.PropertyToID("_FogParams");

		internal static readonly int VelocityScale = Shader.PropertyToID("_VelocityScale");

		internal static readonly int MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

		internal static readonly int RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

		internal static readonly int VelocityTex = Shader.PropertyToID("_VelocityTex");

		internal static readonly int Tile2RT = Shader.PropertyToID("_Tile2RT");

		internal static readonly int Tile4RT = Shader.PropertyToID("_Tile4RT");

		internal static readonly int Tile8RT = Shader.PropertyToID("_Tile8RT");

		internal static readonly int TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

		internal static readonly int TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

		internal static readonly int TileVRT = Shader.PropertyToID("_TileVRT");

		internal static readonly int NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

		internal static readonly int LoopCount = Shader.PropertyToID("_LoopCount");

		internal static readonly int DepthOfFieldTemp = Shader.PropertyToID("_DepthOfFieldTemp");

		internal static readonly int DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

		internal static readonly int Distance = Shader.PropertyToID("_Distance");

		internal static readonly int LensCoeff = Shader.PropertyToID("_LensCoeff");

		internal static readonly int MaxCoC = Shader.PropertyToID("_MaxCoC");

		internal static readonly int RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

		internal static readonly int RcpAspect = Shader.PropertyToID("_RcpAspect");

		internal static readonly int CoCTex = Shader.PropertyToID("_CoCTex");

		internal static readonly int TaaParams = Shader.PropertyToID("_TaaParams");

		internal static readonly int AutoExposureTex = Shader.PropertyToID("_AutoExposureTex");

		internal static readonly int HistogramBuffer = Shader.PropertyToID("_HistogramBuffer");

		internal static readonly int Params = Shader.PropertyToID("_Params");

		internal static readonly int Speed = Shader.PropertyToID("_Speed");

		internal static readonly int ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");

		internal static readonly int ExposureCompensation = Shader.PropertyToID("_ExposureCompensation");

		internal static readonly int BloomTex = Shader.PropertyToID("_BloomTex");

		internal static readonly int SampleScale = Shader.PropertyToID("_SampleScale");

		internal static readonly int Threshold = Shader.PropertyToID("_Threshold");

		internal static readonly int ColorIntensity = Shader.PropertyToID("_ColorIntensity");

		internal static readonly int Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

		internal static readonly int Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

		internal static readonly int Bloom_Color = Shader.PropertyToID("_Bloom_Color");

		internal static readonly int Bloom_DirtTileOffset = Shader.PropertyToID("_Bloom_DirtTileOffset");

		internal static readonly int ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

		internal static readonly int ChromaticAberration_SpectralLut = Shader.PropertyToID("_ChromaticAberration_SpectralLut");

		internal static readonly int Lut2D = Shader.PropertyToID("_Lut2D");

		internal static readonly int Lut3D = Shader.PropertyToID("_Lut3D");

		internal static readonly int Lut3D_Params = Shader.PropertyToID("_Lut3D_Params");

		internal static readonly int Lut2D_Params = Shader.PropertyToID("_Lut2D_Params");

		internal static readonly int PostExposure = Shader.PropertyToID("_PostExposure");

		internal static readonly int ColorBalance = Shader.PropertyToID("_ColorBalance");

		internal static readonly int ColorFilter = Shader.PropertyToID("_ColorFilter");

		internal static readonly int HueSatCon = Shader.PropertyToID("_HueSatCon");

		internal static readonly int Brightness = Shader.PropertyToID("_Brightness");

		internal static readonly int ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

		internal static readonly int ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

		internal static readonly int ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

		internal static readonly int Lift = Shader.PropertyToID("_Lift");

		internal static readonly int InvGamma = Shader.PropertyToID("_InvGamma");

		internal static readonly int Gain = Shader.PropertyToID("_Gain");

		internal static readonly int Curves = Shader.PropertyToID("_Curves");

		internal static readonly int CustomToneCurve = Shader.PropertyToID("_CustomToneCurve");

		internal static readonly int ToeSegmentA = Shader.PropertyToID("_ToeSegmentA");

		internal static readonly int ToeSegmentB = Shader.PropertyToID("_ToeSegmentB");

		internal static readonly int MidSegmentA = Shader.PropertyToID("_MidSegmentA");

		internal static readonly int MidSegmentB = Shader.PropertyToID("_MidSegmentB");

		internal static readonly int ShoSegmentA = Shader.PropertyToID("_ShoSegmentA");

		internal static readonly int ShoSegmentB = Shader.PropertyToID("_ShoSegmentB");

		internal static readonly int Vignette_Color = Shader.PropertyToID("_Vignette_Color");

		internal static readonly int Vignette_Center = Shader.PropertyToID("_Vignette_Center");

		internal static readonly int Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

		internal static readonly int Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

		internal static readonly int Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");

		internal static readonly int Vignette_Mode = Shader.PropertyToID("_Vignette_Mode");

		internal static readonly int Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

		internal static readonly int Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

		internal static readonly int GrainTex = Shader.PropertyToID("_GrainTex");

		internal static readonly int Phase = Shader.PropertyToID("_Phase");

		internal static readonly int LumaInAlpha = Shader.PropertyToID("_LumaInAlpha");

		internal static readonly int DitheringTex = Shader.PropertyToID("_DitheringTex");

		internal static readonly int Dithering_Coords = Shader.PropertyToID("_Dithering_Coords");

		internal static readonly int From = Shader.PropertyToID("_From");

		internal static readonly int To = Shader.PropertyToID("_To");

		internal static readonly int Interp = Shader.PropertyToID("_Interp");

		internal static readonly int HalfResFinalCopy = Shader.PropertyToID("_HalfResFinalCopy");

		internal static readonly int WaveformSource = Shader.PropertyToID("_WaveformSource");

		internal static readonly int WaveformBuffer = Shader.PropertyToID("_WaveformBuffer");

		internal static readonly int VectorscopeBuffer = Shader.PropertyToID("_VectorscopeBuffer");

		internal static readonly int RenderViewportScaleFactor = Shader.PropertyToID("_RenderViewportScaleFactor");
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;

namespace UnityEngine.Rendering.PostProcessing
{
	[Serializable]
	public sealed class Spline
	{
		public const int k_Precision = 128;

		public const float k_Step = 0.0078125f;

		public AnimationCurve curve;

		[SerializeField]
		private bool m_Loop;

		[SerializeField]
		private float m_ZeroValue;

		[SerializeField]
		private float m_Range;

		private AnimationCurve m_InternalLoopingCurve;

		private int frameCount = -1;

		internal float[] cachedData;

		public Spline(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
		{
			this.curve = curve;
			this.m_ZeroValue = zeroValue;
			this.m_Loop = loop;
			this.m_Range = bounds.magnitude;
			this.cachedData = new float[128];
		}

		public void Cache(int frame)
		{
			if (frame == this.frameCount)
			{
				return;
			}
			int length = this.curve.length;
			if (this.m_Loop && length > 1)
			{
				if (this.m_InternalLoopingCurve == null)
				{
					this.m_InternalLoopingCurve = new AnimationCurve();
				}
				Keyframe key = this.curve[length - 1];
				key.time -= this.m_Range;
				Keyframe key2 = this.curve[0];
				key2.time += this.m_Range;
				this.m_InternalLoopingCurve.keys = this.curve.keys;
				this.m_InternalLoopingCurve.AddKey(key);
				this.m_InternalLoopingCurve.AddKey(key2);
			}
			for (int i = 0; i < 128; i++)
			{
				this.cachedData[i] = this.Evaluate((float)i * 0.0078125f);
			}
			this.frameCount = Time.renderedFrameCount;
		}

		public float Evaluate(float t)
		{
			if (this.curve.length == 0)
			{
				return this.m_ZeroValue;
			}
			if (!this.m_Loop || this.curve.length == 1)
			{
				return this.curve.Evaluate(t);
			}
			return this.m_InternalLoopingCurve.Evaluate(t);
		}

		public override int GetHashCode()
		{
			int num = 17;
			return num * 23 + this.curve.GetHashCode();
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering.PostProcessing
{
	internal class TargetPool
	{
		private readonly List<int> m_Pool;

		private int m_Current;

		internal TargetPool()
		{
			this.m_Pool = new List<int>();
			this.Get();
		}

		internal int Get()
		{
			int result = this.Get(this.m_Current);
			this.m_Current++;
			return result;
		}

		private int Get(int i)
		{
			int result;
			if (this.m_Pool.Count > i)
			{
				result = this.m_Pool[i];
			}
			else
			{
				while (this.m_Pool.Count <= i)
				{
					this.m_Pool.Add(Shader.PropertyToID("_TargetPool" + i));
				}
				result = this.m_Pool[i];
			}
			return result;
		}

		internal void Reset()
		{
			this.m_Current = 0;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;
using System.Linq;

namespace UnityEngine.Rendering.PostProcessing
{
	public static class TextureFormatUtilities
	{
		private static Dictionary<int, RenderTextureFormat> s_FormatAliasMap;

		private static Dictionary<int, bool> s_SupportedRenderTextureFormats;

		static TextureFormatUtilities()
		{
			TextureFormatUtilities.s_FormatAliasMap = new Dictionary<int, RenderTextureFormat>
			{
				{
					1,
					RenderTextureFormat.ARGB32
				},
				{
					2,
					RenderTextureFormat.ARGB4444
				},
				{
					3,
					RenderTextureFormat.ARGB32
				},
				{
					4,
					RenderTextureFormat.ARGB32
				},
				{
					5,
					RenderTextureFormat.ARGB32
				},
				{
					7,
					RenderTextureFormat.RGB565
				},
				{
					9,
					RenderTextureFormat.RHalf
				},
				{
					10,
					RenderTextureFormat.ARGB32
				},
				{
					12,
					RenderTextureFormat.ARGB32
				},
				{
					13,
					RenderTextureFormat.ARGB4444
				},
				{
					14,
					RenderTextureFormat.ARGB32
				},
				{
					15,
					RenderTextureFormat.RHalf
				},
				{
					16,
					RenderTextureFormat.RGHalf
				},
				{
					17,
					RenderTextureFormat.ARGBHalf
				},
				{
					18,
					RenderTextureFormat.RFloat
				},
				{
					19,
					RenderTextureFormat.RGFloat
				},
				{
					20,
					RenderTextureFormat.ARGBFloat
				},
				{
					22,
					RenderTextureFormat.ARGBHalf
				},
				{
					26,
					RenderTextureFormat.R8
				},
				{
					27,
					RenderTextureFormat.RGHalf
				},
				{
					24,
					RenderTextureFormat.ARGBHalf
				},
				{
					25,
					RenderTextureFormat.ARGB32
				},
				{
					28,
					RenderTextureFormat.ARGB32
				},
				{
					29,
					RenderTextureFormat.ARGB32
				},
				{
					30,
					RenderTextureFormat.ARGB32
				},
				{
					31,
					RenderTextureFormat.ARGB32
				},
				{
					32,
					RenderTextureFormat.ARGB32
				},
				{
					33,
					RenderTextureFormat.ARGB32
				},
				{
					34,
					RenderTextureFormat.ARGB32
				},
				{
					45,
					RenderTextureFormat.ARGB32
				},
				{
					46,
					RenderTextureFormat.ARGB32
				},
				{
					47,
					RenderTextureFormat.ARGB32
				},
				{
					48,
					RenderTextureFormat.ARGB32
				},
				{
					49,
					RenderTextureFormat.ARGB32
				},
				{
					50,
					RenderTextureFormat.ARGB32
				},
				{
					51,
					RenderTextureFormat.ARGB32
				},
				{
					52,
					RenderTextureFormat.ARGB32
				},
				{
					53,
					RenderTextureFormat.ARGB32
				},
				{
					54,
					RenderTextureFormat.ARGB32
				},
				{
					55,
					RenderTextureFormat.ARGB32
				},
				{
					56,
					RenderTextureFormat.ARGB32
				},
				{
					57,
					RenderTextureFormat.ARGB32
				},
				{
					58,
					RenderTextureFormat.ARGB32
				},
				{
					59,
					RenderTextureFormat.ARGB32
				},
				{
					60,
					RenderTextureFormat.ARGB32
				},
				{
					61,
					RenderTextureFormat.ARGB32
				}
			};
			TextureFormatUtilities.s_SupportedRenderTextureFormats = new Dictionary<int, bool>();
			IEnumerable<int> enumerable = Enum.GetValues(typeof(RenderTextureFormat)).Cast<int>();
			foreach (int current in enumerable)
			{
				bool value = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)current);
				TextureFormatUtilities.s_SupportedRenderTextureFormats.Add(current, value);
			}
		}

		public static RenderTextureFormat GetUncompressedRenderTextureFormat(Texture texture)
		{
			if (texture is RenderTexture)
			{
				return (texture as RenderTexture).format;
			}
			if (!(texture is Texture2D))
			{
				return RenderTextureFormat.Default;
			}
			TextureFormat format = ((Texture2D)texture).format;
			RenderTextureFormat result;
			if (!TextureFormatUtilities.s_FormatAliasMap.TryGetValue((int)format, out result))
			{
				throw new NotSupportedException("Texture format not supported");
			}
			return result;
		}

		internal static bool IsSupported(this RenderTextureFormat format)
		{
			bool result;
			TextureFormatUtilities.s_SupportedRenderTextureFormats.TryGetValue((int)format, out result);
			return result;
		}
	}
}

// Decompile from assembly: com.unity.postprocessing.Runtime.dll

using System;
using System.Collections.Generic;

namespace UnityEngine.Rendering.PostProcessing
{
	internal class TextureLerper
	{
		private static TextureLerper m_Instance;

		private CommandBuffer m_Command;

		private PropertySheetFactory m_PropertySheets;

		private PostProcessResources m_Resources;

		private List<RenderTexture> m_Recycled;

		private List<RenderTexture> m_Actives;

		internal static TextureLerper instance
		{
			get
			{
				if (TextureLerper.m_Instance == null)
				{
					TextureLerper.m_Instance = new TextureLerper();
				}
				return TextureLerper.m_Instance;
			}
		}

		private TextureLerper()
		{
			this.m_Recycled = new List<RenderTexture>();
			this.m_Actives = new List<RenderTexture>();
		}

		internal void BeginFrame(PostProcessRenderContext context)
		{
			this.m_Command = context.command;
			this.m_PropertySheets = context.propertySheets;
			this.m_Resources = context.resources;
		}

		internal void EndFrame()
		{
			if (this.m_Recycled.Count > 0)
			{
				foreach (RenderTexture current in this.m_Recycled)
				{
					RuntimeUtilities.Destroy(current);
				}
				this.m_Recycled.Clear();
			}
			if (this.m_Actives.Count > 0)
			{
				foreach (RenderTexture current2 in this.m_Actives)
				{
					this.m_Recycled.Add(current2);
				}
				this.m_Actives.Clear();
			}
		}

		private RenderTexture Get(RenderTextureFormat format, int w, int h, int d = 1, bool enableRandomWrite = false)
		{
			RenderTexture renderTexture = null;
			int count = this.m_Recycled.Count;
			int i;
			for (i = 0; i < count; i++)
			{
				RenderTexture renderTexture2 = this.m_Recycled[i];
				if (renderTexture2.width == w && renderTexture2.height == h && renderTexture2.volumeDepth == d && renderTexture2.format == format && renderTexture2.enableRandomWrite == enableRandomWrite)
				{
					renderTexture = renderTexture2;
					break;
				}
			}
			if (renderTexture == null)
			{
				TextureDimension dimension = (d <= 1) ? TextureDimension.Tex2D : TextureDimension.Tex3D;
				renderTexture = new RenderTexture(w, h, d, format)
				{
					dimension = dimension,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					anisoLevel = 0,
					volumeDepth = d,
					enableRandomWrite = enableRandomWrite
				};
				renderTexture.Create();
			}
			else
			{
				this.m_Recycled.RemoveAt(i);
			}
			this.m_Actives.Add(renderTexture);
			return renderTexture;
		}

		internal Texture Lerp(Texture from, Texture to, float t)
		{
			bool flag = to is Texture3D || (to is RenderTexture && ((RenderTexture)to).volumeDepth > 1);
			RenderTexture renderTexture;
			if (flag)
			{
				int width = to.width;
				renderTexture = this.Get(RenderTextureFormat.ARGBHalf, width, width, width, true);
				ComputeShader texture3dLerp = this.m_Resources.computeShaders.texture3dLerp;
				int kernelIndex = texture3dLerp.FindKernel("KTexture3DLerp");
				this.m_Command.SetComputeVectorParam(texture3dLerp, "_Params", new Vector4(t, (float)width, 0f, 0f));
				this.m_Command.SetComputeTextureParam(texture3dLerp, kernelIndex, "_Output", renderTexture);
				this.m_Command.SetComputeTextureParam(texture3dLerp, kernelIndex, "_From", from);
				this.m_Command.SetComputeTextureParam(texture3dLerp, kernelIndex, "_To", to);
				int num = Mathf.CeilToInt((float)width / 8f);
				int threadGroupsZ = Mathf.CeilToInt((float)width / ((!RuntimeUtilities.isAndroidOpenGL) ? 8f : 2f));
				this.m_Command.DispatchCompute(texture3dLerp, kernelIndex, num, num, threadGroupsZ);
			}
			else
			{
				RenderTextureFormat uncompressedRenderTextureFormat = TextureFormatUtilities.GetUncompressedRenderTextureFormat(to);
				renderTexture = this.Get(uncompressedRenderTextureFormat, to.width, to.height, 1, false);
				PropertySheet propertySheet = this.m_PropertySheets.Get(this.m_Resources.shaders.texture2dLerp);
				propertySheet.properties.SetTexture(ShaderIDs.To, to);
				propertySheet.properties.SetFloat(ShaderIDs.Interp, t);
				this.m_Command.BlitFullscreenTriangle(from, renderTexture, propertySheet, 0, false);
			}
			return renderTexture;
		}

		internal void Clear()
		{
			foreach (RenderTexture current in this.m_Actives)
			{
				RuntimeUtilities.Destroy(current);
			}
			foreach (RenderTexture current2 in this.m_Recycled)
			{
				RuntimeUtilities.Destroy(current2);
			}
			this.m_Actives.Clear();
			this.m_Recycled.Clear();
		}
	}
}

