// Decompile from assembly: DOTween.dll

using System;

internal class <Module>
{
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum AutoPlay
	{
		None,
		AutoPlaySequences,
		AutoPlayTweeners,
		All
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	[Flags]
	public enum AxisConstraint
	{
		None = 0,
		X = 2,
		Y = 4,
		Z = 8,
		W = 16
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening
{
	public struct Color2
	{
		public Color ca;

		public Color cb;

		public Color2(Color ca, Color cb)
		{
			this.ca = ca;
			this.cb = cb;
		}

		public static Color2 operator +(Color2 c1, Color2 c2)
		{
			return new Color2(c1.ca + c2.ca, c1.cb + c2.cb);
		}

		public static Color2 operator -(Color2 c1, Color2 c2)
		{
			return new Color2(c1.ca - c2.ca, c1.cb - c2.cb);
		}

		public static Color2 operator *(Color2 c1, float f)
		{
			return new Color2(c1.ca * f, c1.cb * f);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public delegate void TweenCallback();
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public delegate void TweenCallback<in T>(T value);
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public delegate float EaseFunction(float time, float duration, float overshootOrAmplitude, float period);
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace DG.Tweening
{
	public class DOTween
	{
		private sealed class __c__DisplayClass53_0
		{
			public float v;

			public DOSetter<float> setter;

			internal float _To_b__0()
			{
				return this.v;
			}

			internal void _To_b__1(float x)
			{
				this.v = x;
				this.setter(this.v);
			}
		}

		public static readonly string Version;

		public static bool useSafeMode;

		public static bool showUnityEditorReport;

		public static float timeScale;

		public static bool useSmoothDeltaTime;

		public static float maxSmoothUnscaledTime;

		private static LogBehaviour _logBehaviour;

		public static bool drawGizmos;

		public static UpdateType defaultUpdateType;

		public static bool defaultTimeScaleIndependent;

		public static AutoPlay defaultAutoPlay;

		public static bool defaultAutoKill;

		public static LoopType defaultLoopType;

		public static bool defaultRecyclable;

		public static Ease defaultEaseType;

		public static float defaultEaseOvershootOrAmplitude;

		public static float defaultEasePeriod;

		internal static DOTweenComponent instance;

		internal static bool isUnityEditor;

		internal static bool isDebugBuild;

		internal static int maxActiveTweenersReached;

		internal static int maxActiveSequencesReached;

		internal static readonly List<TweenCallback> GizmosDelegates;

		internal static bool initialized;

		internal static bool isQuitting;

		public static LogBehaviour logBehaviour
		{
			get
			{
				return DOTween._logBehaviour;
			}
			set
			{
				DOTween._logBehaviour = value;
				Debugger.SetLogPriority(DOTween._logBehaviour);
			}
		}

		static DOTween()
		{
			DOTween.Version = "1.1.555";
			DOTween.useSafeMode = true;
			DOTween.showUnityEditorReport = false;
			DOTween.timeScale = 1f;
			DOTween.maxSmoothUnscaledTime = 0.15f;
			DOTween._logBehaviour = LogBehaviour.ErrorsOnly;
			DOTween.drawGizmos = true;
			DOTween.defaultUpdateType = UpdateType.Normal;
			DOTween.defaultTimeScaleIndependent = false;
			DOTween.defaultAutoPlay = AutoPlay.All;
			DOTween.defaultAutoKill = true;
			DOTween.defaultLoopType = LoopType.Restart;
			DOTween.defaultEaseType = Ease.OutQuad;
			DOTween.defaultEaseOvershootOrAmplitude = 1.70158f;
			DOTween.defaultEasePeriod = 0f;
			DOTween.GizmosDelegates = new List<TweenCallback>();
			DOTween.isUnityEditor = Application.isEditor;
		}

		public static IDOTweenInit Init(bool? recycleAllByDefault = null, bool? useSafeMode = null, LogBehaviour? logBehaviour = null)
		{
			if (DOTween.initialized)
			{
				return DOTween.instance;
			}
			if (!Application.isPlaying || DOTween.isQuitting)
			{
				return null;
			}
			return DOTween.Init(Resources.Load("DOTweenSettings") as DOTweenSettings, recycleAllByDefault, useSafeMode, logBehaviour);
		}

		private static void AutoInit()
		{
			DOTween.Init(Resources.Load("DOTweenSettings") as DOTweenSettings, null, null, null);
		}

		private static IDOTweenInit Init(DOTweenSettings settings, bool? recycleAllByDefault, bool? useSafeMode, LogBehaviour? logBehaviour)
		{
			DOTween.initialized = true;
			if (recycleAllByDefault.HasValue)
			{
				DOTween.defaultRecyclable = recycleAllByDefault.Value;
			}
			if (useSafeMode.HasValue)
			{
				DOTween.useSafeMode = useSafeMode.Value;
			}
			if (logBehaviour.HasValue)
			{
				DOTween.logBehaviour = logBehaviour.Value;
			}
			DOTweenComponent.Create();
			if (settings != null)
			{
				if (!useSafeMode.HasValue)
				{
					DOTween.useSafeMode = settings.useSafeMode;
				}
				if (!logBehaviour.HasValue)
				{
					DOTween.logBehaviour = settings.logBehaviour;
				}
				if (!recycleAllByDefault.HasValue)
				{
					DOTween.defaultRecyclable = settings.defaultRecyclable;
				}
				DOTween.timeScale = settings.timeScale;
				DOTween.useSmoothDeltaTime = settings.useSmoothDeltaTime;
				DOTween.maxSmoothUnscaledTime = settings.maxSmoothUnscaledTime;
				DOTween.defaultRecyclable = ((!recycleAllByDefault.HasValue) ? settings.defaultRecyclable : recycleAllByDefault.Value);
				DOTween.showUnityEditorReport = settings.showUnityEditorReport;
				DOTween.drawGizmos = settings.drawGizmos;
				DOTween.defaultAutoPlay = settings.defaultAutoPlay;
				DOTween.defaultUpdateType = settings.defaultUpdateType;
				DOTween.defaultTimeScaleIndependent = settings.defaultTimeScaleIndependent;
				DOTween.defaultEaseType = settings.defaultEaseType;
				DOTween.defaultEaseOvershootOrAmplitude = settings.defaultEaseOvershootOrAmplitude;
				DOTween.defaultEasePeriod = settings.defaultEasePeriod;
				DOTween.defaultAutoKill = settings.defaultAutoKill;
				DOTween.defaultLoopType = settings.defaultLoopType;
			}
			if (Debugger.logPriority >= 2)
			{
				Debugger.Log(string.Concat(new object[]
				{
					"DOTween initialization (useSafeMode: ",
					DOTween.useSafeMode.ToString(),
					", recycling: ",
					DOTween.defaultRecyclable ? "ON" : "OFF",
					", logBehaviour: ",
					DOTween.logBehaviour,
					")"
				}));
			}
			return DOTween.instance;
		}

		public static void SetTweensCapacity(int tweenersCapacity, int sequencesCapacity)
		{
			TweenManager.SetCapacities(tweenersCapacity, sequencesCapacity);
		}

		public static void Clear(bool destroy = false)
		{
			TweenManager.PurgeAll();
			PluginsManager.PurgeAll();
			if (!destroy)
			{
				return;
			}
			DOTween.initialized = false;
			DOTween.useSafeMode = false;
			DOTween.showUnityEditorReport = false;
			DOTween.drawGizmos = true;
			DOTween.timeScale = 1f;
			DOTween.useSmoothDeltaTime = false;
			DOTween.logBehaviour = LogBehaviour.ErrorsOnly;
			DOTween.defaultEaseType = Ease.OutQuad;
			DOTween.defaultEaseOvershootOrAmplitude = 1.70158f;
			DOTween.defaultEasePeriod = 0f;
			DOTween.defaultUpdateType = UpdateType.Normal;
			DOTween.defaultTimeScaleIndependent = false;
			DOTween.defaultAutoPlay = AutoPlay.All;
			DOTween.defaultLoopType = LoopType.Restart;
			DOTween.defaultAutoKill = true;
			DOTween.defaultRecyclable = false;
			DOTween.maxActiveTweenersReached = (DOTween.maxActiveSequencesReached = 0);
			DOTweenComponent.DestroyInstance();
		}

		public static void ClearCachedTweens()
		{
			TweenManager.PurgePools();
		}

		public static int Validate()
		{
			return TweenManager.Validate();
		}

		public static TweenerCore<float, float, FloatOptions> To(DOGetter<float> getter, DOSetter<float> setter, float endValue, float duration)
		{
			return DOTween.ApplyTo<float, float, FloatOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<double, double, NoOptions> To(DOGetter<double> getter, DOSetter<double> setter, double endValue, float duration)
		{
			return DOTween.ApplyTo<double, double, NoOptions>(getter, setter, endValue, duration, null);
		}

		public static Tweener To(DOGetter<int> getter, DOSetter<int> setter, int endValue, float duration)
		{
			return DOTween.ApplyTo<int, int, NoOptions>(getter, setter, endValue, duration, null);
		}

		public static Tweener To(DOGetter<uint> getter, DOSetter<uint> setter, uint endValue, float duration)
		{
			return DOTween.ApplyTo<uint, uint, UintOptions>(getter, setter, endValue, duration, null);
		}

		public static Tweener To(DOGetter<long> getter, DOSetter<long> setter, long endValue, float duration)
		{
			return DOTween.ApplyTo<long, long, NoOptions>(getter, setter, endValue, duration, null);
		}

		public static Tweener To(DOGetter<ulong> getter, DOSetter<ulong> setter, ulong endValue, float duration)
		{
			return DOTween.ApplyTo<ulong, ulong, NoOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<string, string, StringOptions> To(DOGetter<string> getter, DOSetter<string> setter, string endValue, float duration)
		{
			return DOTween.ApplyTo<string, string, StringOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> To(DOGetter<Vector2> getter, DOSetter<Vector2> setter, Vector2 endValue, float duration)
		{
			return DOTween.ApplyTo<Vector2, Vector2, VectorOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> To(DOGetter<Vector3> getter, DOSetter<Vector3> setter, Vector3 endValue, float duration)
		{
			return DOTween.ApplyTo<Vector3, Vector3, VectorOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<Vector4, Vector4, VectorOptions> To(DOGetter<Vector4> getter, DOSetter<Vector4> setter, Vector4 endValue, float duration)
		{
			return DOTween.ApplyTo<Vector4, Vector4, VectorOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<Quaternion, Vector3, QuaternionOptions> To(DOGetter<Quaternion> getter, DOSetter<Quaternion> setter, Vector3 endValue, float duration)
		{
			return DOTween.ApplyTo<Quaternion, Vector3, QuaternionOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<Color, Color, ColorOptions> To(DOGetter<Color> getter, DOSetter<Color> setter, Color endValue, float duration)
		{
			return DOTween.ApplyTo<Color, Color, ColorOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<Rect, Rect, RectOptions> To(DOGetter<Rect> getter, DOSetter<Rect> setter, Rect endValue, float duration)
		{
			return DOTween.ApplyTo<Rect, Rect, RectOptions>(getter, setter, endValue, duration, null);
		}

		public static Tweener To(DOGetter<RectOffset> getter, DOSetter<RectOffset> setter, RectOffset endValue, float duration)
		{
			return DOTween.ApplyTo<RectOffset, RectOffset, NoOptions>(getter, setter, endValue, duration, null);
		}

		public static TweenerCore<T1, T2, TPlugOptions> To<T1, T2, TPlugOptions>(ABSTweenPlugin<T1, T2, TPlugOptions> plugin, DOGetter<T1> getter, DOSetter<T1> setter, T2 endValue, float duration) where TPlugOptions : struct, IPlugOptions
		{
			return DOTween.ApplyTo<T1, T2, TPlugOptions>(getter, setter, endValue, duration, plugin);
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> ToAxis(DOGetter<Vector3> getter, DOSetter<Vector3> setter, float endValue, float duration, AxisConstraint axisConstraint = AxisConstraint.X)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> expr_11 = DOTween.ApplyTo<Vector3, Vector3, VectorOptions>(getter, setter, new Vector3(endValue, endValue, endValue), duration, null);
			expr_11.plugOptions.axisConstraint = axisConstraint;
			return expr_11;
		}

		public static Tweener ToAlpha(DOGetter<Color> getter, DOSetter<Color> setter, float endValue, float duration)
		{
			return DOTween.ApplyTo<Color, Color, ColorOptions>(getter, setter, new Color(0f, 0f, 0f, endValue), duration, null).SetOptions(true);
		}

		public static Tweener To(DOSetter<float> setter, float startValue, float endValue, float duration)
		{
			DOTween.__c__DisplayClass53_0 __c__DisplayClass53_ = new DOTween.__c__DisplayClass53_0();
			__c__DisplayClass53_.setter = setter;
			__c__DisplayClass53_.v = startValue;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass53_._To_b__0), new DOSetter<float>(__c__DisplayClass53_._To_b__1), endValue, duration).NoFrom<float, float, FloatOptions>();
		}

		public static TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> Punch(DOGetter<Vector3> getter, DOSetter<Vector3> setter, Vector3 direction, float duration, int vibrato = 10, float elasticity = 1f)
		{
			if (elasticity > 1f)
			{
				elasticity = 1f;
			}
			else if (elasticity < 0f)
			{
				elasticity = 0f;
			}
			float num = direction.magnitude;
			int num2 = (int)((float)vibrato * duration);
			if (num2 < 2)
			{
				num2 = 2;
			}
			float num3 = num / (float)num2;
			float[] array = new float[num2];
			float num4 = 0f;
			for (int i = 0; i < num2; i++)
			{
				float num5 = (float)(i + 1) / (float)num2;
				float num6 = duration * num5;
				num4 += num6;
				array[i] = num6;
			}
			float num7 = duration / num4;
			for (int j = 0; j < num2; j++)
			{
				array[j] *= num7;
			}
			Vector3[] array2 = new Vector3[num2];
			for (int k = 0; k < num2; k++)
			{
				if (k < num2 - 1)
				{
					if (k == 0)
					{
						array2[k] = direction;
					}
					else if (k % 2 != 0)
					{
						array2[k] = -Vector3.ClampMagnitude(direction, num * elasticity);
					}
					else
					{
						array2[k] = Vector3.ClampMagnitude(direction, num);
					}
					num -= num3;
				}
				else
				{
					array2[k] = Vector3.zero;
				}
			}
			return DOTween.ToArray(getter, setter, array2, array).NoFrom<Vector3, Vector3[], Vector3ArrayOptions>().SetSpecialStartupMode(SpecialStartupMode.SetPunch);
		}

		public static TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> Shake(DOGetter<Vector3> getter, DOSetter<Vector3> setter, float duration, float strength = 3f, int vibrato = 10, float randomness = 90f, bool ignoreZAxis = true, bool fadeOut = true)
		{
			return DOTween.Shake(getter, setter, duration, new Vector3(strength, strength, strength), vibrato, randomness, ignoreZAxis, false, fadeOut);
		}

		public static TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> Shake(DOGetter<Vector3> getter, DOSetter<Vector3> setter, float duration, Vector3 strength, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			return DOTween.Shake(getter, setter, duration, strength, vibrato, randomness, false, true, fadeOut);
		}

		private static TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> Shake(DOGetter<Vector3> getter, DOSetter<Vector3> setter, float duration, Vector3 strength, int vibrato, float randomness, bool ignoreZAxis, bool vectorBased, bool fadeOut)
		{
			float num = vectorBased ? strength.magnitude : strength.x;
			int num2 = (int)((float)vibrato * duration);
			if (num2 < 2)
			{
				num2 = 2;
			}
			float num3 = num / (float)num2;
			float[] array = new float[num2];
			float num4 = 0f;
			for (int i = 0; i < num2; i++)
			{
				float num5 = (float)(i + 1) / (float)num2;
				float num6 = fadeOut ? (duration * num5) : (duration / (float)num2);
				num4 += num6;
				array[i] = num6;
			}
			float num7 = duration / num4;
			for (int j = 0; j < num2; j++)
			{
				array[j] *= num7;
			}
			float num8 = Random.Range(0f, 360f);
			Vector3[] array2 = new Vector3[num2];
			for (int k = 0; k < num2; k++)
			{
				if (k < num2 - 1)
				{
					if (k > 0)
					{
						num8 = num8 - 180f + Random.Range(-randomness, randomness);
					}
					if (vectorBased)
					{
						Vector3 vector = Quaternion.AngleAxis(Random.Range(-randomness, randomness), Vector3.up) * Utils.Vector3FromAngle(num8, num);
						vector.x = Vector3.ClampMagnitude(vector, strength.x).x;
						vector.y = Vector3.ClampMagnitude(vector, strength.y).y;
						vector.z = Vector3.ClampMagnitude(vector, strength.z).z;
						array2[k] = vector;
						if (fadeOut)
						{
							num -= num3;
						}
						strength = Vector3.ClampMagnitude(strength, num);
					}
					else
					{
						if (ignoreZAxis)
						{
							array2[k] = Utils.Vector3FromAngle(num8, num);
						}
						else
						{
							Quaternion rotation = Quaternion.AngleAxis(Random.Range(-randomness, randomness), Vector3.up);
							array2[k] = rotation * Utils.Vector3FromAngle(num8, num);
						}
						if (fadeOut)
						{
							num -= num3;
						}
					}
				}
				else
				{
					array2[k] = Vector3.zero;
				}
			}
			return DOTween.ToArray(getter, setter, array2, array).NoFrom<Vector3, Vector3[], Vector3ArrayOptions>().SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> ToArray(DOGetter<Vector3> getter, DOSetter<Vector3> setter, Vector3[] endValues, float[] durations)
		{
			int num = durations.Length;
			if (num != endValues.Length)
			{
				Debugger.LogError("To Vector3 array tween: endValues and durations arrays must have the same length");
				return null;
			}
			Vector3[] array = new Vector3[num];
			float[] array2 = new float[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = endValues[i];
				array2[i] = durations[i];
			}
			float num2 = 0f;
			for (int j = 0; j < num; j++)
			{
				num2 += array2[j];
			}
			TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> expr_78 = DOTween.ApplyTo<Vector3, Vector3[], Vector3ArrayOptions>(getter, setter, array, num2, null).NoFrom<Vector3, Vector3[], Vector3ArrayOptions>();
			expr_78.plugOptions.durations = array2;
			return expr_78;
		}

		internal static TweenerCore<Color2, Color2, ColorOptions> To(DOGetter<Color2> getter, DOSetter<Color2> setter, Color2 endValue, float duration)
		{
			return DOTween.ApplyTo<Color2, Color2, ColorOptions>(getter, setter, endValue, duration, null);
		}

		public static Sequence Sequence()
		{
			DOTween.InitCheck();
			Sequence expr_0A = TweenManager.GetSequence();
			DG.Tweening.Sequence.Setup(expr_0A);
			return expr_0A;
		}

		public static int CompleteAll(bool withCallbacks = false)
		{
			return TweenManager.FilteredOperation(OperationType.Complete, FilterType.All, null, false, (float)(withCallbacks ? 1 : 0), null, null);
		}

		public static int Complete(object targetOrId, bool withCallbacks = false)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Complete, FilterType.TargetOrId, targetOrId, false, (float)(withCallbacks ? 1 : 0), null, null);
		}

		internal static int CompleteAndReturnKilledTot()
		{
			return TweenManager.FilteredOperation(OperationType.Complete, FilterType.All, null, true, 0f, null, null);
		}

		internal static int CompleteAndReturnKilledTot(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Complete, FilterType.TargetOrId, targetOrId, true, 0f, null, null);
		}

		internal static int CompleteAndReturnKilledTotExceptFor(params object[] excludeTargetsOrIds)
		{
			return TweenManager.FilteredOperation(OperationType.Complete, FilterType.AllExceptTargetsOrIds, null, true, 0f, null, excludeTargetsOrIds);
		}

		public static int FlipAll()
		{
			return TweenManager.FilteredOperation(OperationType.Flip, FilterType.All, null, false, 0f, null, null);
		}

		public static int Flip(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Flip, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int GotoAll(float to, bool andPlay = false)
		{
			return TweenManager.FilteredOperation(OperationType.Goto, FilterType.All, null, andPlay, to, null, null);
		}

		public static int Goto(object targetOrId, float to, bool andPlay = false)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Goto, FilterType.TargetOrId, targetOrId, andPlay, to, null, null);
		}

		public static int KillAll(bool complete = false)
		{
			return (complete ? DOTween.CompleteAndReturnKilledTot() : 0) + TweenManager.DespawnAll();
		}

		public static int KillAll(bool complete, params object[] idsOrTargetsToExclude)
		{
			if (idsOrTargetsToExclude == null)
			{
				return (complete ? DOTween.CompleteAndReturnKilledTot() : 0) + TweenManager.DespawnAll();
			}
			return (complete ? DOTween.CompleteAndReturnKilledTotExceptFor(idsOrTargetsToExclude) : 0) + TweenManager.FilteredOperation(OperationType.Despawn, FilterType.AllExceptTargetsOrIds, null, false, 0f, null, idsOrTargetsToExclude);
		}

		public static int Kill(object targetOrId, bool complete = false)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return (complete ? DOTween.CompleteAndReturnKilledTot(targetOrId) : 0) + TweenManager.FilteredOperation(OperationType.Despawn, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int PauseAll()
		{
			return TweenManager.FilteredOperation(OperationType.Pause, FilterType.All, null, false, 0f, null, null);
		}

		public static int Pause(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Pause, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int PlayAll()
		{
			return TweenManager.FilteredOperation(OperationType.Play, FilterType.All, null, false, 0f, null, null);
		}

		public static int Play(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Play, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int Play(object target, object id)
		{
			if (target == null || id == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Play, FilterType.TargetAndId, id, false, 0f, target, null);
		}

		public static int PlayBackwardsAll()
		{
			return TweenManager.FilteredOperation(OperationType.PlayBackwards, FilterType.All, null, false, 0f, null, null);
		}

		public static int PlayBackwards(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.PlayBackwards, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int PlayBackwards(object target, object id)
		{
			if (target == null || id == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.PlayBackwards, FilterType.TargetAndId, id, false, 0f, target, null);
		}

		public static int PlayForwardAll()
		{
			return TweenManager.FilteredOperation(OperationType.PlayForward, FilterType.All, null, false, 0f, null, null);
		}

		public static int PlayForward(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.PlayForward, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int PlayForward(object target, object id)
		{
			if (target == null || id == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.PlayForward, FilterType.TargetAndId, id, false, 0f, target, null);
		}

		public static int RestartAll(bool includeDelay = true)
		{
			return TweenManager.FilteredOperation(OperationType.Restart, FilterType.All, null, includeDelay, 0f, null, null);
		}

		public static int Restart(object targetOrId, bool includeDelay = true)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Restart, FilterType.TargetOrId, targetOrId, includeDelay, 0f, null, null);
		}

		public static int Restart(object target, object id, bool includeDelay = true)
		{
			if (target == null || id == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Restart, FilterType.TargetAndId, id, includeDelay, 0f, target, null);
		}

		public static int RewindAll(bool includeDelay = true)
		{
			return TweenManager.FilteredOperation(OperationType.Rewind, FilterType.All, null, includeDelay, 0f, null, null);
		}

		public static int Rewind(object targetOrId, bool includeDelay = true)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.Rewind, FilterType.TargetOrId, targetOrId, includeDelay, 0f, null, null);
		}

		public static int SmoothRewindAll()
		{
			return TweenManager.FilteredOperation(OperationType.SmoothRewind, FilterType.All, null, false, 0f, null, null);
		}

		public static int SmoothRewind(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.SmoothRewind, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static int TogglePauseAll()
		{
			return TweenManager.FilteredOperation(OperationType.TogglePause, FilterType.All, null, false, 0f, null, null);
		}

		public static int TogglePause(object targetOrId)
		{
			if (targetOrId == null)
			{
				return 0;
			}
			return TweenManager.FilteredOperation(OperationType.TogglePause, FilterType.TargetOrId, targetOrId, false, 0f, null, null);
		}

		public static bool IsTweening(object targetOrId, bool alsoCheckIfIsPlaying = false)
		{
			return TweenManager.FilteredOperation(OperationType.IsTweening, FilterType.TargetOrId, targetOrId, alsoCheckIfIsPlaying, 0f, null, null) > 0;
		}

		public static int TotalPlayingTweens()
		{
			return TweenManager.TotalPlayingTweens();
		}

		public static List<Tween> PlayingTweens()
		{
			return TweenManager.GetActiveTweens(true);
		}

		public static List<Tween> PausedTweens()
		{
			return TweenManager.GetActiveTweens(false);
		}

		public static List<Tween> TweensById(object id, bool playingOnly = false)
		{
			if (id == null)
			{
				return null;
			}
			return TweenManager.GetTweensById(id, playingOnly);
		}

		public static List<Tween> TweensByTarget(object target, bool playingOnly = false)
		{
			return TweenManager.GetTweensByTarget(target, playingOnly);
		}

		private static void InitCheck()
		{
			if (DOTween.initialized || !Application.isPlaying || DOTween.isQuitting)
			{
				return;
			}
			DOTween.AutoInit();
		}

		private static TweenerCore<T1, T2, TPlugOptions> ApplyTo<T1, T2, TPlugOptions>(DOGetter<T1> getter, DOSetter<T1> setter, T2 endValue, float duration, ABSTweenPlugin<T1, T2, TPlugOptions> plugin = null) where TPlugOptions : struct, IPlugOptions
		{
			DOTween.InitCheck();
			TweenerCore<T1, T2, TPlugOptions> tweener = TweenManager.GetTweener<T1, T2, TPlugOptions>();
			if (!Tweener.Setup<T1, T2, TPlugOptions>(tweener, getter, setter, endValue, duration, plugin))
			{
				TweenManager.Despawn(tweener, true);
				return null;
			}
			return tweener;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Plugins.Options;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace DG.Tweening
{
	public static class DOVirtual
	{
		private sealed class __c__DisplayClass0_0
		{
			public float val;

			public TweenCallback<float> onVirtualUpdate;

			internal float _Float_b__0()
			{
				return this.val;
			}

			internal void _Float_b__1(float x)
			{
				this.val = x;
			}

			internal void _Float_b__2()
			{
				this.onVirtualUpdate(this.val);
			}
		}

		public static Tweener Float(float from, float to, float duration, TweenCallback<float> onVirtualUpdate)
		{
			DOVirtual.__c__DisplayClass0_0 __c__DisplayClass0_ = new DOVirtual.__c__DisplayClass0_0();
			__c__DisplayClass0_.onVirtualUpdate = onVirtualUpdate;
			__c__DisplayClass0_.val = from;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass0_._Float_b__0), new DOSetter<float>(__c__DisplayClass0_._Float_b__1), to, duration).OnUpdate(new TweenCallback(__c__DisplayClass0_._Float_b__2));
		}

		public static float EasedValue(float from, float to, float lifetimePercentage, Ease easeType)
		{
			return from + (to - from) * EaseManager.Evaluate(easeType, null, lifetimePercentage, 1f, DOTween.defaultEaseOvershootOrAmplitude, DOTween.defaultEasePeriod);
		}

		public static float EasedValue(float from, float to, float lifetimePercentage, Ease easeType, float overshoot)
		{
			return from + (to - from) * EaseManager.Evaluate(easeType, null, lifetimePercentage, 1f, overshoot, DOTween.defaultEasePeriod);
		}

		public static float EasedValue(float from, float to, float lifetimePercentage, Ease easeType, float amplitude, float period)
		{
			return from + (to - from) * EaseManager.Evaluate(easeType, null, lifetimePercentage, 1f, amplitude, period);
		}

		public static float EasedValue(float from, float to, float lifetimePercentage, AnimationCurve easeCurve)
		{
			return from + (to - from) * EaseManager.Evaluate(Ease.INTERNAL_Custom, new EaseFunction(new EaseCurve(easeCurve).Evaluate), lifetimePercentage, 1f, DOTween.defaultEaseOvershootOrAmplitude, DOTween.defaultEasePeriod);
		}

		public static Tween DelayedCall(float delay, TweenCallback callback, bool ignoreTimeScale = true)
		{
			return DOTween.Sequence().AppendInterval(delay).OnStepComplete(callback).SetUpdate(UpdateType.Normal, ignoreTimeScale).SetAutoKill(true);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum Ease
	{
		Unset,
		Linear,
		InSine,
		OutSine,
		InOutSine,
		InQuad,
		OutQuad,
		InOutQuad,
		InCubic,
		OutCubic,
		InOutCubic,
		InQuart,
		OutQuart,
		InOutQuart,
		InQuint,
		OutQuint,
		InOutQuint,
		InExpo,
		OutExpo,
		InOutExpo,
		InCirc,
		OutCirc,
		InOutCirc,
		InElastic,
		OutElastic,
		InOutElastic,
		InBack,
		OutBack,
		InOutBack,
		InBounce,
		OutBounce,
		InOutBounce,
		Flash,
		InFlash,
		OutFlash,
		InOutFlash,
		INTERNAL_Zero,
		INTERNAL_Custom
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core.Easing;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace DG.Tweening
{
	public class EaseFactory
	{
		private sealed class __c__DisplayClass2_0
		{
			public float motionDelay;

			public EaseFunction customEase;

			internal float _StopMotion_b__0(float time, float duration, float overshootOrAmplitude, float period)
			{
				float time2 = (time < duration) ? (time - time % this.motionDelay) : time;
				return this.customEase(time2, duration, overshootOrAmplitude, period);
			}
		}

		public static EaseFunction StopMotion(int motionFps, Ease? ease = null)
		{
			EaseFunction customEase = EaseManager.ToEaseFunction((!ease.HasValue) ? DOTween.defaultEaseType : ease.Value);
			return EaseFactory.StopMotion(motionFps, customEase);
		}

		public static EaseFunction StopMotion(int motionFps, AnimationCurve animCurve)
		{
			return EaseFactory.StopMotion(motionFps, new EaseFunction(new EaseCurve(animCurve).Evaluate));
		}

		public static EaseFunction StopMotion(int motionFps, EaseFunction customEase)
		{
			EaseFactory.__c__DisplayClass2_0 expr_05 = new EaseFactory.__c__DisplayClass2_0();
			expr_05.customEase = customEase;
			expr_05.motionDelay = 1f / (float)motionFps;
			return new EaseFunction(expr_05._StopMotion_b__0);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public interface IDOTweenInit
	{
		IDOTweenInit SetCapacity(int tweenersCapacity, int sequencesCapacity);
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum PathMode
	{
		Ignore,
		Full3D,
		TopDown2D,
		Sidescroller2D
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum PathType
	{
		Linear,
		CatmullRom
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum RotateMode
	{
		Fast,
		FastBeyond360,
		WorldAxisAdd,
		LocalAxisAdd
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum ScrambleMode
	{
		None,
		All,
		Uppercase,
		Lowercase,
		Numerals,
		Custom
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening
{
	public static class TweenExtensions
	{
		public static void Complete(this Tween t)
		{
			t.Complete(false);
		}

		public static void Complete(this Tween t, bool withCallbacks)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.Complete(t, true, withCallbacks ? UpdateMode.Update : UpdateMode.Goto);
		}

		public static void Flip(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.Flip(t);
		}

		public static void ForceInit(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.ForceInit(t, false);
		}

		public static void Goto(this Tween t, float to, bool andPlay = false)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			if (to < 0f)
			{
				to = 0f;
			}
			TweenManager.Goto(t, to, andPlay, UpdateMode.Goto);
		}

		public static void Kill(this Tween t, bool complete = false)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			if (complete)
			{
				TweenManager.Complete(t, true, UpdateMode.Goto);
				if (t.autoKill && t.loops >= 0)
				{
					return;
				}
			}
			if (TweenManager.isUpdateLoop)
			{
				t.active = false;
				return;
			}
			TweenManager.Despawn(t, true);
		}

		public static T Pause<T>(this T t) where T : Tween
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return t;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return t;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return t;
			}
			TweenManager.Pause(t);
			return t;
		}

		public static T Play<T>(this T t) where T : Tween
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return t;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return t;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return t;
			}
			TweenManager.Play(t);
			return t;
		}

		public static void PlayBackwards(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.PlayBackwards(t);
		}

		public static void PlayForward(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.PlayForward(t);
		}

		public static void Restart(this Tween t, bool includeDelay = true)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.Restart(t, includeDelay);
		}

		public static void Rewind(this Tween t, bool includeDelay = true)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.Rewind(t, includeDelay);
		}

		public static void SmoothRewind(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.SmoothRewind(t);
		}

		public static void TogglePause(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenManager.TogglePause(t);
		}

		public static void GotoWaypoint(this Tween t, int waypointIndex, bool andPlay = false)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return;
			}
			TweenerCore<Vector3, Path, PathOptions> tweenerCore = t as TweenerCore<Vector3, Path, PathOptions>;
			if (tweenerCore == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNonPathTween(t);
				}
				return;
			}
			if (!t.startupDone)
			{
				TweenManager.ForceInit(t, false);
			}
			if (waypointIndex < 0)
			{
				waypointIndex = 0;
			}
			else if (waypointIndex > tweenerCore.changeValue.wps.Length - 1)
			{
				waypointIndex = tweenerCore.changeValue.wps.Length - 1;
			}
			float num = 0f;
			for (int i = 0; i < waypointIndex + 1; i++)
			{
				num += tweenerCore.changeValue.wpLengths[i];
			}
			float num2 = num / tweenerCore.changeValue.length;
			if (t.loopType == LoopType.Yoyo && ((t.position < t.duration) ? (t.completedLoops % 2 != 0) : (t.completedLoops % 2 == 0)))
			{
				num2 = 1f - num2;
			}
			float to = (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops) * t.duration + num2 * t.duration;
			TweenManager.Goto(t, to, andPlay, UpdateMode.Goto);
		}

		public static YieldInstruction WaitForCompletion(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return DOTween.instance.StartCoroutine(DOTween.instance.WaitForCompletion(t));
		}

		public static YieldInstruction WaitForRewind(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return DOTween.instance.StartCoroutine(DOTween.instance.WaitForRewind(t));
		}

		public static YieldInstruction WaitForKill(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return DOTween.instance.StartCoroutine(DOTween.instance.WaitForKill(t));
		}

		public static YieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return DOTween.instance.StartCoroutine(DOTween.instance.WaitForElapsedLoops(t, elapsedLoops));
		}

		public static YieldInstruction WaitForPosition(this Tween t, float position)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return DOTween.instance.StartCoroutine(DOTween.instance.WaitForPosition(t, position));
		}

		public static Coroutine WaitForStart(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return DOTween.instance.StartCoroutine(DOTween.instance.WaitForStart(t));
		}

		public static int CompletedLoops(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0;
			}
			return t.completedLoops;
		}

		public static float Delay(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0f;
			}
			return t.delay;
		}

		public static float Duration(this Tween t, bool includeLoops = true)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0f;
			}
			if (!includeLoops)
			{
				return t.duration;
			}
			if (t.loops != -1)
			{
				return t.duration * (float)t.loops;
			}
			return float.PositiveInfinity;
		}

		public static float Elapsed(this Tween t, bool includeLoops = true)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0f;
			}
			if (includeLoops)
			{
				return (float)((t.position >= t.duration) ? (t.completedLoops - 1) : t.completedLoops) * t.duration + t.position;
			}
			return t.position;
		}

		public static float ElapsedPercentage(this Tween t, bool includeLoops = true)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0f;
			}
			if (includeLoops)
			{
				return ((float)((t.position >= t.duration) ? (t.completedLoops - 1) : t.completedLoops) * t.duration + t.position) / t.fullDuration;
			}
			return t.position / t.duration;
		}

		public static float ElapsedDirectionalPercentage(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0f;
			}
			float num = t.position / t.duration;
			if (t.completedLoops <= 0 || t.loopType != LoopType.Yoyo || ((t.isComplete || t.completedLoops % 2 == 0) && (!t.isComplete || t.completedLoops % 2 != 0)))
			{
				return num;
			}
			return 1f - num;
		}

		public static bool IsActive(this Tween t)
		{
			return t.active;
		}

		public static bool IsBackwards(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return false;
			}
			return t.isBackwards;
		}

		public static bool IsComplete(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return false;
			}
			return t.isComplete;
		}

		public static bool IsInitialized(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return false;
			}
			return t.startupDone;
		}

		public static bool IsPlaying(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return false;
			}
			return t.isPlaying;
		}

		public static int Loops(this Tween t)
		{
			if (!t.active)
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogInvalidTween(t);
				}
				return 0;
			}
			return t.loops;
		}

		public static Vector3 PathGetPoint(this Tween t, float pathPercentage)
		{
			if (pathPercentage > 1f)
			{
				pathPercentage = 1f;
			}
			else if (pathPercentage < 0f)
			{
				pathPercentage = 0f;
			}
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return Vector3.zero;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return Vector3.zero;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return Vector3.zero;
			}
			TweenerCore<Vector3, Path, PathOptions> tweenerCore = t as TweenerCore<Vector3, Path, PathOptions>;
			if (tweenerCore == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNonPathTween(t);
				}
				return Vector3.zero;
			}
			if (!tweenerCore.endValue.isFinalized)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogWarning("The path is not finalized yet");
				}
				return Vector3.zero;
			}
			return tweenerCore.endValue.GetPoint(pathPercentage, true);
		}

		public static Vector3[] PathGetDrawPoints(this Tween t, int subdivisionsXSegment = 10)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return null;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return null;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return null;
			}
			TweenerCore<Vector3, Path, PathOptions> tweenerCore = t as TweenerCore<Vector3, Path, PathOptions>;
			if (tweenerCore == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNonPathTween(t);
				}
				return null;
			}
			if (!tweenerCore.endValue.isFinalized)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogWarning("The path is not finalized yet");
				}
				return null;
			}
			return Path.GetDrawPoints(tweenerCore.endValue, subdivisionsXSegment);
		}

		public static float PathLength(this Tween t)
		{
			if (t == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNullTween(t);
				}
				return -1f;
			}
			if (!t.active)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogInvalidTween(t);
				}
				return -1f;
			}
			if (t.isSequenced)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNestedTween(t);
				}
				return -1f;
			}
			TweenerCore<Vector3, Path, PathOptions> tweenerCore = t as TweenerCore<Vector3, Path, PathOptions>;
			if (tweenerCore == null)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogNonPathTween(t);
				}
				return -1f;
			}
			if (!tweenerCore.endValue.isFinalized)
			{
				if (Debugger.logPriority > 1)
				{
					Debugger.LogWarning("The path is not finalized yet");
				}
				return -1f;
			}
			return tweenerCore.endValue.length;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum LoopType
	{
		Restart,
		Yoyo,
		Incremental
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using System;
using System.Collections.Generic;

namespace DG.Tweening
{
	public sealed class Sequence : Tween
	{
		internal readonly List<Tween> sequencedTweens = new List<Tween>();

		private readonly List<ABSSequentiable> _sequencedObjs = new List<ABSSequentiable>();

		internal float lastTweenInsertTime;

		internal Sequence()
		{
			this.tweenType = TweenType.Sequence;
			this.Reset();
		}

		internal static Sequence DoPrepend(Sequence inSequence, Tween t)
		{
			if (t.loops == -1)
			{
				t.loops = 1;
			}
			float num = t.delay + t.duration * (float)t.loops;
			inSequence.duration += num;
			int count = inSequence._sequencedObjs.Count;
			for (int i = 0; i < count; i++)
			{
				ABSSequentiable expr_50 = inSequence._sequencedObjs[i];
				expr_50.sequencedPosition += num;
				expr_50.sequencedEndPosition += num;
			}
			return Sequence.DoInsert(inSequence, t, 0f);
		}

		internal static Sequence DoInsert(Sequence inSequence, Tween t, float atPosition)
		{
			TweenManager.AddActiveTweenToSequence(t);
			atPosition += t.delay;
			inSequence.lastTweenInsertTime = atPosition;
			t.isSequenced = (t.creationLocked = true);
			t.sequenceParent = inSequence;
			if (t.loops == -1)
			{
				t.loops = 1;
			}
			float num = t.duration * (float)t.loops;
			t.autoKill = false;
			t.delay = (t.elapsedDelay = 0f);
			t.delayComplete = true;
			t.isSpeedBased = false;
			t.sequencedPosition = atPosition;
			t.sequencedEndPosition = atPosition + num;
			if (t.sequencedEndPosition > inSequence.duration)
			{
				inSequence.duration = t.sequencedEndPosition;
			}
			inSequence._sequencedObjs.Add(t);
			inSequence.sequencedTweens.Add(t);
			return inSequence;
		}

		internal static Sequence DoAppendInterval(Sequence inSequence, float interval)
		{
			inSequence.lastTweenInsertTime = inSequence.duration;
			inSequence.duration += interval;
			return inSequence;
		}

		internal static Sequence DoPrependInterval(Sequence inSequence, float interval)
		{
			inSequence.lastTweenInsertTime = 0f;
			inSequence.duration += interval;
			int count = inSequence._sequencedObjs.Count;
			for (int i = 0; i < count; i++)
			{
				ABSSequentiable expr_35 = inSequence._sequencedObjs[i];
				expr_35.sequencedPosition += interval;
				expr_35.sequencedEndPosition += interval;
			}
			return inSequence;
		}

		internal static Sequence DoInsertCallback(Sequence inSequence, TweenCallback callback, float atPosition)
		{
			inSequence.lastTweenInsertTime = atPosition;
			SequenceCallback sequenceCallback = new SequenceCallback(atPosition, callback);
			ABSSequentiable arg_1A_0 = sequenceCallback;
			sequenceCallback.sequencedEndPosition = atPosition;
			arg_1A_0.sequencedPosition = atPosition;
			inSequence._sequencedObjs.Add(sequenceCallback);
			if (inSequence.duration < atPosition)
			{
				inSequence.duration = atPosition;
			}
			return inSequence;
		}

		internal override void Reset()
		{
			base.Reset();
			this.sequencedTweens.Clear();
			this._sequencedObjs.Clear();
			this.lastTweenInsertTime = 0f;
		}

		internal override bool Validate()
		{
			int count = this.sequencedTweens.Count;
			for (int i = 0; i < count; i++)
			{
				if (!this.sequencedTweens[i].Validate())
				{
					return false;
				}
			}
			return true;
		}

		internal override bool Startup()
		{
			return Sequence.DoStartup(this);
		}

		internal override bool ApplyTween(float prevPosition, int prevCompletedLoops, int newCompletedSteps, bool useInversePosition, UpdateMode updateMode, UpdateNotice updateNotice)
		{
			return Sequence.DoApplyTween(this, prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode);
		}

		internal static void Setup(Sequence s)
		{
			s.autoKill = DOTween.defaultAutoKill;
			s.isRecyclable = DOTween.defaultRecyclable;
			s.isPlaying = (DOTween.defaultAutoPlay == AutoPlay.All || DOTween.defaultAutoPlay == AutoPlay.AutoPlaySequences);
			s.loopType = DOTween.defaultLoopType;
			s.easeType = Ease.Linear;
			s.easeOvershootOrAmplitude = DOTween.defaultEaseOvershootOrAmplitude;
			s.easePeriod = DOTween.defaultEasePeriod;
		}

		internal static bool DoStartup(Sequence s)
		{
			if (s.sequencedTweens.Count == 0 && s._sequencedObjs.Count == 0 && s.onComplete == null && s.onKill == null && s.onPause == null && s.onPlay == null && s.onRewind == null && s.onStart == null && s.onStepComplete == null && s.onUpdate == null)
			{
				return false;
			}
			s.startupDone = true;
			s.fullDuration = ((s.loops > -1) ? (s.duration * (float)s.loops) : float.PositiveInfinity);
			s._sequencedObjs.Sort(new Comparison<ABSSequentiable>(Sequence.SortSequencedObjs));
			if (s.isRelative)
			{
				int count = s.sequencedTweens.Count;
				for (int i = 0; i < count; i++)
				{
					Tween arg_C2_0 = s.sequencedTweens[i];
					if (!s.isBlendable)
					{
						s.sequencedTweens[i].isRelative = true;
					}
				}
			}
			return true;
		}

		internal static bool DoApplyTween(Sequence s, float prevPosition, int prevCompletedLoops, int newCompletedSteps, bool useInversePosition, UpdateMode updateMode)
		{
			float num = prevPosition;
			float num2 = s.position;
			if (s.easeType != Ease.Linear)
			{
				num = s.duration * EaseManager.Evaluate(s.easeType, s.customEase, num, s.duration, s.easeOvershootOrAmplitude, s.easePeriod);
				num2 = s.duration * EaseManager.Evaluate(s.easeType, s.customEase, num2, s.duration, s.easeOvershootOrAmplitude, s.easePeriod);
			}
			float num3 = 0f;
			bool flag = s.loopType == LoopType.Yoyo && ((num < s.duration) ? (prevCompletedLoops % 2 != 0) : (prevCompletedLoops % 2 == 0));
			if (s.isBackwards)
			{
				flag = !flag;
			}
			float num5;
			if (newCompletedSteps > 0)
			{
				int completedLoops = s.completedLoops;
				float position = s.position;
				int num4 = newCompletedSteps;
				int i = 0;
				num5 = num;
				if (updateMode == UpdateMode.Update)
				{
					while (i < num4)
					{
						if (i > 0)
						{
							num5 = num3;
						}
						else if (flag && !s.isBackwards)
						{
							num5 = s.duration - num5;
						}
						num3 = (flag ? 0f : s.duration);
						if (Sequence.ApplyInternalCycle(s, num5, num3, updateMode, useInversePosition, flag, true))
						{
							return true;
						}
						i++;
						if (s.loopType == LoopType.Yoyo)
						{
							flag = !flag;
						}
					}
					if (completedLoops != s.completedLoops || Math.Abs(position - s.position) > 1.401298E-45f)
					{
						return !s.active;
					}
				}
				else
				{
					if (s.loopType == LoopType.Yoyo && newCompletedSteps % 2 != 0)
					{
						flag = !flag;
						num = s.duration - num;
					}
					newCompletedSteps = 0;
				}
			}
			if (newCompletedSteps == 1 && s.isComplete)
			{
				return false;
			}
			if (newCompletedSteps > 0 && !s.isComplete)
			{
				num5 = (useInversePosition ? s.duration : 0f);
				if (s.loopType == LoopType.Restart && num3 > 0f)
				{
					Sequence.ApplyInternalCycle(s, s.duration, 0f, UpdateMode.Goto, false, false, false);
				}
			}
			else
			{
				num5 = (useInversePosition ? (s.duration - num) : num);
			}
			return Sequence.ApplyInternalCycle(s, num5, useInversePosition ? (s.duration - num2) : num2, updateMode, useInversePosition, flag, false);
		}

		private static bool ApplyInternalCycle(Sequence s, float fromPos, float toPos, UpdateMode updateMode, bool useInverse, bool prevPosIsInverse, bool multiCycleStep = false)
		{
			if (toPos < fromPos)
			{
				for (int i = s._sequencedObjs.Count - 1; i > -1; i--)
				{
					if (!s.active)
					{
						return true;
					}
					ABSSequentiable aBSSequentiable = s._sequencedObjs[i];
					if (aBSSequentiable.sequencedEndPosition >= toPos && aBSSequentiable.sequencedPosition <= fromPos)
					{
						if (aBSSequentiable.tweenType == TweenType.Callback)
						{
							if (updateMode == UpdateMode.Update & prevPosIsInverse)
							{
								Tween.OnTweenCallback(aBSSequentiable.onStart);
							}
						}
						else
						{
							float num = toPos - aBSSequentiable.sequencedPosition;
							if (num < 0f)
							{
								num = 0f;
							}
							Tween tween = (Tween)aBSSequentiable;
							if (tween.startupDone)
							{
								tween.isBackwards = true;
								if (TweenManager.Goto(tween, num, false, updateMode))
								{
									return true;
								}
								if (multiCycleStep && tween.tweenType == TweenType.Sequence)
								{
									if (s.position <= 0f && s.completedLoops == 0)
									{
										tween.position = 0f;
									}
									else
									{
										bool flag = s.completedLoops == 0 || (s.isBackwards && (s.completedLoops < s.loops || s.loops == -1));
										if (tween.isBackwards)
										{
											flag = !flag;
										}
										if (useInverse)
										{
											flag = !flag;
										}
										if (s.isBackwards && !useInverse && !prevPosIsInverse)
										{
											flag = !flag;
										}
										tween.position = (flag ? 0f : tween.duration);
									}
								}
							}
						}
					}
				}
			}
			else
			{
				int count = s._sequencedObjs.Count;
				for (int j = 0; j < count; j++)
				{
					if (!s.active)
					{
						return true;
					}
					ABSSequentiable aBSSequentiable2 = s._sequencedObjs[j];
					if (aBSSequentiable2.sequencedPosition <= toPos && aBSSequentiable2.sequencedEndPosition >= fromPos)
					{
						if (aBSSequentiable2.tweenType == TweenType.Callback)
						{
							if (updateMode == UpdateMode.Update && ((!s.isBackwards && !useInverse && !prevPosIsInverse) || ((s.isBackwards & useInverse) && !prevPosIsInverse)))
							{
								Tween.OnTweenCallback(aBSSequentiable2.onStart);
							}
						}
						else
						{
							float num2 = toPos - aBSSequentiable2.sequencedPosition;
							if (num2 < 0f)
							{
								num2 = 0f;
							}
							Tween tween2 = (Tween)aBSSequentiable2;
							if (toPos >= aBSSequentiable2.sequencedEndPosition)
							{
								if (!tween2.startupDone)
								{
									TweenManager.ForceInit(tween2, true);
								}
								if (num2 < tween2.fullDuration)
								{
									num2 = tween2.fullDuration;
								}
							}
							tween2.isBackwards = false;
							if (TweenManager.Goto(tween2, num2, false, updateMode))
							{
								return true;
							}
							if (multiCycleStep && tween2.tweenType == TweenType.Sequence)
							{
								if (s.position <= 0f && s.completedLoops == 0)
								{
									tween2.position = 0f;
								}
								else
								{
									bool flag2 = s.completedLoops == 0 || (!s.isBackwards && (s.completedLoops < s.loops || s.loops == -1));
									if (tween2.isBackwards)
									{
										flag2 = !flag2;
									}
									if (useInverse)
									{
										flag2 = !flag2;
									}
									if (s.isBackwards && !useInverse && !prevPosIsInverse)
									{
										flag2 = !flag2;
									}
									tween2.position = (flag2 ? 0f : tween2.duration);
								}
							}
						}
					}
				}
			}
			return false;
		}

		private static int SortSequencedObjs(ABSSequentiable a, ABSSequentiable b)
		{
			if (a.sequencedPosition > b.sequencedPosition)
			{
				return 1;
			}
			if (a.sequencedPosition < b.sequencedPosition)
			{
				return -1;
			}
			return 0;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.CustomPlugins;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace DG.Tweening
{
	public static class ShortcutExtensions
	{
		private sealed class __c__DisplayClass0_0
		{
			public AudioSource target;

			internal float _DOFade_b__0()
			{
				return this.target.volume;
			}

			internal void _DOFade_b__1(float x)
			{
				this.target.volume = x;
			}
		}

		private sealed class __c__DisplayClass1_0
		{
			public AudioSource target;

			internal float _DOPitch_b__0()
			{
				return this.target.pitch;
			}

			internal void _DOPitch_b__1(float x)
			{
				this.target.pitch = x;
			}
		}

		private sealed class __c__DisplayClass2_0
		{
			public Camera target;

			internal float _DOAspect_b__0()
			{
				return this.target.aspect;
			}

			internal void _DOAspect_b__1(float x)
			{
				this.target.aspect = x;
			}
		}

		private sealed class __c__DisplayClass3_0
		{
			public Camera target;

			internal Color _DOColor_b__0()
			{
				return this.target.backgroundColor;
			}

			internal void _DOColor_b__1(Color x)
			{
				this.target.backgroundColor = x;
			}
		}

		private sealed class __c__DisplayClass4_0
		{
			public Camera target;

			internal float _DOFarClipPlane_b__0()
			{
				return this.target.farClipPlane;
			}

			internal void _DOFarClipPlane_b__1(float x)
			{
				this.target.farClipPlane = x;
			}
		}

		private sealed class __c__DisplayClass5_0
		{
			public Camera target;

			internal float _DOFieldOfView_b__0()
			{
				return this.target.fieldOfView;
			}

			internal void _DOFieldOfView_b__1(float x)
			{
				this.target.fieldOfView = x;
			}
		}

		private sealed class __c__DisplayClass6_0
		{
			public Camera target;

			internal float _DONearClipPlane_b__0()
			{
				return this.target.nearClipPlane;
			}

			internal void _DONearClipPlane_b__1(float x)
			{
				this.target.nearClipPlane = x;
			}
		}

		private sealed class __c__DisplayClass7_0
		{
			public Camera target;

			internal float _DOOrthoSize_b__0()
			{
				return this.target.orthographicSize;
			}

			internal void _DOOrthoSize_b__1(float x)
			{
				this.target.orthographicSize = x;
			}
		}

		private sealed class __c__DisplayClass8_0
		{
			public Camera target;

			internal Rect _DOPixelRect_b__0()
			{
				return this.target.pixelRect;
			}

			internal void _DOPixelRect_b__1(Rect x)
			{
				this.target.pixelRect = x;
			}
		}

		private sealed class __c__DisplayClass9_0
		{
			public Camera target;

			internal Rect _DORect_b__0()
			{
				return this.target.rect;
			}

			internal void _DORect_b__1(Rect x)
			{
				this.target.rect = x;
			}
		}

		private sealed class __c__DisplayClass10_0
		{
			public Camera target;

			internal Vector3 _DOShakePosition_b__0()
			{
				return this.target.transform.localPosition;
			}

			internal void _DOShakePosition_b__1(Vector3 x)
			{
				this.target.transform.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass11_0
		{
			public Camera target;

			internal Vector3 _DOShakePosition_b__0()
			{
				return this.target.transform.localPosition;
			}

			internal void _DOShakePosition_b__1(Vector3 x)
			{
				this.target.transform.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass12_0
		{
			public Camera target;

			internal Vector3 _DOShakeRotation_b__0()
			{
				return this.target.transform.localEulerAngles;
			}

			internal void _DOShakeRotation_b__1(Vector3 x)
			{
				this.target.transform.localRotation = Quaternion.Euler(x);
			}
		}

		private sealed class __c__DisplayClass13_0
		{
			public Camera target;

			internal Vector3 _DOShakeRotation_b__0()
			{
				return this.target.transform.localEulerAngles;
			}

			internal void _DOShakeRotation_b__1(Vector3 x)
			{
				this.target.transform.localRotation = Quaternion.Euler(x);
			}
		}

		private sealed class __c__DisplayClass14_0
		{
			public Light target;

			internal Color _DOColor_b__0()
			{
				return this.target.color;
			}

			internal void _DOColor_b__1(Color x)
			{
				this.target.color = x;
			}
		}

		private sealed class __c__DisplayClass15_0
		{
			public Light target;

			internal float _DOIntensity_b__0()
			{
				return this.target.intensity;
			}

			internal void _DOIntensity_b__1(float x)
			{
				this.target.intensity = x;
			}
		}

		private sealed class __c__DisplayClass16_0
		{
			public Light target;

			internal float _DOShadowStrength_b__0()
			{
				return this.target.shadowStrength;
			}

			internal void _DOShadowStrength_b__1(float x)
			{
				this.target.shadowStrength = x;
			}
		}

		private sealed class __c__DisplayClass17_0
		{
			public Color2 startValue;

			public LineRenderer target;

			internal Color2 _DOColor_b__0()
			{
				return this.startValue;
			}

			internal void _DOColor_b__1(Color2 x)
			{
				this.target.SetColors(x.ca, x.cb);
			}
		}

		private sealed class __c__DisplayClass18_0
		{
			public Material target;

			internal Color _DOColor_b__0()
			{
				return this.target.color;
			}

			internal void _DOColor_b__1(Color x)
			{
				this.target.color = x;
			}
		}

		private sealed class __c__DisplayClass19_0
		{
			public Material target;

			public string property;

			internal Color _DOColor_b__0()
			{
				return this.target.GetColor(this.property);
			}

			internal void _DOColor_b__1(Color x)
			{
				this.target.SetColor(this.property, x);
			}
		}

		private sealed class __c__DisplayClass20_0
		{
			public Material target;

			internal Color _DOFade_b__0()
			{
				return this.target.color;
			}

			internal void _DOFade_b__1(Color x)
			{
				this.target.color = x;
			}
		}

		private sealed class __c__DisplayClass21_0
		{
			public Material target;

			public string property;

			internal Color _DOFade_b__0()
			{
				return this.target.GetColor(this.property);
			}

			internal void _DOFade_b__1(Color x)
			{
				this.target.SetColor(this.property, x);
			}
		}

		private sealed class __c__DisplayClass22_0
		{
			public Material target;

			public string property;

			internal float _DOFloat_b__0()
			{
				return this.target.GetFloat(this.property);
			}

			internal void _DOFloat_b__1(float x)
			{
				this.target.SetFloat(this.property, x);
			}
		}

		private sealed class __c__DisplayClass23_0
		{
			public Material target;

			internal Vector2 _DOOffset_b__0()
			{
				return this.target.mainTextureOffset;
			}

			internal void _DOOffset_b__1(Vector2 x)
			{
				this.target.mainTextureOffset = x;
			}
		}

		private sealed class __c__DisplayClass24_0
		{
			public Material target;

			public string property;

			internal Vector2 _DOOffset_b__0()
			{
				return this.target.GetTextureOffset(this.property);
			}

			internal void _DOOffset_b__1(Vector2 x)
			{
				this.target.SetTextureOffset(this.property, x);
			}
		}

		private sealed class __c__DisplayClass25_0
		{
			public Material target;

			internal Vector2 _DOTiling_b__0()
			{
				return this.target.mainTextureScale;
			}

			internal void _DOTiling_b__1(Vector2 x)
			{
				this.target.mainTextureScale = x;
			}
		}

		private sealed class __c__DisplayClass26_0
		{
			public Material target;

			public string property;

			internal Vector2 _DOTiling_b__0()
			{
				return this.target.GetTextureScale(this.property);
			}

			internal void _DOTiling_b__1(Vector2 x)
			{
				this.target.SetTextureScale(this.property, x);
			}
		}

		private sealed class __c__DisplayClass27_0
		{
			public Material target;

			public string property;

			internal Vector4 _DOVector_b__0()
			{
				return this.target.GetVector(this.property);
			}

			internal void _DOVector_b__1(Vector4 x)
			{
				this.target.SetVector(this.property, x);
			}
		}

		private sealed class __c__DisplayClass28_0
		{
			public Rigidbody target;

			internal Vector3 _DOMove_b__0()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass29_0
		{
			public Rigidbody target;

			internal Vector3 _DOMoveX_b__0()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass30_0
		{
			public Rigidbody target;

			internal Vector3 _DOMoveY_b__0()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass31_0
		{
			public Rigidbody target;

			internal Vector3 _DOMoveZ_b__0()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass32_0
		{
			public Rigidbody target;

			internal Quaternion _DORotate_b__0()
			{
				return this.target.rotation;
			}
		}

		private sealed class __c__DisplayClass33_0
		{
			public Rigidbody target;

			internal Quaternion _DOLookAt_b__0()
			{
				return this.target.rotation;
			}
		}

		private sealed class __c__DisplayClass34_0
		{
			public Rigidbody target;

			public bool offsetYSet;

			public float offsetY;

			public Sequence s;

			public Vector3 endValue;

			public float startPosY;

			internal Vector3 _DOJump_b__0()
			{
				return this.target.position;
			}

			internal void _DOJump_b__1()
			{
				if (!this.offsetYSet)
				{
					this.offsetYSet = true;
					this.offsetY = (this.s.isRelative ? this.endValue.y : (this.endValue.y - this.startPosY));
				}
				Vector3 position = this.target.position;
				position.y += DOVirtual.EasedValue(0f, this.offsetY, this.s.ElapsedDirectionalPercentage(), Ease.OutQuad);
				this.target.MovePosition(position);
			}

			internal Vector3 _DOJump_b__2()
			{
				return this.target.position;
			}

			internal Vector3 _DOJump_b__3()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass35_0
		{
			public Rigidbody target;

			internal Vector3 _DOPath_b__0()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass36_0
		{
			public Transform trans;

			public Rigidbody target;

			internal Vector3 _DOLocalPath_b__0()
			{
				return this.trans.localPosition;
			}

			internal void _DOLocalPath_b__1(Vector3 x)
			{
				this.target.MovePosition((this.trans.parent == null) ? x : this.trans.parent.TransformPoint(x));
			}
		}

		private sealed class __c__DisplayClass37_0
		{
			public Rigidbody target;

			internal Vector3 _DOPath_b__0()
			{
				return this.target.position;
			}
		}

		private sealed class __c__DisplayClass38_0
		{
			public Transform trans;

			public Rigidbody target;

			internal Vector3 _DOLocalPath_b__0()
			{
				return this.trans.localPosition;
			}

			internal void _DOLocalPath_b__1(Vector3 x)
			{
				this.target.MovePosition((this.trans.parent == null) ? x : this.trans.parent.TransformPoint(x));
			}
		}

		private sealed class __c__DisplayClass39_0
		{
			public TrailRenderer target;

			internal Vector2 _DOResize_b__0()
			{
				return new Vector2(this.target.startWidth, this.target.endWidth);
			}

			internal void _DOResize_b__1(Vector2 x)
			{
				this.target.startWidth = x.x;
				this.target.endWidth = x.y;
			}
		}

		private sealed class __c__DisplayClass40_0
		{
			public TrailRenderer target;

			internal float _DOTime_b__0()
			{
				return this.target.time;
			}

			internal void _DOTime_b__1(float x)
			{
				this.target.time = x;
			}
		}

		private sealed class __c__DisplayClass41_0
		{
			public Transform target;

			internal Vector3 _DOMove_b__0()
			{
				return this.target.position;
			}

			internal void _DOMove_b__1(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass42_0
		{
			public Transform target;

			internal Vector3 _DOMoveX_b__0()
			{
				return this.target.position;
			}

			internal void _DOMoveX_b__1(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass43_0
		{
			public Transform target;

			internal Vector3 _DOMoveY_b__0()
			{
				return this.target.position;
			}

			internal void _DOMoveY_b__1(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass44_0
		{
			public Transform target;

			internal Vector3 _DOMoveZ_b__0()
			{
				return this.target.position;
			}

			internal void _DOMoveZ_b__1(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass45_0
		{
			public Transform target;

			internal Vector3 _DOLocalMove_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalMove_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass46_0
		{
			public Transform target;

			internal Vector3 _DOLocalMoveX_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalMoveX_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass47_0
		{
			public Transform target;

			internal Vector3 _DOLocalMoveY_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalMoveY_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass48_0
		{
			public Transform target;

			internal Vector3 _DOLocalMoveZ_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalMoveZ_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass49_0
		{
			public Transform target;

			internal Quaternion _DORotate_b__0()
			{
				return this.target.rotation;
			}

			internal void _DORotate_b__1(Quaternion x)
			{
				this.target.rotation = x;
			}
		}

		private sealed class __c__DisplayClass50_0
		{
			public Transform target;

			internal Quaternion _DORotateQuaternion_b__0()
			{
				return this.target.rotation;
			}

			internal void _DORotateQuaternion_b__1(Quaternion x)
			{
				this.target.rotation = x;
			}
		}

		private sealed class __c__DisplayClass51_0
		{
			public Transform target;

			internal Quaternion _DOLocalRotate_b__0()
			{
				return this.target.localRotation;
			}

			internal void _DOLocalRotate_b__1(Quaternion x)
			{
				this.target.localRotation = x;
			}
		}

		private sealed class __c__DisplayClass52_0
		{
			public Transform target;

			internal Quaternion _DOLocalRotateQuaternion_b__0()
			{
				return this.target.localRotation;
			}

			internal void _DOLocalRotateQuaternion_b__1(Quaternion x)
			{
				this.target.localRotation = x;
			}
		}

		private sealed class __c__DisplayClass53_0
		{
			public Transform target;

			internal Vector3 _DOScale_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOScale_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass54_0
		{
			public Transform target;

			internal Vector3 _DOScale_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOScale_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass55_0
		{
			public Transform target;

			internal Vector3 _DOScaleX_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOScaleX_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass56_0
		{
			public Transform target;

			internal Vector3 _DOScaleY_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOScaleY_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass57_0
		{
			public Transform target;

			internal Vector3 _DOScaleZ_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOScaleZ_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass58_0
		{
			public Transform target;

			internal Quaternion _DOLookAt_b__0()
			{
				return this.target.rotation;
			}

			internal void _DOLookAt_b__1(Quaternion x)
			{
				this.target.rotation = x;
			}
		}

		private sealed class __c__DisplayClass59_0
		{
			public Transform target;

			internal Vector3 _DOPunchPosition_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOPunchPosition_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass60_0
		{
			public Transform target;

			internal Vector3 _DOPunchScale_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOPunchScale_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass61_0
		{
			public Transform target;

			internal Vector3 _DOPunchRotation_b__0()
			{
				return this.target.localEulerAngles;
			}

			internal void _DOPunchRotation_b__1(Vector3 x)
			{
				this.target.localRotation = Quaternion.Euler(x);
			}
		}

		private sealed class __c__DisplayClass62_0
		{
			public Transform target;

			internal Vector3 _DOShakePosition_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOShakePosition_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass63_0
		{
			public Transform target;

			internal Vector3 _DOShakePosition_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOShakePosition_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass64_0
		{
			public Transform target;

			internal Vector3 _DOShakeRotation_b__0()
			{
				return this.target.localEulerAngles;
			}

			internal void _DOShakeRotation_b__1(Vector3 x)
			{
				this.target.localRotation = Quaternion.Euler(x);
			}
		}

		private sealed class __c__DisplayClass65_0
		{
			public Transform target;

			internal Vector3 _DOShakeRotation_b__0()
			{
				return this.target.localEulerAngles;
			}

			internal void _DOShakeRotation_b__1(Vector3 x)
			{
				this.target.localRotation = Quaternion.Euler(x);
			}
		}

		private sealed class __c__DisplayClass66_0
		{
			public Transform target;

			internal Vector3 _DOShakeScale_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOShakeScale_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass67_0
		{
			public Transform target;

			internal Vector3 _DOShakeScale_b__0()
			{
				return this.target.localScale;
			}

			internal void _DOShakeScale_b__1(Vector3 x)
			{
				this.target.localScale = x;
			}
		}

		private sealed class __c__DisplayClass68_0
		{
			public Transform target;

			public bool offsetYSet;

			public float offsetY;

			public Sequence s;

			public Vector3 endValue;

			public float startPosY;

			internal Vector3 _DOJump_b__0()
			{
				return this.target.position;
			}

			internal void _DOJump_b__1(Vector3 x)
			{
				this.target.position = x;
			}

			internal void _DOJump_b__2()
			{
				if (!this.offsetYSet)
				{
					this.offsetYSet = true;
					this.offsetY = (this.s.isRelative ? this.endValue.y : (this.endValue.y - this.startPosY));
				}
				Vector3 position = this.target.position;
				position.y += DOVirtual.EasedValue(0f, this.offsetY, this.s.ElapsedDirectionalPercentage(), Ease.OutQuad);
				this.target.position = position;
			}

			internal Vector3 _DOJump_b__3()
			{
				return this.target.position;
			}

			internal void _DOJump_b__4(Vector3 x)
			{
				this.target.position = x;
			}

			internal Vector3 _DOJump_b__5()
			{
				return this.target.position;
			}

			internal void _DOJump_b__6(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass69_0
		{
			public Transform target;

			public bool offsetYSet;

			public float offsetY;

			public Sequence s;

			public Vector3 endValue;

			public float startPosY;

			internal Vector3 _DOLocalJump_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalJump_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}

			internal void _DOLocalJump_b__2()
			{
				if (!this.offsetYSet)
				{
					this.offsetYSet = false;
					this.offsetY = (this.s.isRelative ? this.endValue.y : (this.endValue.y - this.startPosY));
				}
				Vector3 localPosition = this.target.localPosition;
				localPosition.y += DOVirtual.EasedValue(0f, this.offsetY, this.s.ElapsedDirectionalPercentage(), Ease.OutQuad);
				this.target.localPosition = localPosition;
			}

			internal Vector3 _DOLocalJump_b__3()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalJump_b__4(Vector3 x)
			{
				this.target.localPosition = x;
			}

			internal Vector3 _DOLocalJump_b__5()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalJump_b__6(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass70_0
		{
			public Transform target;

			internal Vector3 _DOPath_b__0()
			{
				return this.target.position;
			}

			internal void _DOPath_b__1(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass71_0
		{
			public Transform target;

			internal Vector3 _DOLocalPath_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalPath_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass72_0
		{
			public Transform target;

			internal Vector3 _DOPath_b__0()
			{
				return this.target.position;
			}

			internal void _DOPath_b__1(Vector3 x)
			{
				this.target.position = x;
			}
		}

		private sealed class __c__DisplayClass73_0
		{
			public Transform target;

			internal Vector3 _DOLocalPath_b__0()
			{
				return this.target.localPosition;
			}

			internal void _DOLocalPath_b__1(Vector3 x)
			{
				this.target.localPosition = x;
			}
		}

		private sealed class __c__DisplayClass74_0
		{
			public Color to;

			public Light target;

			internal Color _DOBlendableColor_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableColor_b__1(Color x)
			{
				Color b = x - this.to;
				this.to = x;
				this.target.color += b;
			}
		}

		private sealed class __c__DisplayClass75_0
		{
			public Color to;

			public Material target;

			internal Color _DOBlendableColor_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableColor_b__1(Color x)
			{
				Color b = x - this.to;
				this.to = x;
				this.target.color += b;
			}
		}

		private sealed class __c__DisplayClass76_0
		{
			public Color to;

			public Material target;

			public string property;

			internal Color _DOBlendableColor_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableColor_b__1(Color x)
			{
				Color b = x - this.to;
				this.to = x;
				this.target.SetColor(this.property, this.target.GetColor(this.property) + b);
			}
		}

		private sealed class __c__DisplayClass77_0
		{
			public Vector3 to;

			public Transform target;

			internal Vector3 _DOBlendableMoveBy_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableMoveBy_b__1(Vector3 x)
			{
				Vector3 b = x - this.to;
				this.to = x;
				this.target.position += b;
			}
		}

		private sealed class __c__DisplayClass78_0
		{
			public Vector3 to;

			public Transform target;

			internal Vector3 _DOBlendableLocalMoveBy_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableLocalMoveBy_b__1(Vector3 x)
			{
				Vector3 b = x - this.to;
				this.to = x;
				this.target.localPosition += b;
			}
		}

		private sealed class __c__DisplayClass79_0
		{
			public Quaternion to;

			public Transform target;

			internal Quaternion _DOBlendableRotateBy_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableRotateBy_b__1(Quaternion x)
			{
				Quaternion rhs = x * Quaternion.Inverse(this.to);
				this.to = x;
				this.target.rotation = this.target.rotation * Quaternion.Inverse(this.target.rotation) * rhs * this.target.rotation;
			}
		}

		private sealed class __c__DisplayClass80_0
		{
			public Quaternion to;

			public Transform target;

			internal Quaternion _DOBlendableLocalRotateBy_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableLocalRotateBy_b__1(Quaternion x)
			{
				Quaternion rhs = x * Quaternion.Inverse(this.to);
				this.to = x;
				this.target.localRotation = this.target.localRotation * Quaternion.Inverse(this.target.localRotation) * rhs * this.target.localRotation;
			}
		}

		private sealed class __c__DisplayClass81_0
		{
			public Vector3 to;

			public Transform target;

			internal Vector3 _DOBlendableScaleBy_b__0()
			{
				return this.to;
			}

			internal void _DOBlendableScaleBy_b__1(Vector3 x)
			{
				Vector3 b = x - this.to;
				this.to = x;
				this.target.localScale += b;
			}
		}

		public static Tweener DOFade(this AudioSource target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass0_0 __c__DisplayClass0_ = new ShortcutExtensions.__c__DisplayClass0_0();
			__c__DisplayClass0_.target = target;
			if (endValue < 0f)
			{
				endValue = 0f;
			}
			else if (endValue > 1f)
			{
				endValue = 1f;
			}
			return DOTween.To(new DOGetter<float>(__c__DisplayClass0_._DOFade_b__0), new DOSetter<float>(__c__DisplayClass0_._DOFade_b__1), endValue, duration).SetTarget(__c__DisplayClass0_.target);
		}

		public static Tweener DOPitch(this AudioSource target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass1_0 __c__DisplayClass1_ = new ShortcutExtensions.__c__DisplayClass1_0();
			__c__DisplayClass1_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass1_._DOPitch_b__0), new DOSetter<float>(__c__DisplayClass1_._DOPitch_b__1), endValue, duration).SetTarget(__c__DisplayClass1_.target);
		}

		public static Tweener DOAspect(this Camera target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass2_0 __c__DisplayClass2_ = new ShortcutExtensions.__c__DisplayClass2_0();
			__c__DisplayClass2_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass2_._DOAspect_b__0), new DOSetter<float>(__c__DisplayClass2_._DOAspect_b__1), endValue, duration).SetTarget(__c__DisplayClass2_.target);
		}

		public static Tweener DOColor(this Camera target, Color endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass3_0 __c__DisplayClass3_ = new ShortcutExtensions.__c__DisplayClass3_0();
			__c__DisplayClass3_.target = target;
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass3_._DOColor_b__0), new DOSetter<Color>(__c__DisplayClass3_._DOColor_b__1), endValue, duration).SetTarget(__c__DisplayClass3_.target);
		}

		public static Tweener DOFarClipPlane(this Camera target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass4_0 __c__DisplayClass4_ = new ShortcutExtensions.__c__DisplayClass4_0();
			__c__DisplayClass4_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass4_._DOFarClipPlane_b__0), new DOSetter<float>(__c__DisplayClass4_._DOFarClipPlane_b__1), endValue, duration).SetTarget(__c__DisplayClass4_.target);
		}

		public static Tweener DOFieldOfView(this Camera target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass5_0 __c__DisplayClass5_ = new ShortcutExtensions.__c__DisplayClass5_0();
			__c__DisplayClass5_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass5_._DOFieldOfView_b__0), new DOSetter<float>(__c__DisplayClass5_._DOFieldOfView_b__1), endValue, duration).SetTarget(__c__DisplayClass5_.target);
		}

		public static Tweener DONearClipPlane(this Camera target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass6_0 __c__DisplayClass6_ = new ShortcutExtensions.__c__DisplayClass6_0();
			__c__DisplayClass6_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass6_._DONearClipPlane_b__0), new DOSetter<float>(__c__DisplayClass6_._DONearClipPlane_b__1), endValue, duration).SetTarget(__c__DisplayClass6_.target);
		}

		public static Tweener DOOrthoSize(this Camera target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass7_0 __c__DisplayClass7_ = new ShortcutExtensions.__c__DisplayClass7_0();
			__c__DisplayClass7_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass7_._DOOrthoSize_b__0), new DOSetter<float>(__c__DisplayClass7_._DOOrthoSize_b__1), endValue, duration).SetTarget(__c__DisplayClass7_.target);
		}

		public static Tweener DOPixelRect(this Camera target, Rect endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass8_0 __c__DisplayClass8_ = new ShortcutExtensions.__c__DisplayClass8_0();
			__c__DisplayClass8_.target = target;
			return DOTween.To(new DOGetter<Rect>(__c__DisplayClass8_._DOPixelRect_b__0), new DOSetter<Rect>(__c__DisplayClass8_._DOPixelRect_b__1), endValue, duration).SetTarget(__c__DisplayClass8_.target);
		}

		public static Tweener DORect(this Camera target, Rect endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass9_0 __c__DisplayClass9_ = new ShortcutExtensions.__c__DisplayClass9_0();
			__c__DisplayClass9_.target = target;
			return DOTween.To(new DOGetter<Rect>(__c__DisplayClass9_._DORect_b__0), new DOSetter<Rect>(__c__DisplayClass9_._DORect_b__1), endValue, duration).SetTarget(__c__DisplayClass9_.target);
		}

		public static Tweener DOShakePosition(this Camera target, float duration, float strength = 3f, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass10_0 __c__DisplayClass10_ = new ShortcutExtensions.__c__DisplayClass10_0();
			__c__DisplayClass10_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass10_._DOShakePosition_b__0), new DOSetter<Vector3>(__c__DisplayClass10_._DOShakePosition_b__1), duration, strength, vibrato, randomness, true, fadeOut).SetTarget(__c__DisplayClass10_.target).SetSpecialStartupMode(SpecialStartupMode.SetCameraShakePosition);
		}

		public static Tweener DOShakePosition(this Camera target, float duration, Vector3 strength, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass11_0 __c__DisplayClass11_ = new ShortcutExtensions.__c__DisplayClass11_0();
			__c__DisplayClass11_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass11_._DOShakePosition_b__0), new DOSetter<Vector3>(__c__DisplayClass11_._DOShakePosition_b__1), duration, strength, vibrato, randomness, fadeOut).SetTarget(__c__DisplayClass11_.target).SetSpecialStartupMode(SpecialStartupMode.SetCameraShakePosition);
		}

		public static Tweener DOShakeRotation(this Camera target, float duration, float strength = 90f, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass12_0 __c__DisplayClass12_ = new ShortcutExtensions.__c__DisplayClass12_0();
			__c__DisplayClass12_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass12_._DOShakeRotation_b__0), new DOSetter<Vector3>(__c__DisplayClass12_._DOShakeRotation_b__1), duration, strength, vibrato, randomness, false, fadeOut).SetTarget(__c__DisplayClass12_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static Tweener DOShakeRotation(this Camera target, float duration, Vector3 strength, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass13_0 __c__DisplayClass13_ = new ShortcutExtensions.__c__DisplayClass13_0();
			__c__DisplayClass13_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass13_._DOShakeRotation_b__0), new DOSetter<Vector3>(__c__DisplayClass13_._DOShakeRotation_b__1), duration, strength, vibrato, randomness, fadeOut).SetTarget(__c__DisplayClass13_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static Tweener DOColor(this Light target, Color endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass14_0 __c__DisplayClass14_ = new ShortcutExtensions.__c__DisplayClass14_0();
			__c__DisplayClass14_.target = target;
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass14_._DOColor_b__0), new DOSetter<Color>(__c__DisplayClass14_._DOColor_b__1), endValue, duration).SetTarget(__c__DisplayClass14_.target);
		}

		public static Tweener DOIntensity(this Light target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass15_0 __c__DisplayClass15_ = new ShortcutExtensions.__c__DisplayClass15_0();
			__c__DisplayClass15_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass15_._DOIntensity_b__0), new DOSetter<float>(__c__DisplayClass15_._DOIntensity_b__1), endValue, duration).SetTarget(__c__DisplayClass15_.target);
		}

		public static Tweener DOShadowStrength(this Light target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass16_0 __c__DisplayClass16_ = new ShortcutExtensions.__c__DisplayClass16_0();
			__c__DisplayClass16_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass16_._DOShadowStrength_b__0), new DOSetter<float>(__c__DisplayClass16_._DOShadowStrength_b__1), endValue, duration).SetTarget(__c__DisplayClass16_.target);
		}

		public static Tweener DOColor(this LineRenderer target, Color2 startValue, Color2 endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass17_0 __c__DisplayClass17_ = new ShortcutExtensions.__c__DisplayClass17_0();
			__c__DisplayClass17_.startValue = startValue;
			__c__DisplayClass17_.target = target;
			return DOTween.To(new DOGetter<Color2>(__c__DisplayClass17_._DOColor_b__0), new DOSetter<Color2>(__c__DisplayClass17_._DOColor_b__1), endValue, duration).SetTarget(__c__DisplayClass17_.target);
		}

		public static Tweener DOColor(this Material target, Color endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass18_0 __c__DisplayClass18_ = new ShortcutExtensions.__c__DisplayClass18_0();
			__c__DisplayClass18_.target = target;
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass18_._DOColor_b__0), new DOSetter<Color>(__c__DisplayClass18_._DOColor_b__1), endValue, duration).SetTarget(__c__DisplayClass18_.target);
		}

		public static Tweener DOColor(this Material target, Color endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass19_0 __c__DisplayClass19_ = new ShortcutExtensions.__c__DisplayClass19_0();
			__c__DisplayClass19_.target = target;
			__c__DisplayClass19_.property = property;
			if (!__c__DisplayClass19_.target.HasProperty(__c__DisplayClass19_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass19_.property);
				}
				return null;
			}
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass19_._DOColor_b__0), new DOSetter<Color>(__c__DisplayClass19_._DOColor_b__1), endValue, duration).SetTarget(__c__DisplayClass19_.target);
		}

		public static Tweener DOFade(this Material target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass20_0 __c__DisplayClass20_ = new ShortcutExtensions.__c__DisplayClass20_0();
			__c__DisplayClass20_.target = target;
			return DOTween.ToAlpha(new DOGetter<Color>(__c__DisplayClass20_._DOFade_b__0), new DOSetter<Color>(__c__DisplayClass20_._DOFade_b__1), endValue, duration).SetTarget(__c__DisplayClass20_.target);
		}

		public static Tweener DOFade(this Material target, float endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass21_0 __c__DisplayClass21_ = new ShortcutExtensions.__c__DisplayClass21_0();
			__c__DisplayClass21_.target = target;
			__c__DisplayClass21_.property = property;
			if (!__c__DisplayClass21_.target.HasProperty(__c__DisplayClass21_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass21_.property);
				}
				return null;
			}
			return DOTween.ToAlpha(new DOGetter<Color>(__c__DisplayClass21_._DOFade_b__0), new DOSetter<Color>(__c__DisplayClass21_._DOFade_b__1), endValue, duration).SetTarget(__c__DisplayClass21_.target);
		}

		public static Tweener DOFloat(this Material target, float endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass22_0 __c__DisplayClass22_ = new ShortcutExtensions.__c__DisplayClass22_0();
			__c__DisplayClass22_.target = target;
			__c__DisplayClass22_.property = property;
			if (!__c__DisplayClass22_.target.HasProperty(__c__DisplayClass22_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass22_.property);
				}
				return null;
			}
			return DOTween.To(new DOGetter<float>(__c__DisplayClass22_._DOFloat_b__0), new DOSetter<float>(__c__DisplayClass22_._DOFloat_b__1), endValue, duration).SetTarget(__c__DisplayClass22_.target);
		}

		public static Tweener DOOffset(this Material target, Vector2 endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass23_0 __c__DisplayClass23_ = new ShortcutExtensions.__c__DisplayClass23_0();
			__c__DisplayClass23_.target = target;
			return DOTween.To(new DOGetter<Vector2>(__c__DisplayClass23_._DOOffset_b__0), new DOSetter<Vector2>(__c__DisplayClass23_._DOOffset_b__1), endValue, duration).SetTarget(__c__DisplayClass23_.target);
		}

		public static Tweener DOOffset(this Material target, Vector2 endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass24_0 __c__DisplayClass24_ = new ShortcutExtensions.__c__DisplayClass24_0();
			__c__DisplayClass24_.target = target;
			__c__DisplayClass24_.property = property;
			if (!__c__DisplayClass24_.target.HasProperty(__c__DisplayClass24_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass24_.property);
				}
				return null;
			}
			return DOTween.To(new DOGetter<Vector2>(__c__DisplayClass24_._DOOffset_b__0), new DOSetter<Vector2>(__c__DisplayClass24_._DOOffset_b__1), endValue, duration).SetTarget(__c__DisplayClass24_.target);
		}

		public static Tweener DOTiling(this Material target, Vector2 endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass25_0 __c__DisplayClass25_ = new ShortcutExtensions.__c__DisplayClass25_0();
			__c__DisplayClass25_.target = target;
			return DOTween.To(new DOGetter<Vector2>(__c__DisplayClass25_._DOTiling_b__0), new DOSetter<Vector2>(__c__DisplayClass25_._DOTiling_b__1), endValue, duration).SetTarget(__c__DisplayClass25_.target);
		}

		public static Tweener DOTiling(this Material target, Vector2 endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass26_0 __c__DisplayClass26_ = new ShortcutExtensions.__c__DisplayClass26_0();
			__c__DisplayClass26_.target = target;
			__c__DisplayClass26_.property = property;
			if (!__c__DisplayClass26_.target.HasProperty(__c__DisplayClass26_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass26_.property);
				}
				return null;
			}
			return DOTween.To(new DOGetter<Vector2>(__c__DisplayClass26_._DOTiling_b__0), new DOSetter<Vector2>(__c__DisplayClass26_._DOTiling_b__1), endValue, duration).SetTarget(__c__DisplayClass26_.target);
		}

		public static Tweener DOVector(this Material target, Vector4 endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass27_0 __c__DisplayClass27_ = new ShortcutExtensions.__c__DisplayClass27_0();
			__c__DisplayClass27_.target = target;
			__c__DisplayClass27_.property = property;
			if (!__c__DisplayClass27_.target.HasProperty(__c__DisplayClass27_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass27_.property);
				}
				return null;
			}
			return DOTween.To(new DOGetter<Vector4>(__c__DisplayClass27_._DOVector_b__0), new DOSetter<Vector4>(__c__DisplayClass27_._DOVector_b__1), endValue, duration).SetTarget(__c__DisplayClass27_.target);
		}

		public static Tweener DOMove(this Rigidbody target, Vector3 endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass28_0 __c__DisplayClass28_ = new ShortcutExtensions.__c__DisplayClass28_0();
			__c__DisplayClass28_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass28_._DOMove_b__0), new DOSetter<Vector3>(__c__DisplayClass28_.target.MovePosition), endValue, duration).SetOptions(snapping).SetTarget(__c__DisplayClass28_.target);
		}

		public static Tweener DOMoveX(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass29_0 __c__DisplayClass29_ = new ShortcutExtensions.__c__DisplayClass29_0();
			__c__DisplayClass29_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass29_._DOMoveX_b__0), new DOSetter<Vector3>(__c__DisplayClass29_.target.MovePosition), new Vector3(endValue, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(__c__DisplayClass29_.target);
		}

		public static Tweener DOMoveY(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass30_0 __c__DisplayClass30_ = new ShortcutExtensions.__c__DisplayClass30_0();
			__c__DisplayClass30_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass30_._DOMoveY_b__0), new DOSetter<Vector3>(__c__DisplayClass30_.target.MovePosition), new Vector3(0f, endValue, 0f), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(__c__DisplayClass30_.target);
		}

		public static Tweener DOMoveZ(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass31_0 __c__DisplayClass31_ = new ShortcutExtensions.__c__DisplayClass31_0();
			__c__DisplayClass31_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass31_._DOMoveZ_b__0), new DOSetter<Vector3>(__c__DisplayClass31_.target.MovePosition), new Vector3(0f, 0f, endValue), duration).SetOptions(AxisConstraint.Z, snapping).SetTarget(__c__DisplayClass31_.target);
		}

		public static Tweener DORotate(this Rigidbody target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			ShortcutExtensions.__c__DisplayClass32_0 __c__DisplayClass32_ = new ShortcutExtensions.__c__DisplayClass32_0();
			__c__DisplayClass32_.target = target;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_31 = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass32_._DORotate_b__0), new DOSetter<Quaternion>(__c__DisplayClass32_.target.MoveRotation), endValue, duration);
			expr_31.SetTarget(__c__DisplayClass32_.target);
			expr_31.plugOptions.rotateMode = mode;
			return expr_31;
		}

		public static Tweener DOLookAt(this Rigidbody target, Vector3 towards, float duration, AxisConstraint axisConstraint = AxisConstraint.None, Vector3? up = null)
		{
			ShortcutExtensions.__c__DisplayClass33_0 __c__DisplayClass33_ = new ShortcutExtensions.__c__DisplayClass33_0();
			__c__DisplayClass33_.target = target;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_42 = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass33_._DOLookAt_b__0), new DOSetter<Quaternion>(__c__DisplayClass33_.target.MoveRotation), towards, duration).SetTarget(__c__DisplayClass33_.target).SetSpecialStartupMode(SpecialStartupMode.SetLookAt);
			expr_42.plugOptions.axisConstraint = axisConstraint;
			expr_42.plugOptions.up = ((!up.HasValue) ? Vector3.up : up.Value);
			return expr_42;
		}

		public static Sequence DOJump(this Rigidbody target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass34_0 __c__DisplayClass34_ = new ShortcutExtensions.__c__DisplayClass34_0();
			__c__DisplayClass34_.target = target;
			__c__DisplayClass34_.endValue = endValue;
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			__c__DisplayClass34_.startPosY = __c__DisplayClass34_.target.position.y;
			__c__DisplayClass34_.offsetY = -1f;
			__c__DisplayClass34_.offsetYSet = false;
			__c__DisplayClass34_.s = DOTween.Sequence();
			__c__DisplayClass34_.s.Append(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass34_._DOJump_b__0), new DOSetter<Vector3>(__c__DisplayClass34_.target.MovePosition), new Vector3(__c__DisplayClass34_.endValue.x, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear).OnUpdate(new TweenCallback(__c__DisplayClass34_._DOJump_b__1))).Join(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass34_._DOJump_b__2), new DOSetter<Vector3>(__c__DisplayClass34_.target.MovePosition), new Vector3(0f, 0f, __c__DisplayClass34_.endValue.z), duration).SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)).Join(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass34_._DOJump_b__3), new DOSetter<Vector3>(__c__DisplayClass34_.target.MovePosition), new Vector3(0f, jumpPower, 0f), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetLoops(numJumps * 2, LoopType.Yoyo).SetRelative<Tweener>()).SetTarget(__c__DisplayClass34_.target).SetEase(DOTween.defaultEaseType);
			return __c__DisplayClass34_.s;
		}

		public static TweenerCore<Vector3, Path, PathOptions> DOPath(this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			ShortcutExtensions.__c__DisplayClass35_0 __c__DisplayClass35_ = new ShortcutExtensions.__c__DisplayClass35_0();
			__c__DisplayClass35_.target = target;
			if (resolution < 1)
			{
				resolution = 1;
			}
			TweenerCore<Vector3, Path, PathOptions> expr_59 = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass35_._DOPath_b__0), new DOSetter<Vector3>(__c__DisplayClass35_.target.MovePosition), new Path(pathType, path, resolution, gizmoColor), duration).SetTarget(__c__DisplayClass35_.target).SetUpdate(UpdateType.Fixed);
			expr_59.plugOptions.isRigidbody = true;
			expr_59.plugOptions.mode = pathMode;
			return expr_59;
		}

		public static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			ShortcutExtensions.__c__DisplayClass36_0 __c__DisplayClass36_ = new ShortcutExtensions.__c__DisplayClass36_0();
			__c__DisplayClass36_.target = target;
			if (resolution < 1)
			{
				resolution = 1;
			}
			__c__DisplayClass36_.trans = __c__DisplayClass36_.target.transform;
			TweenerCore<Vector3, Path, PathOptions> expr_65 = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass36_._DOLocalPath_b__0), new DOSetter<Vector3>(__c__DisplayClass36_._DOLocalPath_b__1), new Path(pathType, path, resolution, gizmoColor), duration).SetTarget(__c__DisplayClass36_.target).SetUpdate(UpdateType.Fixed);
			expr_65.plugOptions.isRigidbody = true;
			expr_65.plugOptions.mode = pathMode;
			expr_65.plugOptions.useLocalPosition = true;
			return expr_65;
		}

		internal static TweenerCore<Vector3, Path, PathOptions> DOPath(this Rigidbody target, Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			ShortcutExtensions.__c__DisplayClass37_0 __c__DisplayClass37_ = new ShortcutExtensions.__c__DisplayClass37_0();
			__c__DisplayClass37_.target = target;
			TweenerCore<Vector3, Path, PathOptions> expr_41 = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass37_._DOPath_b__0), new DOSetter<Vector3>(__c__DisplayClass37_.target.MovePosition), path, duration).SetTarget(__c__DisplayClass37_.target);
			expr_41.plugOptions.isRigidbody = true;
			expr_41.plugOptions.mode = pathMode;
			return expr_41;
		}

		internal static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(this Rigidbody target, Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			ShortcutExtensions.__c__DisplayClass38_0 __c__DisplayClass38_ = new ShortcutExtensions.__c__DisplayClass38_0();
			__c__DisplayClass38_.target = target;
			__c__DisplayClass38_.trans = __c__DisplayClass38_.target.transform;
			TweenerCore<Vector3, Path, PathOptions> expr_4D = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass38_._DOLocalPath_b__0), new DOSetter<Vector3>(__c__DisplayClass38_._DOLocalPath_b__1), path, duration).SetTarget(__c__DisplayClass38_.target);
			expr_4D.plugOptions.isRigidbody = true;
			expr_4D.plugOptions.mode = pathMode;
			expr_4D.plugOptions.useLocalPosition = true;
			return expr_4D;
		}

		public static Tweener DOResize(this TrailRenderer target, float toStartWidth, float toEndWidth, float duration)
		{
			ShortcutExtensions.__c__DisplayClass39_0 __c__DisplayClass39_ = new ShortcutExtensions.__c__DisplayClass39_0();
			__c__DisplayClass39_.target = target;
			return DOTween.To(new DOGetter<Vector2>(__c__DisplayClass39_._DOResize_b__0), new DOSetter<Vector2>(__c__DisplayClass39_._DOResize_b__1), new Vector2(toStartWidth, toEndWidth), duration).SetTarget(__c__DisplayClass39_.target);
		}

		public static Tweener DOTime(this TrailRenderer target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass40_0 __c__DisplayClass40_ = new ShortcutExtensions.__c__DisplayClass40_0();
			__c__DisplayClass40_.target = target;
			return DOTween.To(new DOGetter<float>(__c__DisplayClass40_._DOTime_b__0), new DOSetter<float>(__c__DisplayClass40_._DOTime_b__1), endValue, duration).SetTarget(__c__DisplayClass40_.target);
		}

		public static Tweener DOMove(this Transform target, Vector3 endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass41_0 __c__DisplayClass41_ = new ShortcutExtensions.__c__DisplayClass41_0();
			__c__DisplayClass41_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass41_._DOMove_b__0), new DOSetter<Vector3>(__c__DisplayClass41_._DOMove_b__1), endValue, duration).SetOptions(snapping).SetTarget(__c__DisplayClass41_.target);
		}

		public static Tweener DOMoveX(this Transform target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass42_0 __c__DisplayClass42_ = new ShortcutExtensions.__c__DisplayClass42_0();
			__c__DisplayClass42_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass42_._DOMoveX_b__0), new DOSetter<Vector3>(__c__DisplayClass42_._DOMoveX_b__1), new Vector3(endValue, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(__c__DisplayClass42_.target);
		}

		public static Tweener DOMoveY(this Transform target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass43_0 __c__DisplayClass43_ = new ShortcutExtensions.__c__DisplayClass43_0();
			__c__DisplayClass43_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass43_._DOMoveY_b__0), new DOSetter<Vector3>(__c__DisplayClass43_._DOMoveY_b__1), new Vector3(0f, endValue, 0f), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(__c__DisplayClass43_.target);
		}

		public static Tweener DOMoveZ(this Transform target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass44_0 __c__DisplayClass44_ = new ShortcutExtensions.__c__DisplayClass44_0();
			__c__DisplayClass44_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass44_._DOMoveZ_b__0), new DOSetter<Vector3>(__c__DisplayClass44_._DOMoveZ_b__1), new Vector3(0f, 0f, endValue), duration).SetOptions(AxisConstraint.Z, snapping).SetTarget(__c__DisplayClass44_.target);
		}

		public static Tweener DOLocalMove(this Transform target, Vector3 endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass45_0 __c__DisplayClass45_ = new ShortcutExtensions.__c__DisplayClass45_0();
			__c__DisplayClass45_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass45_._DOLocalMove_b__0), new DOSetter<Vector3>(__c__DisplayClass45_._DOLocalMove_b__1), endValue, duration).SetOptions(snapping).SetTarget(__c__DisplayClass45_.target);
		}

		public static Tweener DOLocalMoveX(this Transform target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass46_0 __c__DisplayClass46_ = new ShortcutExtensions.__c__DisplayClass46_0();
			__c__DisplayClass46_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass46_._DOLocalMoveX_b__0), new DOSetter<Vector3>(__c__DisplayClass46_._DOLocalMoveX_b__1), new Vector3(endValue, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(__c__DisplayClass46_.target);
		}

		public static Tweener DOLocalMoveY(this Transform target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass47_0 __c__DisplayClass47_ = new ShortcutExtensions.__c__DisplayClass47_0();
			__c__DisplayClass47_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass47_._DOLocalMoveY_b__0), new DOSetter<Vector3>(__c__DisplayClass47_._DOLocalMoveY_b__1), new Vector3(0f, endValue, 0f), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(__c__DisplayClass47_.target);
		}

		public static Tweener DOLocalMoveZ(this Transform target, float endValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass48_0 __c__DisplayClass48_ = new ShortcutExtensions.__c__DisplayClass48_0();
			__c__DisplayClass48_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass48_._DOLocalMoveZ_b__0), new DOSetter<Vector3>(__c__DisplayClass48_._DOLocalMoveZ_b__1), new Vector3(0f, 0f, endValue), duration).SetOptions(AxisConstraint.Z, snapping).SetTarget(__c__DisplayClass48_.target);
		}

		public static Tweener DORotate(this Transform target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			ShortcutExtensions.__c__DisplayClass49_0 __c__DisplayClass49_ = new ShortcutExtensions.__c__DisplayClass49_0();
			__c__DisplayClass49_.target = target;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_2C = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass49_._DORotate_b__0), new DOSetter<Quaternion>(__c__DisplayClass49_._DORotate_b__1), endValue, duration);
			expr_2C.SetTarget(__c__DisplayClass49_.target);
			expr_2C.plugOptions.rotateMode = mode;
			return expr_2C;
		}

		public static Tweener DORotateQuaternion(this Transform target, Quaternion endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass50_0 __c__DisplayClass50_ = new ShortcutExtensions.__c__DisplayClass50_0();
			__c__DisplayClass50_.target = target;
			TweenerCore<Quaternion, Quaternion, NoOptions> expr_31 = DOTween.To<Quaternion, Quaternion, NoOptions>(PureQuaternionPlugin.Plug(), new DOGetter<Quaternion>(__c__DisplayClass50_._DORotateQuaternion_b__0), new DOSetter<Quaternion>(__c__DisplayClass50_._DORotateQuaternion_b__1), endValue, duration);
			expr_31.SetTarget(__c__DisplayClass50_.target);
			return expr_31;
		}

		public static Tweener DOLocalRotate(this Transform target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			ShortcutExtensions.__c__DisplayClass51_0 __c__DisplayClass51_ = new ShortcutExtensions.__c__DisplayClass51_0();
			__c__DisplayClass51_.target = target;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_2C = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass51_._DOLocalRotate_b__0), new DOSetter<Quaternion>(__c__DisplayClass51_._DOLocalRotate_b__1), endValue, duration);
			expr_2C.SetTarget(__c__DisplayClass51_.target);
			expr_2C.plugOptions.rotateMode = mode;
			return expr_2C;
		}

		public static Tweener DOLocalRotateQuaternion(this Transform target, Quaternion endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass52_0 __c__DisplayClass52_ = new ShortcutExtensions.__c__DisplayClass52_0();
			__c__DisplayClass52_.target = target;
			TweenerCore<Quaternion, Quaternion, NoOptions> expr_31 = DOTween.To<Quaternion, Quaternion, NoOptions>(PureQuaternionPlugin.Plug(), new DOGetter<Quaternion>(__c__DisplayClass52_._DOLocalRotateQuaternion_b__0), new DOSetter<Quaternion>(__c__DisplayClass52_._DOLocalRotateQuaternion_b__1), endValue, duration);
			expr_31.SetTarget(__c__DisplayClass52_.target);
			return expr_31;
		}

		public static Tweener DOScale(this Transform target, Vector3 endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass53_0 __c__DisplayClass53_ = new ShortcutExtensions.__c__DisplayClass53_0();
			__c__DisplayClass53_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass53_._DOScale_b__0), new DOSetter<Vector3>(__c__DisplayClass53_._DOScale_b__1), endValue, duration).SetTarget(__c__DisplayClass53_.target);
		}

		public static Tweener DOScale(this Transform target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass54_0 __c__DisplayClass54_ = new ShortcutExtensions.__c__DisplayClass54_0();
			__c__DisplayClass54_.target = target;
			Vector3 endValue2 = new Vector3(endValue, endValue, endValue);
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass54_._DOScale_b__0), new DOSetter<Vector3>(__c__DisplayClass54_._DOScale_b__1), endValue2, duration).SetTarget(__c__DisplayClass54_.target);
		}

		public static Tweener DOScaleX(this Transform target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass55_0 __c__DisplayClass55_ = new ShortcutExtensions.__c__DisplayClass55_0();
			__c__DisplayClass55_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass55_._DOScaleX_b__0), new DOSetter<Vector3>(__c__DisplayClass55_._DOScaleX_b__1), new Vector3(endValue, 0f, 0f), duration).SetOptions(AxisConstraint.X, false).SetTarget(__c__DisplayClass55_.target);
		}

		public static Tweener DOScaleY(this Transform target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass56_0 __c__DisplayClass56_ = new ShortcutExtensions.__c__DisplayClass56_0();
			__c__DisplayClass56_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass56_._DOScaleY_b__0), new DOSetter<Vector3>(__c__DisplayClass56_._DOScaleY_b__1), new Vector3(0f, endValue, 0f), duration).SetOptions(AxisConstraint.Y, false).SetTarget(__c__DisplayClass56_.target);
		}

		public static Tweener DOScaleZ(this Transform target, float endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass57_0 __c__DisplayClass57_ = new ShortcutExtensions.__c__DisplayClass57_0();
			__c__DisplayClass57_.target = target;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass57_._DOScaleZ_b__0), new DOSetter<Vector3>(__c__DisplayClass57_._DOScaleZ_b__1), new Vector3(0f, 0f, endValue), duration).SetOptions(AxisConstraint.Z, false).SetTarget(__c__DisplayClass57_.target);
		}

		public static Tweener DOLookAt(this Transform target, Vector3 towards, float duration, AxisConstraint axisConstraint = AxisConstraint.None, Vector3? up = null)
		{
			ShortcutExtensions.__c__DisplayClass58_0 __c__DisplayClass58_ = new ShortcutExtensions.__c__DisplayClass58_0();
			__c__DisplayClass58_.target = target;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_3D = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass58_._DOLookAt_b__0), new DOSetter<Quaternion>(__c__DisplayClass58_._DOLookAt_b__1), towards, duration).SetTarget(__c__DisplayClass58_.target).SetSpecialStartupMode(SpecialStartupMode.SetLookAt);
			expr_3D.plugOptions.axisConstraint = axisConstraint;
			expr_3D.plugOptions.up = ((!up.HasValue) ? Vector3.up : up.Value);
			return expr_3D;
		}

		public static Tweener DOPunchPosition(this Transform target, Vector3 punch, float duration, int vibrato = 10, float elasticity = 1f, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass59_0 __c__DisplayClass59_ = new ShortcutExtensions.__c__DisplayClass59_0();
			__c__DisplayClass59_.target = target;
			return DOTween.Punch(new DOGetter<Vector3>(__c__DisplayClass59_._DOPunchPosition_b__0), new DOSetter<Vector3>(__c__DisplayClass59_._DOPunchPosition_b__1), punch, duration, vibrato, elasticity).SetTarget(__c__DisplayClass59_.target).SetOptions(snapping);
		}

		public static Tweener DOPunchScale(this Transform target, Vector3 punch, float duration, int vibrato = 10, float elasticity = 1f)
		{
			ShortcutExtensions.__c__DisplayClass60_0 __c__DisplayClass60_ = new ShortcutExtensions.__c__DisplayClass60_0();
			__c__DisplayClass60_.target = target;
			return DOTween.Punch(new DOGetter<Vector3>(__c__DisplayClass60_._DOPunchScale_b__0), new DOSetter<Vector3>(__c__DisplayClass60_._DOPunchScale_b__1), punch, duration, vibrato, elasticity).SetTarget(__c__DisplayClass60_.target);
		}

		public static Tweener DOPunchRotation(this Transform target, Vector3 punch, float duration, int vibrato = 10, float elasticity = 1f)
		{
			ShortcutExtensions.__c__DisplayClass61_0 __c__DisplayClass61_ = new ShortcutExtensions.__c__DisplayClass61_0();
			__c__DisplayClass61_.target = target;
			return DOTween.Punch(new DOGetter<Vector3>(__c__DisplayClass61_._DOPunchRotation_b__0), new DOSetter<Vector3>(__c__DisplayClass61_._DOPunchRotation_b__1), punch, duration, vibrato, elasticity).SetTarget(__c__DisplayClass61_.target);
		}

		public static Tweener DOShakePosition(this Transform target, float duration, float strength = 1f, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass62_0 __c__DisplayClass62_ = new ShortcutExtensions.__c__DisplayClass62_0();
			__c__DisplayClass62_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass62_._DOShakePosition_b__0), new DOSetter<Vector3>(__c__DisplayClass62_._DOShakePosition_b__1), duration, strength, vibrato, randomness, false, fadeOut).SetTarget(__c__DisplayClass62_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
		}

		public static Tweener DOShakePosition(this Transform target, float duration, Vector3 strength, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass63_0 __c__DisplayClass63_ = new ShortcutExtensions.__c__DisplayClass63_0();
			__c__DisplayClass63_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass63_._DOShakePosition_b__0), new DOSetter<Vector3>(__c__DisplayClass63_._DOShakePosition_b__1), duration, strength, vibrato, randomness, fadeOut).SetTarget(__c__DisplayClass63_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake).SetOptions(snapping);
		}

		public static Tweener DOShakeRotation(this Transform target, float duration, float strength = 90f, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass64_0 __c__DisplayClass64_ = new ShortcutExtensions.__c__DisplayClass64_0();
			__c__DisplayClass64_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass64_._DOShakeRotation_b__0), new DOSetter<Vector3>(__c__DisplayClass64_._DOShakeRotation_b__1), duration, strength, vibrato, randomness, false, fadeOut).SetTarget(__c__DisplayClass64_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static Tweener DOShakeRotation(this Transform target, float duration, Vector3 strength, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass65_0 __c__DisplayClass65_ = new ShortcutExtensions.__c__DisplayClass65_0();
			__c__DisplayClass65_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass65_._DOShakeRotation_b__0), new DOSetter<Vector3>(__c__DisplayClass65_._DOShakeRotation_b__1), duration, strength, vibrato, randomness, fadeOut).SetTarget(__c__DisplayClass65_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static Tweener DOShakeScale(this Transform target, float duration, float strength = 1f, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass66_0 __c__DisplayClass66_ = new ShortcutExtensions.__c__DisplayClass66_0();
			__c__DisplayClass66_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass66_._DOShakeScale_b__0), new DOSetter<Vector3>(__c__DisplayClass66_._DOShakeScale_b__1), duration, strength, vibrato, randomness, false, fadeOut).SetTarget(__c__DisplayClass66_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static Tweener DOShakeScale(this Transform target, float duration, Vector3 strength, int vibrato = 10, float randomness = 90f, bool fadeOut = true)
		{
			ShortcutExtensions.__c__DisplayClass67_0 __c__DisplayClass67_ = new ShortcutExtensions.__c__DisplayClass67_0();
			__c__DisplayClass67_.target = target;
			return DOTween.Shake(new DOGetter<Vector3>(__c__DisplayClass67_._DOShakeScale_b__0), new DOSetter<Vector3>(__c__DisplayClass67_._DOShakeScale_b__1), duration, strength, vibrato, randomness, fadeOut).SetTarget(__c__DisplayClass67_.target).SetSpecialStartupMode(SpecialStartupMode.SetShake);
		}

		public static Sequence DOJump(this Transform target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass68_0 __c__DisplayClass68_ = new ShortcutExtensions.__c__DisplayClass68_0();
			__c__DisplayClass68_.target = target;
			__c__DisplayClass68_.endValue = endValue;
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			__c__DisplayClass68_.startPosY = __c__DisplayClass68_.target.position.y;
			__c__DisplayClass68_.offsetY = -1f;
			__c__DisplayClass68_.offsetYSet = false;
			__c__DisplayClass68_.s = DOTween.Sequence();
			__c__DisplayClass68_.s.Append(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass68_._DOJump_b__0), new DOSetter<Vector3>(__c__DisplayClass68_._DOJump_b__1), new Vector3(__c__DisplayClass68_.endValue.x, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear).OnUpdate(new TweenCallback(__c__DisplayClass68_._DOJump_b__2))).Join(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass68_._DOJump_b__3), new DOSetter<Vector3>(__c__DisplayClass68_._DOJump_b__4), new Vector3(0f, 0f, __c__DisplayClass68_.endValue.z), duration).SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)).Join(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass68_._DOJump_b__5), new DOSetter<Vector3>(__c__DisplayClass68_._DOJump_b__6), new Vector3(0f, jumpPower, 0f), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative<Tweener>().SetLoops(numJumps * 2, LoopType.Yoyo)).SetTarget(__c__DisplayClass68_.target).SetEase(DOTween.defaultEaseType);
			return __c__DisplayClass68_.s;
		}

		public static Sequence DOLocalJump(this Transform target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass69_0 __c__DisplayClass69_ = new ShortcutExtensions.__c__DisplayClass69_0();
			__c__DisplayClass69_.target = target;
			__c__DisplayClass69_.endValue = endValue;
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			__c__DisplayClass69_.startPosY = __c__DisplayClass69_.target.localPosition.y;
			__c__DisplayClass69_.offsetY = -1f;
			__c__DisplayClass69_.offsetYSet = false;
			__c__DisplayClass69_.s = DOTween.Sequence();
			__c__DisplayClass69_.s.Append(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass69_._DOLocalJump_b__0), new DOSetter<Vector3>(__c__DisplayClass69_._DOLocalJump_b__1), new Vector3(__c__DisplayClass69_.endValue.x, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear).OnUpdate(new TweenCallback(__c__DisplayClass69_._DOLocalJump_b__2))).Join(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass69_._DOLocalJump_b__3), new DOSetter<Vector3>(__c__DisplayClass69_._DOLocalJump_b__4), new Vector3(0f, 0f, __c__DisplayClass69_.endValue.z), duration).SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)).Join(DOTween.To(new DOGetter<Vector3>(__c__DisplayClass69_._DOLocalJump_b__5), new DOSetter<Vector3>(__c__DisplayClass69_._DOLocalJump_b__6), new Vector3(0f, jumpPower, 0f), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative<Tweener>().SetLoops(numJumps * 2, LoopType.Yoyo)).SetTarget(__c__DisplayClass69_.target).SetEase(DOTween.defaultEaseType);
			return __c__DisplayClass69_.s;
		}

		public static TweenerCore<Vector3, Path, PathOptions> DOPath(this Transform target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			ShortcutExtensions.__c__DisplayClass70_0 __c__DisplayClass70_ = new ShortcutExtensions.__c__DisplayClass70_0();
			__c__DisplayClass70_.target = target;
			if (resolution < 1)
			{
				resolution = 1;
			}
			TweenerCore<Vector3, Path, PathOptions> expr_4E = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass70_._DOPath_b__0), new DOSetter<Vector3>(__c__DisplayClass70_._DOPath_b__1), new Path(pathType, path, resolution, gizmoColor), duration).SetTarget(__c__DisplayClass70_.target);
			expr_4E.plugOptions.mode = pathMode;
			return expr_4E;
		}

		public static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(this Transform target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			ShortcutExtensions.__c__DisplayClass71_0 __c__DisplayClass71_ = new ShortcutExtensions.__c__DisplayClass71_0();
			__c__DisplayClass71_.target = target;
			if (resolution < 1)
			{
				resolution = 1;
			}
			TweenerCore<Vector3, Path, PathOptions> expr_4E = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass71_._DOLocalPath_b__0), new DOSetter<Vector3>(__c__DisplayClass71_._DOLocalPath_b__1), new Path(pathType, path, resolution, gizmoColor), duration).SetTarget(__c__DisplayClass71_.target);
			expr_4E.plugOptions.mode = pathMode;
			expr_4E.plugOptions.useLocalPosition = true;
			return expr_4E;
		}

		internal static TweenerCore<Vector3, Path, PathOptions> DOPath(this Transform target, Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			ShortcutExtensions.__c__DisplayClass72_0 __c__DisplayClass72_ = new ShortcutExtensions.__c__DisplayClass72_0();
			__c__DisplayClass72_.target = target;
			TweenerCore<Vector3, Path, PathOptions> expr_3C = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass72_._DOPath_b__0), new DOSetter<Vector3>(__c__DisplayClass72_._DOPath_b__1), path, duration).SetTarget(__c__DisplayClass72_.target);
			expr_3C.plugOptions.mode = pathMode;
			return expr_3C;
		}

		internal static TweenerCore<Vector3, Path, PathOptions> DOLocalPath(this Transform target, Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			ShortcutExtensions.__c__DisplayClass73_0 __c__DisplayClass73_ = new ShortcutExtensions.__c__DisplayClass73_0();
			__c__DisplayClass73_.target = target;
			TweenerCore<Vector3, Path, PathOptions> expr_3C = DOTween.To<Vector3, Path, PathOptions>(PathPlugin.Get(), new DOGetter<Vector3>(__c__DisplayClass73_._DOLocalPath_b__0), new DOSetter<Vector3>(__c__DisplayClass73_._DOLocalPath_b__1), path, duration).SetTarget(__c__DisplayClass73_.target);
			expr_3C.plugOptions.mode = pathMode;
			expr_3C.plugOptions.useLocalPosition = true;
			return expr_3C;
		}

		public static Tweener DOBlendableColor(this Light target, Color endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass74_0 __c__DisplayClass74_ = new ShortcutExtensions.__c__DisplayClass74_0();
			__c__DisplayClass74_.target = target;
			endValue -= __c__DisplayClass74_.target.color;
			__c__DisplayClass74_.to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass74_._DOBlendableColor_b__0), new DOSetter<Color>(__c__DisplayClass74_._DOBlendableColor_b__1), endValue, duration).Blendable<Color, Color, ColorOptions>().SetTarget(__c__DisplayClass74_.target);
		}

		public static Tweener DOBlendableColor(this Material target, Color endValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass75_0 __c__DisplayClass75_ = new ShortcutExtensions.__c__DisplayClass75_0();
			__c__DisplayClass75_.target = target;
			endValue -= __c__DisplayClass75_.target.color;
			__c__DisplayClass75_.to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass75_._DOBlendableColor_b__0), new DOSetter<Color>(__c__DisplayClass75_._DOBlendableColor_b__1), endValue, duration).Blendable<Color, Color, ColorOptions>().SetTarget(__c__DisplayClass75_.target);
		}

		public static Tweener DOBlendableColor(this Material target, Color endValue, string property, float duration)
		{
			ShortcutExtensions.__c__DisplayClass76_0 __c__DisplayClass76_ = new ShortcutExtensions.__c__DisplayClass76_0();
			__c__DisplayClass76_.target = target;
			__c__DisplayClass76_.property = property;
			if (!__c__DisplayClass76_.target.HasProperty(__c__DisplayClass76_.property))
			{
				if (Debugger.logPriority > 0)
				{
					Debugger.LogMissingMaterialProperty(__c__DisplayClass76_.property);
				}
				return null;
			}
			endValue -= __c__DisplayClass76_.target.GetColor(__c__DisplayClass76_.property);
			__c__DisplayClass76_.to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(new DOGetter<Color>(__c__DisplayClass76_._DOBlendableColor_b__0), new DOSetter<Color>(__c__DisplayClass76_._DOBlendableColor_b__1), endValue, duration).Blendable<Color, Color, ColorOptions>().SetTarget(__c__DisplayClass76_.target);
		}

		public static Tweener DOBlendableMoveBy(this Transform target, Vector3 byValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass77_0 __c__DisplayClass77_ = new ShortcutExtensions.__c__DisplayClass77_0();
			__c__DisplayClass77_.target = target;
			__c__DisplayClass77_.to = Vector3.zero;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass77_._DOBlendableMoveBy_b__0), new DOSetter<Vector3>(__c__DisplayClass77_._DOBlendableMoveBy_b__1), byValue, duration).Blendable<Vector3, Vector3, VectorOptions>().SetOptions(snapping).SetTarget(__c__DisplayClass77_.target);
		}

		public static Tweener DOBlendableLocalMoveBy(this Transform target, Vector3 byValue, float duration, bool snapping = false)
		{
			ShortcutExtensions.__c__DisplayClass78_0 __c__DisplayClass78_ = new ShortcutExtensions.__c__DisplayClass78_0();
			__c__DisplayClass78_.target = target;
			__c__DisplayClass78_.to = Vector3.zero;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass78_._DOBlendableLocalMoveBy_b__0), new DOSetter<Vector3>(__c__DisplayClass78_._DOBlendableLocalMoveBy_b__1), byValue, duration).Blendable<Vector3, Vector3, VectorOptions>().SetOptions(snapping).SetTarget(__c__DisplayClass78_.target);
		}

		public static Tweener DOBlendableRotateBy(this Transform target, Vector3 byValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			ShortcutExtensions.__c__DisplayClass79_0 __c__DisplayClass79_ = new ShortcutExtensions.__c__DisplayClass79_0();
			__c__DisplayClass79_.target = target;
			__c__DisplayClass79_.to = __c__DisplayClass79_.target.rotation;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_4D = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass79_._DOBlendableRotateBy_b__0), new DOSetter<Quaternion>(__c__DisplayClass79_._DOBlendableRotateBy_b__1), byValue, duration).Blendable<Quaternion, Vector3, QuaternionOptions>().SetTarget(__c__DisplayClass79_.target);
			expr_4D.plugOptions.rotateMode = mode;
			return expr_4D;
		}

		public static Tweener DOBlendableLocalRotateBy(this Transform target, Vector3 byValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			ShortcutExtensions.__c__DisplayClass80_0 __c__DisplayClass80_ = new ShortcutExtensions.__c__DisplayClass80_0();
			__c__DisplayClass80_.target = target;
			__c__DisplayClass80_.to = __c__DisplayClass80_.target.localRotation;
			TweenerCore<Quaternion, Vector3, QuaternionOptions> expr_4D = DOTween.To(new DOGetter<Quaternion>(__c__DisplayClass80_._DOBlendableLocalRotateBy_b__0), new DOSetter<Quaternion>(__c__DisplayClass80_._DOBlendableLocalRotateBy_b__1), byValue, duration).Blendable<Quaternion, Vector3, QuaternionOptions>().SetTarget(__c__DisplayClass80_.target);
			expr_4D.plugOptions.rotateMode = mode;
			return expr_4D;
		}

		public static Tweener DOBlendableScaleBy(this Transform target, Vector3 byValue, float duration)
		{
			ShortcutExtensions.__c__DisplayClass81_0 __c__DisplayClass81_ = new ShortcutExtensions.__c__DisplayClass81_0();
			__c__DisplayClass81_.target = target;
			__c__DisplayClass81_.to = Vector3.zero;
			return DOTween.To(new DOGetter<Vector3>(__c__DisplayClass81_._DOBlendableScaleBy_b__0), new DOSetter<Vector3>(__c__DisplayClass81_._DOBlendableScaleBy_b__1), byValue, duration).Blendable<Vector3, Vector3, VectorOptions>().SetTarget(__c__DisplayClass81_.target);
		}

		public static int DOComplete(this Component target, bool withCallbacks = false)
		{
			return DOTween.Complete(target, withCallbacks);
		}

		public static int DOComplete(this Material target, bool withCallbacks = false)
		{
			return DOTween.Complete(target, withCallbacks);
		}

		public static int DOKill(this Component target, bool complete = false)
		{
			return DOTween.Kill(target, complete);
		}

		public static int DOKill(this Material target, bool complete = false)
		{
			return DOTween.Kill(target, complete);
		}

		public static int DOFlip(this Component target)
		{
			return DOTween.Flip(target);
		}

		public static int DOFlip(this Material target)
		{
			return DOTween.Flip(target);
		}

		public static int DOGoto(this Component target, float to, bool andPlay = false)
		{
			return DOTween.Goto(target, to, andPlay);
		}

		public static int DOGoto(this Material target, float to, bool andPlay = false)
		{
			return DOTween.Goto(target, to, andPlay);
		}

		public static int DOPause(this Component target)
		{
			return DOTween.Pause(target);
		}

		public static int DOPause(this Material target)
		{
			return DOTween.Pause(target);
		}

		public static int DOPlay(this Component target)
		{
			return DOTween.Play(target);
		}

		public static int DOPlay(this Material target)
		{
			return DOTween.Play(target);
		}

		public static int DOPlayBackwards(this Component target)
		{
			return DOTween.PlayBackwards(target);
		}

		public static int DOPlayBackwards(this Material target)
		{
			return DOTween.PlayBackwards(target);
		}

		public static int DOPlayForward(this Component target)
		{
			return DOTween.PlayForward(target);
		}

		public static int DOPlayForward(this Material target)
		{
			return DOTween.PlayForward(target);
		}

		public static int DORestart(this Component target, bool includeDelay = true)
		{
			return DOTween.Restart(target, includeDelay);
		}

		public static int DORestart(this Material target, bool includeDelay = true)
		{
			return DOTween.Restart(target, includeDelay);
		}

		public static int DORewind(this Component target, bool includeDelay = true)
		{
			return DOTween.Rewind(target, includeDelay);
		}

		public static int DORewind(this Material target, bool includeDelay = true)
		{
			return DOTween.Rewind(target, includeDelay);
		}

		public static int DOSmoothRewind(this Component target)
		{
			return DOTween.SmoothRewind(target);
		}

		public static int DOSmoothRewind(this Material target)
		{
			return DOTween.SmoothRewind(target);
		}

		public static int DOTogglePause(this Component target)
		{
			return DOTween.TogglePause(target);
		}

		public static int DOTogglePause(this Material target)
		{
			return DOTween.TogglePause(target);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core.Easing;
using System;
using UnityEngine;

namespace DG.Tweening
{
	public class TweenParams
	{
		public static readonly TweenParams Params = new TweenParams();

		internal object id;

		internal object target;

		internal UpdateType updateType;

		internal bool isIndependentUpdate;

		internal TweenCallback onStart;

		internal TweenCallback onPlay;

		internal TweenCallback onRewind;

		internal TweenCallback onUpdate;

		internal TweenCallback onStepComplete;

		internal TweenCallback onComplete;

		internal TweenCallback onKill;

		internal TweenCallback<int> onWaypointChange;

		internal bool isRecyclable;

		internal bool isSpeedBased;

		internal bool autoKill;

		internal int loops;

		internal LoopType loopType;

		internal float delay;

		internal bool isRelative;

		internal Ease easeType;

		internal EaseFunction customEase;

		internal float easeOvershootOrAmplitude;

		internal float easePeriod;

		public TweenParams()
		{
			this.Clear();
		}

		public TweenParams Clear()
		{
			this.id = (this.target = null);
			this.updateType = DOTween.defaultUpdateType;
			this.isIndependentUpdate = DOTween.defaultTimeScaleIndependent;
			this.onStart = (this.onPlay = (this.onRewind = (this.onUpdate = (this.onStepComplete = (this.onComplete = (this.onKill = null))))));
			this.onWaypointChange = null;
			this.isRecyclable = DOTween.defaultRecyclable;
			this.isSpeedBased = false;
			this.autoKill = DOTween.defaultAutoKill;
			this.loops = 1;
			this.loopType = DOTween.defaultLoopType;
			this.delay = 0f;
			this.isRelative = false;
			this.easeType = Ease.Unset;
			this.customEase = null;
			this.easeOvershootOrAmplitude = DOTween.defaultEaseOvershootOrAmplitude;
			this.easePeriod = DOTween.defaultEasePeriod;
			return this;
		}

		public TweenParams SetAutoKill(bool autoKillOnCompletion = true)
		{
			this.autoKill = autoKillOnCompletion;
			return this;
		}

		public TweenParams SetId(object id)
		{
			this.id = id;
			return this;
		}

		public TweenParams SetTarget(object target)
		{
			this.target = target;
			return this;
		}

		public TweenParams SetLoops(int loops, LoopType? loopType = null)
		{
			if (loops < -1)
			{
				loops = -1;
			}
			else if (loops == 0)
			{
				loops = 1;
			}
			this.loops = loops;
			if (loopType.HasValue)
			{
				this.loopType = loopType.Value;
			}
			return this;
		}

		public TweenParams SetEase(Ease ease, float? overshootOrAmplitude = null, float? period = null)
		{
			this.easeType = ease;
			this.easeOvershootOrAmplitude = (overshootOrAmplitude.HasValue ? overshootOrAmplitude.Value : DOTween.defaultEaseOvershootOrAmplitude);
			this.easePeriod = (period.HasValue ? period.Value : DOTween.defaultEasePeriod);
			this.customEase = null;
			return this;
		}

		public TweenParams SetEase(AnimationCurve animCurve)
		{
			this.easeType = Ease.INTERNAL_Custom;
			this.customEase = new EaseFunction(new EaseCurve(animCurve).Evaluate);
			return this;
		}

		public TweenParams SetEase(EaseFunction customEase)
		{
			this.easeType = Ease.INTERNAL_Custom;
			this.customEase = customEase;
			return this;
		}

		public TweenParams SetRecyclable(bool recyclable = true)
		{
			this.isRecyclable = recyclable;
			return this;
		}

		public TweenParams SetUpdate(bool isIndependentUpdate)
		{
			this.updateType = DOTween.defaultUpdateType;
			this.isIndependentUpdate = isIndependentUpdate;
			return this;
		}

		public TweenParams SetUpdate(UpdateType updateType, bool isIndependentUpdate = false)
		{
			this.updateType = updateType;
			this.isIndependentUpdate = isIndependentUpdate;
			return this;
		}

		public TweenParams OnStart(TweenCallback action)
		{
			this.onStart = action;
			return this;
		}

		public TweenParams OnPlay(TweenCallback action)
		{
			this.onPlay = action;
			return this;
		}

		public TweenParams OnRewind(TweenCallback action)
		{
			this.onRewind = action;
			return this;
		}

		public TweenParams OnUpdate(TweenCallback action)
		{
			this.onUpdate = action;
			return this;
		}

		public TweenParams OnStepComplete(TweenCallback action)
		{
			this.onStepComplete = action;
			return this;
		}

		public TweenParams OnComplete(TweenCallback action)
		{
			this.onComplete = action;
			return this;
		}

		public TweenParams OnKill(TweenCallback action)
		{
			this.onKill = action;
			return this;
		}

		public TweenParams OnWaypointChange(TweenCallback<int> action)
		{
			this.onWaypointChange = action;
			return this;
		}

		public TweenParams SetDelay(float delay)
		{
			this.delay = delay;
			return this;
		}

		public TweenParams SetRelative(bool isRelative = true)
		{
			this.isRelative = isRelative;
			return this;
		}

		public TweenParams SetSpeedBased(bool isSpeedBased = true)
		{
			this.isSpeedBased = isSpeedBased;
			return this;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening
{
	public static class TweenSettingsExtensions
	{
		public static T SetAutoKill<T>(this T t) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			t.autoKill = true;
			return t;
		}

		public static T SetAutoKill<T>(this T t, bool autoKillOnCompletion) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			t.autoKill = autoKillOnCompletion;
			return t;
		}

		public static T SetId<T>(this T t, object id) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.id = id;
			return t;
		}

		public static T SetTarget<T>(this T t, object target) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.target = target;
			return t;
		}

		public static T SetLoops<T>(this T t, int loops) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			if (loops < -1)
			{
				loops = -1;
			}
			else if (loops == 0)
			{
				loops = 1;
			}
			t.loops = loops;
			if (t.tweenType == TweenType.Tweener)
			{
				if (loops > -1)
				{
					t.fullDuration = t.duration * (float)loops;
				}
				else
				{
					t.fullDuration = float.PositiveInfinity;
				}
			}
			return t;
		}

		public static T SetLoops<T>(this T t, int loops, LoopType loopType) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			if (loops < -1)
			{
				loops = -1;
			}
			else if (loops == 0)
			{
				loops = 1;
			}
			t.loops = loops;
			t.loopType = loopType;
			if (t.tweenType == TweenType.Tweener)
			{
				if (loops > -1)
				{
					t.fullDuration = t.duration * (float)loops;
				}
				else
				{
					t.fullDuration = float.PositiveInfinity;
				}
			}
			return t;
		}

		public static T SetEase<T>(this T t, Ease ease) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.easeType = ease;
			if (EaseManager.IsFlashEase(ease))
			{
				t.easeOvershootOrAmplitude = (float)((int)t.easeOvershootOrAmplitude);
			}
			t.customEase = null;
			return t;
		}

		public static T SetEase<T>(this T t, Ease ease, float overshoot) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.easeType = ease;
			if (EaseManager.IsFlashEase(ease))
			{
				overshoot = (float)((int)overshoot);
			}
			t.easeOvershootOrAmplitude = overshoot;
			t.customEase = null;
			return t;
		}

		public static T SetEase<T>(this T t, Ease ease, float amplitude, float period) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.easeType = ease;
			if (EaseManager.IsFlashEase(ease))
			{
				amplitude = (float)((int)amplitude);
			}
			t.easeOvershootOrAmplitude = amplitude;
			t.easePeriod = period;
			t.customEase = null;
			return t;
		}

		public static T SetEase<T>(this T t, AnimationCurve animCurve) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.easeType = Ease.INTERNAL_Custom;
			t.customEase = new EaseFunction(new EaseCurve(animCurve).Evaluate);
			return t;
		}

		public static T SetEase<T>(this T t, EaseFunction customEase) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.easeType = Ease.INTERNAL_Custom;
			t.customEase = customEase;
			return t;
		}

		public static T SetRecyclable<T>(this T t) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.isRecyclable = true;
			return t;
		}

		public static T SetRecyclable<T>(this T t, bool recyclable) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.isRecyclable = recyclable;
			return t;
		}

		public static T SetUpdate<T>(this T t, bool isIndependentUpdate) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			TweenManager.SetUpdateType(t, DOTween.defaultUpdateType, isIndependentUpdate);
			return t;
		}

		public static T SetUpdate<T>(this T t, UpdateType updateType) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			TweenManager.SetUpdateType(t, updateType, DOTween.defaultTimeScaleIndependent);
			return t;
		}

		public static T SetUpdate<T>(this T t, UpdateType updateType, bool isIndependentUpdate) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			TweenManager.SetUpdateType(t, updateType, isIndependentUpdate);
			return t;
		}

		public static T OnStart<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onStart = action;
			return t;
		}

		public static T OnPlay<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onPlay = action;
			return t;
		}

		public static T OnPause<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onPause = action;
			return t;
		}

		public static T OnRewind<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onRewind = action;
			return t;
		}

		public static T OnUpdate<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onUpdate = action;
			return t;
		}

		public static T OnStepComplete<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onStepComplete = action;
			return t;
		}

		public static T OnComplete<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onComplete = action;
			return t;
		}

		public static T OnKill<T>(this T t, TweenCallback action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onKill = action;
			return t;
		}

		public static T OnWaypointChange<T>(this T t, TweenCallback<int> action) where T : Tween
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.onWaypointChange = action;
			return t;
		}

		public static T SetAs<T>(this T t, Tween asTween) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			t.timeScale = asTween.timeScale;
			t.isBackwards = asTween.isBackwards;
			TweenManager.SetUpdateType(t, asTween.updateType, asTween.isIndependentUpdate);
			t.id = asTween.id;
			t.onStart = asTween.onStart;
			t.onPlay = asTween.onPlay;
			t.onRewind = asTween.onRewind;
			t.onUpdate = asTween.onUpdate;
			t.onStepComplete = asTween.onStepComplete;
			t.onComplete = asTween.onComplete;
			t.onKill = asTween.onKill;
			t.onWaypointChange = asTween.onWaypointChange;
			t.isRecyclable = asTween.isRecyclable;
			t.isSpeedBased = asTween.isSpeedBased;
			t.autoKill = asTween.autoKill;
			t.loops = asTween.loops;
			t.loopType = asTween.loopType;
			if (t.tweenType == TweenType.Tweener)
			{
				if (t.loops > -1)
				{
					t.fullDuration = t.duration * (float)t.loops;
				}
				else
				{
					t.fullDuration = float.PositiveInfinity;
				}
			}
			t.delay = asTween.delay;
			t.delayComplete = (t.delay <= 0f);
			t.isRelative = asTween.isRelative;
			t.easeType = asTween.easeType;
			t.customEase = asTween.customEase;
			t.easeOvershootOrAmplitude = asTween.easeOvershootOrAmplitude;
			t.easePeriod = asTween.easePeriod;
			return t;
		}

		public static T SetAs<T>(this T t, TweenParams tweenParams) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			TweenManager.SetUpdateType(t, tweenParams.updateType, tweenParams.isIndependentUpdate);
			t.id = tweenParams.id;
			t.onStart = tweenParams.onStart;
			t.onPlay = tweenParams.onPlay;
			t.onRewind = tweenParams.onRewind;
			t.onUpdate = tweenParams.onUpdate;
			t.onStepComplete = tweenParams.onStepComplete;
			t.onComplete = tweenParams.onComplete;
			t.onKill = tweenParams.onKill;
			t.onWaypointChange = tweenParams.onWaypointChange;
			t.isRecyclable = tweenParams.isRecyclable;
			t.isSpeedBased = tweenParams.isSpeedBased;
			t.autoKill = tweenParams.autoKill;
			t.loops = tweenParams.loops;
			t.loopType = tweenParams.loopType;
			if (t.tweenType == TweenType.Tweener)
			{
				if (t.loops > -1)
				{
					t.fullDuration = t.duration * (float)t.loops;
				}
				else
				{
					t.fullDuration = float.PositiveInfinity;
				}
			}
			t.delay = tweenParams.delay;
			t.delayComplete = (t.delay <= 0f);
			t.isRelative = tweenParams.isRelative;
			if (tweenParams.easeType == Ease.Unset)
			{
				if (t.tweenType == TweenType.Sequence)
				{
					t.easeType = Ease.Linear;
				}
				else
				{
					t.easeType = DOTween.defaultEaseType;
				}
			}
			else
			{
				t.easeType = tweenParams.easeType;
			}
			t.customEase = tweenParams.customEase;
			t.easeOvershootOrAmplitude = tweenParams.easeOvershootOrAmplitude;
			t.easePeriod = tweenParams.easePeriod;
			return t;
		}

		public static Sequence Append(this Sequence s, Tween t)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (t == null || !t.active || t.isSequenced)
			{
				return s;
			}
			Sequence.DoInsert(s, t, s.duration);
			return s;
		}

		public static Sequence Prepend(this Sequence s, Tween t)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (t == null || !t.active || t.isSequenced)
			{
				return s;
			}
			Sequence.DoPrepend(s, t);
			return s;
		}

		public static Sequence Join(this Sequence s, Tween t)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (t == null || !t.active || t.isSequenced)
			{
				return s;
			}
			Sequence.DoInsert(s, t, s.lastTweenInsertTime);
			return s;
		}

		public static Sequence Insert(this Sequence s, float atPosition, Tween t)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (t == null || !t.active || t.isSequenced)
			{
				return s;
			}
			Sequence.DoInsert(s, t, atPosition);
			return s;
		}

		public static Sequence AppendInterval(this Sequence s, float interval)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			Sequence.DoAppendInterval(s, interval);
			return s;
		}

		public static Sequence PrependInterval(this Sequence s, float interval)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			Sequence.DoPrependInterval(s, interval);
			return s;
		}

		public static Sequence AppendCallback(this Sequence s, TweenCallback callback)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (callback == null)
			{
				return s;
			}
			Sequence.DoInsertCallback(s, callback, s.duration);
			return s;
		}

		public static Sequence PrependCallback(this Sequence s, TweenCallback callback)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (callback == null)
			{
				return s;
			}
			Sequence.DoInsertCallback(s, callback, 0f);
			return s;
		}

		public static Sequence InsertCallback(this Sequence s, float atPosition, TweenCallback callback)
		{
			if (s == null || !s.active || s.creationLocked)
			{
				return s;
			}
			if (callback == null)
			{
				return s;
			}
			Sequence.DoInsertCallback(s, callback, atPosition);
			return s;
		}

		public static T From<T>(this T t) where T : Tweener
		{
			if (t == null || !t.active || t.creationLocked || !t.isFromAllowed)
			{
				return t;
			}
			t.isFrom = true;
			t.SetFrom(false);
			return t;
		}

		public static T From<T>(this T t, bool isRelative) where T : Tweener
		{
			if (t == null || !t.active || t.creationLocked || !t.isFromAllowed)
			{
				return t;
			}
			t.isFrom = true;
			if (!isRelative)
			{
				t.SetFrom(false);
			}
			else
			{
				t.SetFrom(!t.isBlendable);
			}
			return t;
		}

		public static T SetDelay<T>(this T t, float delay) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			if (t.tweenType == TweenType.Sequence)
			{
				(t as Sequence).PrependInterval(delay);
			}
			else
			{
				t.delay = delay;
				t.delayComplete = (delay <= 0f);
			}
			return t;
		}

		public static T SetRelative<T>(this T t) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked || t.isFrom || t.isBlendable)
			{
				return t;
			}
			t.isRelative = true;
			return t;
		}

		public static T SetRelative<T>(this T t, bool isRelative) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked || t.isFrom || t.isBlendable)
			{
				return t;
			}
			t.isRelative = isRelative;
			return t;
		}

		public static T SetSpeedBased<T>(this T t) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			t.isSpeedBased = true;
			return t;
		}

		public static T SetSpeedBased<T>(this T t, bool isSpeedBased) where T : Tween
		{
			if (t == null || !t.active || t.creationLocked)
			{
				return t;
			}
			t.isSpeedBased = isSpeedBased;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<float, float, FloatOptions> t, bool snapping)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector2, Vector2, VectorOptions> t, bool snapping)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector2, Vector2, VectorOptions> t, AxisConstraint axisConstraint, bool snapping = false)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.axisConstraint = axisConstraint;
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector3, Vector3, VectorOptions> t, bool snapping)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector3, Vector3, VectorOptions> t, AxisConstraint axisConstraint, bool snapping = false)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.axisConstraint = axisConstraint;
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector4, Vector4, VectorOptions> t, bool snapping)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector4, Vector4, VectorOptions> t, AxisConstraint axisConstraint, bool snapping = false)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.axisConstraint = axisConstraint;
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Quaternion, Vector3, QuaternionOptions> t, bool useShortest360Route = true)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.rotateMode = (useShortest360Route ? RotateMode.Fast : RotateMode.FastBeyond360);
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Color, Color, ColorOptions> t, bool alphaOnly)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.alphaOnly = alphaOnly;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Rect, Rect, RectOptions> t, bool snapping)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<string, string, StringOptions> t, bool richTextEnabled, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.richTextEnabled = richTextEnabled;
			t.plugOptions.scrambleMode = scrambleMode;
			if (!string.IsNullOrEmpty(scrambleChars))
			{
				if (scrambleChars.Length <= 1)
				{
					scrambleChars += scrambleChars;
				}
				t.plugOptions.scrambledChars = scrambleChars.ToCharArray();
				t.plugOptions.scrambledChars.ScrambleChars();
			}
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t, bool snapping)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static Tweener SetOptions(this TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t, AxisConstraint axisConstraint, bool snapping = false)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.axisConstraint = axisConstraint;
			t.plugOptions.snapping = snapping;
			return t;
		}

		public static TweenerCore<Vector3, Path, PathOptions> SetOptions(this TweenerCore<Vector3, Path, PathOptions> t, AxisConstraint lockPosition, AxisConstraint lockRotation = AxisConstraint.None)
		{
			return t.SetOptions(false, lockPosition, lockRotation);
		}

		public static TweenerCore<Vector3, Path, PathOptions> SetOptions(this TweenerCore<Vector3, Path, PathOptions> t, bool closePath, AxisConstraint lockPosition = AxisConstraint.None, AxisConstraint lockRotation = AxisConstraint.None)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.isClosedPath = closePath;
			t.plugOptions.lockPositionAxis = lockPosition;
			t.plugOptions.lockRotationAxis = lockRotation;
			return t;
		}

		public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(this TweenerCore<Vector3, Path, PathOptions> t, Vector3 lookAtPosition, Vector3? forwardDirection = null, Vector3? up = null)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.orientType = OrientType.LookAtPosition;
			t.plugOptions.lookAtPosition = lookAtPosition;
			t.SetPathForwardDirection(forwardDirection, up);
			return t;
		}

		public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(this TweenerCore<Vector3, Path, PathOptions> t, Transform lookAtTransform, Vector3? forwardDirection = null, Vector3? up = null)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.orientType = OrientType.LookAtTransform;
			t.plugOptions.lookAtTransform = lookAtTransform;
			t.SetPathForwardDirection(forwardDirection, up);
			return t;
		}

		public static TweenerCore<Vector3, Path, PathOptions> SetLookAt(this TweenerCore<Vector3, Path, PathOptions> t, float lookAhead, Vector3? forwardDirection = null, Vector3? up = null)
		{
			if (t == null || !t.active)
			{
				return t;
			}
			t.plugOptions.orientType = OrientType.ToPath;
			if (lookAhead < 0.0001f)
			{
				lookAhead = 0.0001f;
			}
			t.plugOptions.lookAhead = lookAhead;
			t.SetPathForwardDirection(forwardDirection, up);
			return t;
		}

		private static void SetPathForwardDirection(this TweenerCore<Vector3, Path, PathOptions> t, Vector3? forwardDirection = null, Vector3? up = null)
		{
			if (t == null || !t.active)
			{
				return;
			}
			bool arg_86_1;
			if (forwardDirection.HasValue)
			{
				Vector3? vector = forwardDirection;
				Vector3 zero = Vector3.zero;
				if (!vector.HasValue || (vector.HasValue && vector.GetValueOrDefault() != zero))
				{
					arg_86_1 = true;
					goto IL_86;
				}
			}
			if (up.HasValue)
			{
				Vector3? vector = up;
				Vector3 zero = Vector3.zero;
				arg_86_1 = (!vector.HasValue || (vector.HasValue && vector.GetValueOrDefault() != zero));
			}
			else
			{
				arg_86_1 = false;
			}
			IL_86:
			t.plugOptions.hasCustomForwardDirection = arg_86_1;
			if (t.plugOptions.hasCustomForwardDirection)
			{
				Vector3? vector = forwardDirection;
				Vector3 zero = Vector3.zero;
				if (vector.HasValue && (!vector.HasValue || vector.GetValueOrDefault() == zero))
				{
					forwardDirection = new Vector3?(Vector3.forward);
				}
				t.plugOptions.forward = Quaternion.LookRotation((!forwardDirection.HasValue) ? Vector3.forward : forwardDirection.Value, (!up.HasValue) ? Vector3.up : up.Value);
			}
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum LogBehaviour
	{
		Default,
		Verbose,
		ErrorsOnly
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using System;

namespace DG.Tweening
{
	public abstract class Tween : ABSSequentiable
	{
		public float timeScale;

		public bool isBackwards;

		public object id;

		public object target;

		internal UpdateType updateType;

		internal bool isIndependentUpdate;

		internal TweenCallback onPlay;

		internal TweenCallback onPause;

		internal TweenCallback onRewind;

		internal TweenCallback onUpdate;

		internal TweenCallback onStepComplete;

		internal TweenCallback onComplete;

		internal TweenCallback onKill;

		internal TweenCallback<int> onWaypointChange;

		internal bool isFrom;

		internal bool isBlendable;

		internal bool isRecyclable;

		internal bool isSpeedBased;

		internal bool autoKill;

		internal float duration;

		internal int loops;

		internal LoopType loopType;

		internal float delay;

		internal bool isRelative;

		internal Ease easeType;

		internal EaseFunction customEase;

		public float easeOvershootOrAmplitude;

		public float easePeriod;

		internal Type typeofT1;

		internal Type typeofT2;

		internal Type typeofTPlugOptions;

		internal bool active;

		internal bool isSequenced;

		internal Sequence sequenceParent;

		internal int activeId = -1;

		internal SpecialStartupMode specialStartupMode;

		internal bool creationLocked;

		internal bool startupDone;

		internal bool playedOnce;

		internal float position;

		internal float fullDuration;

		internal int completedLoops;

		internal bool isPlaying;

		internal bool isComplete;

		internal float elapsedDelay;

		internal bool delayComplete = true;

		internal int miscInt = -1;

		public float fullPosition
		{
			get
			{
				return this.Elapsed(true);
			}
			set
			{
				this.Goto(value, this.isPlaying);
			}
		}

		internal virtual void Reset()
		{
			this.timeScale = 1f;
			this.isBackwards = false;
			this.id = null;
			this.isIndependentUpdate = false;
			this.onStart = (this.onPlay = (this.onRewind = (this.onUpdate = (this.onComplete = (this.onStepComplete = (this.onKill = null))))));
			this.onWaypointChange = null;
			this.target = null;
			this.isFrom = false;
			this.isBlendable = false;
			this.isSpeedBased = false;
			this.duration = 0f;
			this.loops = 1;
			this.delay = 0f;
			this.isRelative = false;
			this.customEase = null;
			this.isSequenced = false;
			this.sequenceParent = null;
			this.specialStartupMode = SpecialStartupMode.None;
			this.creationLocked = (this.startupDone = (this.playedOnce = false));
			this.position = (this.fullDuration = (float)(this.completedLoops = 0));
			this.isPlaying = (this.isComplete = false);
			this.elapsedDelay = 0f;
			this.delayComplete = true;
			this.miscInt = -1;
		}

		internal abstract bool Validate();

		internal virtual float UpdateDelay(float elapsed)
		{
			return 0f;
		}

		internal abstract bool Startup();

		internal abstract bool ApplyTween(float prevPosition, int prevCompletedLoops, int newCompletedSteps, bool useInversePosition, UpdateMode updateMode, UpdateNotice updateNotice);

		internal static bool DoGoto(Tween t, float toPosition, int toCompletedLoops, UpdateMode updateMode)
		{
			if (!t.startupDone && !t.Startup())
			{
				return true;
			}
			if (!t.playedOnce && updateMode == UpdateMode.Update)
			{
				t.playedOnce = true;
				if (t.onStart != null)
				{
					Tween.OnTweenCallback(t.onStart);
					if (!t.active)
					{
						return true;
					}
				}
				if (t.onPlay != null)
				{
					Tween.OnTweenCallback(t.onPlay);
					if (!t.active)
					{
						return true;
					}
				}
			}
			float prevPosition = t.position;
			int num = t.completedLoops;
			t.completedLoops = toCompletedLoops;
			bool flag = t.position <= 0f && num <= 0;
			bool flag2 = t.isComplete;
			if (t.loops != -1)
			{
				t.isComplete = (t.completedLoops == t.loops);
			}
			int num2 = 0;
			if (updateMode == UpdateMode.Update)
			{
				if (t.isBackwards)
				{
					num2 = ((t.completedLoops < num) ? (num - t.completedLoops) : ((toPosition <= 0f && !flag) ? 1 : 0));
					if (flag2)
					{
						num2--;
					}
				}
				else
				{
					num2 = ((t.completedLoops > num) ? (t.completedLoops - num) : 0);
				}
			}
			else if (t.tweenType == TweenType.Sequence)
			{
				num2 = num - toCompletedLoops;
				if (num2 < 0)
				{
					num2 = -num2;
				}
			}
			t.position = toPosition;
			if (t.position > t.duration)
			{
				t.position = t.duration;
			}
			else if (t.position <= 0f)
			{
				if (t.completedLoops > 0 || t.isComplete)
				{
					t.position = t.duration;
				}
				else
				{
					t.position = 0f;
				}
			}
			bool flag3 = t.isPlaying;
			if (t.isPlaying)
			{
				if (!t.isBackwards)
				{
					t.isPlaying = !t.isComplete;
				}
				else
				{
					t.isPlaying = (t.completedLoops != 0 || t.position > 0f);
				}
			}
			bool useInversePosition = t.loopType == LoopType.Yoyo && ((t.position < t.duration) ? (t.completedLoops % 2 != 0) : (t.completedLoops % 2 == 0));
			UpdateNotice updateNotice = (!flag && ((t.loopType == LoopType.Restart && t.completedLoops != num) || (t.position <= 0f && t.completedLoops <= 0))) ? UpdateNotice.RewindStep : UpdateNotice.None;
			if (t.ApplyTween(prevPosition, num, num2, useInversePosition, updateMode, updateNotice))
			{
				return true;
			}
			if (t.onUpdate != null && updateMode != UpdateMode.IgnoreOnUpdate)
			{
				Tween.OnTweenCallback(t.onUpdate);
			}
			if (t.position <= 0f && t.completedLoops <= 0 && !flag && t.onRewind != null)
			{
				Tween.OnTweenCallback(t.onRewind);
			}
			if (num2 > 0 && updateMode == UpdateMode.Update && t.onStepComplete != null)
			{
				for (int i = 0; i < num2; i++)
				{
					Tween.OnTweenCallback(t.onStepComplete);
				}
			}
			if (t.isComplete && !flag2 && t.onComplete != null)
			{
				Tween.OnTweenCallback(t.onComplete);
			}
			if ((!t.isPlaying & flag3) && (!t.isComplete || !t.autoKill) && t.onPause != null)
			{
				Tween.OnTweenCallback(t.onPause);
			}
			return t.autoKill && t.isComplete;
		}

		internal static bool OnTweenCallback(TweenCallback callback)
		{
			if (DOTween.useSafeMode)
			{
				try
				{
					callback();
					return true;
				}
				catch (Exception ex)
				{
					Debugger.LogWarning(string.Concat(new string[]
					{
						"An error inside a tween callback was silently taken care of > ",
						ex.Message,
						"\n\n",
						ex.StackTrace,
						"\n\n"
					}));
					return false;
				}
			}
			callback();
			return true;
		}

		internal static bool OnTweenCallback<T>(TweenCallback<T> callback, T param)
		{
			if (DOTween.useSafeMode)
			{
				try
				{
					callback(param);
					return true;
				}
				catch (Exception ex)
				{
					Debugger.LogWarning("An error inside a tween callback was silently taken care of > " + ex.Message);
					return false;
				}
			}
			callback(param);
			return true;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening
{
	public abstract class Tweener : Tween
	{
		internal bool hasManuallySetStartValue;

		internal bool isFromAllowed = true;

		internal Tweener()
		{
		}

		public abstract Tweener ChangeStartValue(object newStartValue, float newDuration = -1f);

		public abstract Tweener ChangeEndValue(object newEndValue, float newDuration = -1f, bool snapStartValue = false);

		public abstract Tweener ChangeEndValue(object newEndValue, bool snapStartValue);

		public abstract Tweener ChangeValues(object newStartValue, object newEndValue, float newDuration = -1f);

		internal abstract Tweener SetFrom(bool relative);

		internal static bool Setup<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t, DOGetter<T1> getter, DOSetter<T1> setter, T2 endValue, float duration, ABSTweenPlugin<T1, T2, TPlugOptions> plugin = null) where TPlugOptions : struct, IPlugOptions
		{
			if (plugin != null)
			{
				t.tweenPlugin = plugin;
			}
			else
			{
				if (t.tweenPlugin == null)
				{
					t.tweenPlugin = PluginsManager.GetDefaultPlugin<T1, T2, TPlugOptions>();
				}
				if (t.tweenPlugin == null)
				{
					Debugger.LogError("No suitable plugin found for this type");
					return false;
				}
			}
			t.getter = getter;
			t.setter = setter;
			t.endValue = endValue;
			t.duration = duration;
			t.autoKill = DOTween.defaultAutoKill;
			t.isRecyclable = DOTween.defaultRecyclable;
			t.easeType = DOTween.defaultEaseType;
			t.easeOvershootOrAmplitude = DOTween.defaultEaseOvershootOrAmplitude;
			t.easePeriod = DOTween.defaultEasePeriod;
			t.loopType = DOTween.defaultLoopType;
			t.isPlaying = (DOTween.defaultAutoPlay == AutoPlay.All || DOTween.defaultAutoPlay == AutoPlay.AutoPlayTweeners);
			return true;
		}

		internal static float DoUpdateDelay<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t, float elapsed) where TPlugOptions : struct, IPlugOptions
		{
			float delay = t.delay;
			if (elapsed > delay)
			{
				t.elapsedDelay = delay;
				t.delayComplete = true;
				return elapsed - delay;
			}
			t.elapsedDelay = elapsed;
			return 0f;
		}

		internal static bool DoStartup<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t) where TPlugOptions : struct, IPlugOptions
		{
			t.startupDone = true;
			if (t.specialStartupMode != SpecialStartupMode.None && !Tweener.DOStartupSpecials<T1, T2, TPlugOptions>(t))
			{
				return false;
			}
			if (!t.hasManuallySetStartValue)
			{
				if (DOTween.useSafeMode)
				{
					try
					{
						t.startValue = t.tweenPlugin.ConvertToStartValue(t, t.getter());
						goto IL_69;
					}
					catch
					{
						return false;
					}
				}
				t.startValue = t.tweenPlugin.ConvertToStartValue(t, t.getter());
			}
			IL_69:
			if (t.isRelative)
			{
				t.tweenPlugin.SetRelativeEndValue(t);
			}
			t.tweenPlugin.SetChangeValue(t);
			Tweener.DOStartupDurationBased<T1, T2, TPlugOptions>(t);
			if (t.duration <= 0f)
			{
				t.easeType = Ease.INTERNAL_Zero;
			}
			return true;
		}

		internal static Tweener DoChangeStartValue<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t, T2 newStartValue, float newDuration) where TPlugOptions : struct, IPlugOptions
		{
			t.hasManuallySetStartValue = true;
			t.startValue = newStartValue;
			if (t.startupDone)
			{
				if (t.specialStartupMode != SpecialStartupMode.None && !Tweener.DOStartupSpecials<T1, T2, TPlugOptions>(t))
				{
					return null;
				}
				t.tweenPlugin.SetChangeValue(t);
			}
			if (newDuration > 0f)
			{
				t.duration = newDuration;
				if (t.startupDone)
				{
					Tweener.DOStartupDurationBased<T1, T2, TPlugOptions>(t);
				}
			}
			Tween.DoGoto(t, 0f, 0, UpdateMode.IgnoreOnUpdate);
			return t;
		}

		internal static Tweener DoChangeEndValue<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t, T2 newEndValue, float newDuration, bool snapStartValue) where TPlugOptions : struct, IPlugOptions
		{
			t.endValue = newEndValue;
			t.isRelative = false;
			if (t.startupDone)
			{
				if (t.specialStartupMode != SpecialStartupMode.None && !Tweener.DOStartupSpecials<T1, T2, TPlugOptions>(t))
				{
					return null;
				}
				if (snapStartValue)
				{
					if (DOTween.useSafeMode)
					{
						try
						{
							t.startValue = t.tweenPlugin.ConvertToStartValue(t, t.getter());
							goto IL_7A;
						}
						catch
						{
							TweenManager.Despawn(t, true);
							return null;
						}
					}
					t.startValue = t.tweenPlugin.ConvertToStartValue(t, t.getter());
				}
				IL_7A:
				t.tweenPlugin.SetChangeValue(t);
			}
			if (newDuration > 0f)
			{
				t.duration = newDuration;
				if (t.startupDone)
				{
					Tweener.DOStartupDurationBased<T1, T2, TPlugOptions>(t);
				}
			}
			Tween.DoGoto(t, 0f, 0, UpdateMode.IgnoreOnUpdate);
			return t;
		}

		internal static Tweener DoChangeValues<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t, T2 newStartValue, T2 newEndValue, float newDuration) where TPlugOptions : struct, IPlugOptions
		{
			t.hasManuallySetStartValue = true;
			t.isRelative = (t.isFrom = false);
			t.startValue = newStartValue;
			t.endValue = newEndValue;
			if (t.startupDone)
			{
				if (t.specialStartupMode != SpecialStartupMode.None && !Tweener.DOStartupSpecials<T1, T2, TPlugOptions>(t))
				{
					return null;
				}
				t.tweenPlugin.SetChangeValue(t);
			}
			if (newDuration > 0f)
			{
				t.duration = newDuration;
				if (t.startupDone)
				{
					Tweener.DOStartupDurationBased<T1, T2, TPlugOptions>(t);
				}
			}
			Tween.DoGoto(t, 0f, 0, UpdateMode.IgnoreOnUpdate);
			return t;
		}

		private static bool DOStartupSpecials<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t) where TPlugOptions : struct, IPlugOptions
		{
			bool result;
			try
			{
				switch (t.specialStartupMode)
				{
				case SpecialStartupMode.SetLookAt:
					if (!SpecialPluginsUtils.SetLookAt(t as TweenerCore<Quaternion, Vector3, QuaternionOptions>))
					{
						result = false;
						return result;
					}
					break;
				case SpecialStartupMode.SetShake:
					if (!SpecialPluginsUtils.SetShake(t as TweenerCore<Vector3, Vector3[], Vector3ArrayOptions>))
					{
						result = false;
						return result;
					}
					break;
				case SpecialStartupMode.SetPunch:
					if (!SpecialPluginsUtils.SetPunch(t as TweenerCore<Vector3, Vector3[], Vector3ArrayOptions>))
					{
						result = false;
						return result;
					}
					break;
				case SpecialStartupMode.SetCameraShakePosition:
					if (!SpecialPluginsUtils.SetCameraShakePosition(t as TweenerCore<Vector3, Vector3[], Vector3ArrayOptions>))
					{
						result = false;
						return result;
					}
					break;
				}
				result = true;
			}
			catch
			{
				result = false;
			}
			return result;
		}

		private static void DOStartupDurationBased<T1, T2, TPlugOptions>(TweenerCore<T1, T2, TPlugOptions> t) where TPlugOptions : struct, IPlugOptions
		{
			if (t.isSpeedBased)
			{
				t.duration = t.tweenPlugin.GetSpeedBasedDuration(t.plugOptions, t.duration, t.changeValue);
			}
			t.fullDuration = ((t.loops > -1) ? (t.duration * (float)t.loops) : float.PositiveInfinity);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum TweenType
	{
		Tweener,
		Sequence,
		Callback
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening
{
	public enum UpdateType
	{
		Normal,
		Late,
		Fixed
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	internal class Color2Plugin : ABSTweenPlugin<Color2, Color2, ColorOptions>
	{
		public override void Reset(TweenerCore<Color2, Color2, ColorOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Color2, Color2, ColorOptions> t, bool isRelative)
		{
			Color2 endValue = t.endValue;
			t.endValue = t.getter();
			if (isRelative)
			{
				t.startValue = new Color2(t.endValue.ca + endValue.ca, t.endValue.cb + endValue.cb);
			}
			else
			{
				t.startValue = new Color2(endValue.ca, endValue.cb);
			}
			Color2 pNewValue = t.endValue;
			if (!t.plugOptions.alphaOnly)
			{
				pNewValue = t.startValue;
			}
			else
			{
				pNewValue.ca.a = t.startValue.ca.a;
				pNewValue.cb.a = t.startValue.cb.a;
			}
			t.setter(pNewValue);
		}

		public override Color2 ConvertToStartValue(TweenerCore<Color2, Color2, ColorOptions> t, Color2 value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Color2, Color2, ColorOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Color2, Color2, ColorOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(ColorOptions options, float unitsXSecond, Color2 changeValue)
		{
			return 1f / unitsXSecond;
		}

		public override void EvaluateAndApply(ColorOptions options, Tween t, bool isRelative, DOGetter<Color2> getter, DOSetter<Color2> setter, float elapsed, Color2 startValue, Color2 changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			if (!options.alphaOnly)
			{
				startValue.ca.r = startValue.ca.r + changeValue.ca.r * num;
				startValue.ca.g = startValue.ca.g + changeValue.ca.g * num;
				startValue.ca.b = startValue.ca.b + changeValue.ca.b * num;
				startValue.ca.a = startValue.ca.a + changeValue.ca.a * num;
				startValue.cb.r = startValue.cb.r + changeValue.cb.r * num;
				startValue.cb.g = startValue.cb.g + changeValue.cb.g * num;
				startValue.cb.b = startValue.cb.b + changeValue.cb.b * num;
				startValue.cb.a = startValue.cb.a + changeValue.cb.a * num;
				setter(startValue);
				return;
			}
			Color2 pNewValue = getter();
			pNewValue.ca.a = startValue.ca.a + changeValue.ca.a * num;
			pNewValue.cb.a = startValue.cb.a + changeValue.cb.a * num;
			setter(pNewValue);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	public class DoublePlugin : ABSTweenPlugin<double, double, NoOptions>
	{
		public override void Reset(TweenerCore<double, double, NoOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<double, double, NoOptions> t, bool isRelative)
		{
			double endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			t.setter(t.startValue);
		}

		public override double ConvertToStartValue(TweenerCore<double, double, NoOptions> t, double value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<double, double, NoOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<double, double, NoOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(NoOptions options, float unitsXSecond, double changeValue)
		{
			float num = (float)changeValue / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(NoOptions options, Tween t, bool isRelative, DOGetter<double> getter, DOSetter<double> setter, float elapsed, double startValue, double changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (double)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (double)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (double)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			setter(startValue + changeValue * (double)EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	public class LongPlugin : ABSTweenPlugin<long, long, NoOptions>
	{
		public override void Reset(TweenerCore<long, long, NoOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<long, long, NoOptions> t, bool isRelative)
		{
			long endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			t.setter(t.startValue);
		}

		public override long ConvertToStartValue(TweenerCore<long, long, NoOptions> t, long value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<long, long, NoOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<long, long, NoOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(NoOptions options, float unitsXSecond, long changeValue)
		{
			float num = (float)changeValue / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(NoOptions options, Tween t, bool isRelative, DOGetter<long> getter, DOSetter<long> setter, float elapsed, long startValue, long changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (long)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (long)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (long)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			setter((long)Math.Round((double)((float)startValue + (float)changeValue * EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod))));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	public class UlongPlugin : ABSTweenPlugin<ulong, ulong, NoOptions>
	{
		public override void Reset(TweenerCore<ulong, ulong, NoOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<ulong, ulong, NoOptions> t, bool isRelative)
		{
			ulong endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			t.setter(t.startValue);
		}

		public override ulong ConvertToStartValue(TweenerCore<ulong, ulong, NoOptions> t, ulong value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<ulong, ulong, NoOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<ulong, ulong, NoOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(NoOptions options, float unitsXSecond, ulong changeValue)
		{
			float num = changeValue / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(NoOptions options, Tween t, bool isRelative, DOGetter<ulong> getter, DOSetter<ulong> setter, float elapsed, ulong startValue, ulong changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (ulong)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (ulong)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (ulong)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			setter((ulong)(startValue + changeValue * (decimal)EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod)));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class Vector3ArrayPlugin : ABSTweenPlugin<Vector3, Vector3[], Vector3ArrayOptions>
	{
		public override void Reset(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t)
		{
			t.startValue = (t.endValue = (t.changeValue = null));
		}

		public override void SetFrom(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t, bool isRelative)
		{
		}

		public override Vector3[] ConvertToStartValue(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t, Vector3 value)
		{
			int num = t.endValue.Length;
			Vector3[] array = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				if (i == 0)
				{
					array[i] = value;
				}
				else
				{
					array[i] = t.endValue[i - 1];
				}
			}
			return array;
		}

		public override void SetRelativeEndValue(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t)
		{
			int num = t.endValue.Length;
			for (int i = 0; i < num; i++)
			{
				if (i > 0)
				{
					t.startValue[i] = t.endValue[i - 1];
				}
				t.endValue[i] = t.startValue[i] + t.endValue[i];
			}
		}

		public override void SetChangeValue(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t)
		{
			int num = t.endValue.Length;
			t.changeValue = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				t.changeValue[i] = t.endValue[i] - t.startValue[i];
			}
		}

		public override float GetSpeedBasedDuration(Vector3ArrayOptions options, float unitsXSecond, Vector3[] changeValue)
		{
			float num = 0f;
			int num2 = changeValue.Length;
			for (int i = 0; i < num2; i++)
			{
				float num3 = changeValue[i].magnitude / options.durations[i];
				options.durations[i] = num3;
				num += num3;
			}
			return num;
		}

		public override void EvaluateAndApply(Vector3ArrayOptions options, Tween t, bool isRelative, DOGetter<Vector3> getter, DOSetter<Vector3> setter, float elapsed, Vector3[] startValue, Vector3[] changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			Vector3 vector = Vector3.zero;
			if (t.loopType == LoopType.Incremental)
			{
				int num = t.isComplete ? (t.completedLoops - 1) : t.completedLoops;
				if (num > 0)
				{
					int num2 = startValue.Length - 1;
					vector = (startValue[num2] + changeValue[num2] - startValue[0]) * (float)num;
				}
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				int num3 = ((t.loopType == LoopType.Incremental) ? t.loops : 1) * (t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
				if (num3 > 0)
				{
					int num4 = startValue.Length - 1;
					vector += (startValue[num4] + changeValue[num4] - startValue[0]) * (float)num3;
				}
			}
			int num5 = 0;
			float num6 = 0f;
			float num7 = 0f;
			int num8 = options.durations.Length;
			float num9 = 0f;
			for (int i = 0; i < num8; i++)
			{
				num7 = options.durations[i];
				num9 += num7;
				if (elapsed <= num9)
				{
					num5 = i;
					num6 = elapsed - num6;
					break;
				}
				num6 += num7;
			}
			float num10 = EaseManager.Evaluate(t.easeType, t.customEase, num6, num7, t.easeOvershootOrAmplitude, t.easePeriod);
			AxisConstraint axisConstraint = options.axisConstraint;
			Vector3 vector2;
			if (axisConstraint == AxisConstraint.X)
			{
				vector2 = getter();
				vector2.x = startValue[num5].x + vector.x + changeValue[num5].x * num10;
				if (options.snapping)
				{
					vector2.x = (float)Math.Round((double)vector2.x);
				}
				setter(vector2);
				return;
			}
			if (axisConstraint == AxisConstraint.Y)
			{
				vector2 = getter();
				vector2.y = startValue[num5].y + vector.y + changeValue[num5].y * num10;
				if (options.snapping)
				{
					vector2.y = (float)Math.Round((double)vector2.y);
				}
				setter(vector2);
				return;
			}
			if (axisConstraint != AxisConstraint.Z)
			{
				vector2.x = startValue[num5].x + vector.x + changeValue[num5].x * num10;
				vector2.y = startValue[num5].y + vector.y + changeValue[num5].y * num10;
				vector2.z = startValue[num5].z + vector.z + changeValue[num5].z * num10;
				if (options.snapping)
				{
					vector2.x = (float)Math.Round((double)vector2.x);
					vector2.y = (float)Math.Round((double)vector2.y);
					vector2.z = (float)Math.Round((double)vector2.z);
				}
				setter(vector2);
				return;
			}
			vector2 = getter();
			vector2.z = startValue[num5].z + vector.z + changeValue[num5].z * num10;
			if (options.snapping)
			{
				vector2.z = (float)Math.Round((double)vector2.z);
			}
			setter(vector2);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class PathPlugin : ABSTweenPlugin<Vector3, Path, PathOptions>
	{
		public const float MinLookAhead = 0.0001f;

		public override void Reset(TweenerCore<Vector3, Path, PathOptions> t)
		{
			t.endValue.Destroy();
			t.startValue = (t.endValue = (t.changeValue = null));
		}

		public override void SetFrom(TweenerCore<Vector3, Path, PathOptions> t, bool isRelative)
		{
		}

		public static ABSTweenPlugin<Vector3, Path, PathOptions> Get()
		{
			return PluginsManager.GetCustomPlugin<PathPlugin, Vector3, Path, PathOptions>();
		}

		public override Path ConvertToStartValue(TweenerCore<Vector3, Path, PathOptions> t, Vector3 value)
		{
			return t.endValue;
		}

		public override void SetRelativeEndValue(TweenerCore<Vector3, Path, PathOptions> t)
		{
			if (t.endValue.isFinalized)
			{
				return;
			}
			Vector3 b = t.getter();
			int num = t.endValue.wps.Length;
			for (int i = 0; i < num; i++)
			{
				t.endValue.wps[i] += b;
			}
		}

		public override void SetChangeValue(TweenerCore<Vector3, Path, PathOptions> t)
		{
			Transform transform = ((Component)t.target).transform;
			if (t.plugOptions.orientType == OrientType.ToPath && t.plugOptions.useLocalPosition)
			{
				t.plugOptions.parent = transform.parent;
			}
			if (t.endValue.isFinalized)
			{
				t.changeValue = t.endValue;
				return;
			}
			Vector3 vector = t.getter();
			Path endValue = t.endValue;
			int num = endValue.wps.Length;
			int num2 = 0;
			bool flag = false;
			bool flag2 = false;
			if (endValue.wps[0] != vector)
			{
				flag = true;
				num2++;
			}
			if (t.plugOptions.isClosedPath && endValue.wps[num - 1] != vector)
			{
				flag2 = true;
				num2++;
			}
			Vector3[] array = new Vector3[num + num2];
			int num3 = flag ? 1 : 0;
			if (flag)
			{
				array[0] = vector;
			}
			for (int i = 0; i < num; i++)
			{
				array[i + num3] = endValue.wps[i];
			}
			if (flag2)
			{
				array[array.Length - 1] = array[0];
			}
			endValue.wps = array;
			endValue.FinalizePath(t.plugOptions.isClosedPath, t.plugOptions.lockPositionAxis, vector);
			t.plugOptions.startupRot = transform.rotation;
			t.plugOptions.startupZRot = transform.eulerAngles.z;
			t.changeValue = t.endValue;
		}

		public override float GetSpeedBasedDuration(PathOptions options, float unitsXSecond, Path changeValue)
		{
			return changeValue.length / unitsXSecond;
		}

		public override void EvaluateAndApply(PathOptions options, Tween t, bool isRelative, DOGetter<Vector3> getter, DOSetter<Vector3> setter, float elapsed, Path startValue, Path changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental && !options.isClosedPath)
			{
				int num = t.isComplete ? (t.completedLoops - 1) : t.completedLoops;
				if (num > 0)
				{
					changeValue = changeValue.CloneIncremental(num);
				}
			}
			float perc = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			float num2 = changeValue.ConvertToConstantPathPerc(perc);
			Vector3 point = changeValue.GetPoint(num2, false);
			changeValue.targetPosition = point;
			setter(point);
			if (options.mode != PathMode.Ignore && options.orientType != OrientType.None)
			{
				this.SetOrientation(options, t, changeValue, num2, point, updateNotice);
			}
			bool flag = !usingInversePosition;
			if (t.isBackwards)
			{
				flag = !flag;
			}
			int waypointIndexFromPerc = changeValue.GetWaypointIndexFromPerc(perc, flag);
			if (waypointIndexFromPerc != t.miscInt)
			{
				int miscInt = t.miscInt;
				t.miscInt = waypointIndexFromPerc;
				if (t.onWaypointChange != null)
				{
					if (waypointIndexFromPerc < miscInt)
					{
						for (int i = miscInt - 1; i > waypointIndexFromPerc - 1; i--)
						{
							Tween.OnTweenCallback<int>(t.onWaypointChange, i);
						}
						return;
					}
					for (int j = miscInt + 1; j < waypointIndexFromPerc + 1; j++)
					{
						Tween.OnTweenCallback<int>(t.onWaypointChange, j);
					}
				}
			}
		}

		public void SetOrientation(PathOptions options, Tween t, Path path, float pathPerc, Vector3 tPos, UpdateNotice updateNotice)
		{
			Transform transform = ((Component)t.target).transform;
			Quaternion quaternion = Quaternion.identity;
			if (updateNotice == UpdateNotice.RewindStep)
			{
				transform.rotation = options.startupRot;
			}
			switch (options.orientType)
			{
			case OrientType.ToPath:
			{
				Vector3 vector;
				if (path.type == PathType.Linear && options.lookAhead <= 0.0001f)
				{
					vector = tPos + path.wps[path.linearWPIndex] - path.wps[path.linearWPIndex - 1];
				}
				else
				{
					float num = pathPerc + options.lookAhead;
					if (num > 1f)
					{
						num = (options.isClosedPath ? (num - 1f) : ((path.type == PathType.Linear) ? 1f : 1.00001f));
					}
					vector = path.GetPoint(num, false);
				}
				if (path.type == PathType.Linear)
				{
					Vector3 vector2 = path.wps[path.wps.Length - 1];
					if (vector == vector2)
					{
						vector = ((tPos == vector2) ? (vector2 + (vector2 - path.wps[path.wps.Length - 2])) : vector2);
					}
				}
				Vector3 upwards = transform.up;
				if (options.useLocalPosition && options.parent != null)
				{
					vector = options.parent.TransformPoint(vector);
				}
				if (options.lockRotationAxis != AxisConstraint.None)
				{
					if ((options.lockRotationAxis & AxisConstraint.X) == AxisConstraint.X)
					{
						Vector3 position = transform.InverseTransformPoint(vector);
						position.y = 0f;
						vector = transform.TransformPoint(position);
						upwards = ((options.useLocalPosition && options.parent != null) ? options.parent.up : Vector3.up);
					}
					if ((options.lockRotationAxis & AxisConstraint.Y) == AxisConstraint.Y)
					{
						Vector3 vector3 = transform.InverseTransformPoint(vector);
						if (vector3.z < 0f)
						{
							vector3.z = -vector3.z;
						}
						vector3.x = 0f;
						vector = transform.TransformPoint(vector3);
					}
					if ((options.lockRotationAxis & AxisConstraint.Z) == AxisConstraint.Z)
					{
						if (options.useLocalPosition && options.parent != null)
						{
							upwards = options.parent.TransformDirection(Vector3.up);
						}
						else
						{
							upwards = transform.TransformDirection(Vector3.up);
						}
						upwards.z = options.startupZRot;
					}
				}
				if (options.mode == PathMode.Full3D)
				{
					Vector3 vector4 = vector - transform.position;
					if (vector4 == Vector3.zero)
					{
						vector4 = transform.forward;
					}
					quaternion = Quaternion.LookRotation(vector4, upwards);
				}
				else
				{
					float y = 0f;
					float num2 = Utils.Angle2D(transform.position, vector);
					if (num2 < 0f)
					{
						num2 = 360f + num2;
					}
					if (options.mode == PathMode.Sidescroller2D)
					{
						y = (float)((vector.x < transform.position.x) ? 180 : 0);
						if (num2 > 90f && num2 < 270f)
						{
							num2 = 180f - num2;
						}
					}
					quaternion = Quaternion.Euler(0f, y, num2);
				}
				break;
			}
			case OrientType.LookAtTransform:
				if (options.lookAtTransform != null)
				{
					path.lookAtPosition = new Vector3?(options.lookAtTransform.position);
					quaternion = Quaternion.LookRotation(options.lookAtTransform.position - transform.position, transform.up);
				}
				break;
			case OrientType.LookAtPosition:
				path.lookAtPosition = new Vector3?(options.lookAtPosition);
				quaternion = Quaternion.LookRotation(options.lookAtPosition - transform.position, transform.up);
				break;
			}
			if (options.hasCustomForwardDirection)
			{
				quaternion *= options.forward;
			}
			if (options.isRigidbody)
			{
				((Rigidbody)t.target).rotation = quaternion;
				return;
			}
			transform.rotation = quaternion;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class ColorPlugin : ABSTweenPlugin<Color, Color, ColorOptions>
	{
		public override void Reset(TweenerCore<Color, Color, ColorOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Color, Color, ColorOptions> t, bool isRelative)
		{
			Color endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			Color pNewValue = t.endValue;
			if (!t.plugOptions.alphaOnly)
			{
				pNewValue = t.startValue;
			}
			else
			{
				pNewValue.a = t.startValue.a;
			}
			t.setter(pNewValue);
		}

		public override Color ConvertToStartValue(TweenerCore<Color, Color, ColorOptions> t, Color value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Color, Color, ColorOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Color, Color, ColorOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(ColorOptions options, float unitsXSecond, Color changeValue)
		{
			return 1f / unitsXSecond;
		}

		public override void EvaluateAndApply(ColorOptions options, Tween t, bool isRelative, DOGetter<Color> getter, DOSetter<Color> setter, float elapsed, Color startValue, Color changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			if (!options.alphaOnly)
			{
				startValue.r += changeValue.r * num;
				startValue.g += changeValue.g * num;
				startValue.b += changeValue.b * num;
				startValue.a += changeValue.a * num;
				setter(startValue);
				return;
			}
			Color pNewValue = getter();
			pNewValue.a = startValue.a + changeValue.a * num;
			setter(pNewValue);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	public class IntPlugin : ABSTweenPlugin<int, int, NoOptions>
	{
		public override void Reset(TweenerCore<int, int, NoOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<int, int, NoOptions> t, bool isRelative)
		{
			int endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			t.setter(t.startValue);
		}

		public override int ConvertToStartValue(TweenerCore<int, int, NoOptions> t, int value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<int, int, NoOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<int, int, NoOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(NoOptions options, float unitsXSecond, int changeValue)
		{
			float num = (float)changeValue / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(NoOptions options, Tween t, bool isRelative, DOGetter<int> getter, DOSetter<int> setter, float elapsed, int startValue, int changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * ((t.loopType == LoopType.Incremental) ? t.loops : 1) * (t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			setter((int)Math.Round((double)((float)startValue + (float)changeValue * EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod))));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class QuaternionPlugin : ABSTweenPlugin<Quaternion, Vector3, QuaternionOptions>
	{
		public override void Reset(TweenerCore<Quaternion, Vector3, QuaternionOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Quaternion, Vector3, QuaternionOptions> t, bool isRelative)
		{
			Vector3 endValue = t.endValue;
			t.endValue = t.getter().eulerAngles;
			if (t.plugOptions.rotateMode == RotateMode.Fast && !t.isRelative)
			{
				t.startValue = endValue;
			}
			else if (t.plugOptions.rotateMode == RotateMode.FastBeyond360)
			{
				t.startValue = t.endValue + endValue;
			}
			else
			{
				Quaternion quaternion = t.getter();
				if (t.plugOptions.rotateMode == RotateMode.WorldAxisAdd)
				{
					t.startValue = (quaternion * Quaternion.Inverse(quaternion) * Quaternion.Euler(endValue) * quaternion).eulerAngles;
				}
				else
				{
					t.startValue = (quaternion * Quaternion.Euler(endValue)).eulerAngles;
				}
				t.endValue = -endValue;
			}
			t.setter(Quaternion.Euler(t.startValue));
		}

		public override Vector3 ConvertToStartValue(TweenerCore<Quaternion, Vector3, QuaternionOptions> t, Quaternion value)
		{
			return value.eulerAngles;
		}

		public override void SetRelativeEndValue(TweenerCore<Quaternion, Vector3, QuaternionOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Quaternion, Vector3, QuaternionOptions> t)
		{
			if (t.plugOptions.rotateMode == RotateMode.Fast && !t.isRelative)
			{
				Vector3 endValue = t.endValue;
				if (endValue.x > 360f)
				{
					endValue.x %= 360f;
				}
				if (endValue.y > 360f)
				{
					endValue.y %= 360f;
				}
				if (endValue.z > 360f)
				{
					endValue.z %= 360f;
				}
				Vector3 vector = endValue - t.startValue;
				float num = (vector.x > 0f) ? vector.x : (-vector.x);
				if (num > 180f)
				{
					vector.x = ((vector.x > 0f) ? (-(360f - num)) : (360f - num));
				}
				num = ((vector.y > 0f) ? vector.y : (-vector.y));
				if (num > 180f)
				{
					vector.y = ((vector.y > 0f) ? (-(360f - num)) : (360f - num));
				}
				num = ((vector.z > 0f) ? vector.z : (-vector.z));
				if (num > 180f)
				{
					vector.z = ((vector.z > 0f) ? (-(360f - num)) : (360f - num));
				}
				t.changeValue = vector;
				return;
			}
			if (t.plugOptions.rotateMode == RotateMode.FastBeyond360 || t.isRelative)
			{
				t.changeValue = t.endValue - t.startValue;
				return;
			}
			t.changeValue = t.endValue;
		}

		public override float GetSpeedBasedDuration(QuaternionOptions options, float unitsXSecond, Vector3 changeValue)
		{
			return changeValue.magnitude / unitsXSecond;
		}

		public override void EvaluateAndApply(QuaternionOptions options, Tween t, bool isRelative, DOGetter<Quaternion> getter, DOSetter<Quaternion> setter, float elapsed, Vector3 startValue, Vector3 changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			Vector3 vector = startValue;
			if (t.loopType == LoopType.Incremental)
			{
				vector += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				vector += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			RotateMode rotateMode = options.rotateMode;
			if (rotateMode != RotateMode.WorldAxisAdd && rotateMode != RotateMode.LocalAxisAdd)
			{
				vector.x += changeValue.x * num;
				vector.y += changeValue.y * num;
				vector.z += changeValue.z * num;
				setter(Quaternion.Euler(vector));
				return;
			}
			Quaternion quaternion = Quaternion.Euler(startValue);
			vector.x = changeValue.x * num;
			vector.y = changeValue.y * num;
			vector.z = changeValue.z * num;
			if (options.rotateMode == RotateMode.WorldAxisAdd)
			{
				setter(quaternion * Quaternion.Inverse(quaternion) * Quaternion.Euler(vector) * quaternion);
				return;
			}
			setter(quaternion * Quaternion.Euler(vector));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class RectOffsetPlugin : ABSTweenPlugin<RectOffset, RectOffset, NoOptions>
	{
		private static RectOffset _r = new RectOffset();

		public override void Reset(TweenerCore<RectOffset, RectOffset, NoOptions> t)
		{
			t.startValue = (t.endValue = (t.changeValue = null));
		}

		public override void SetFrom(TweenerCore<RectOffset, RectOffset, NoOptions> t, bool isRelative)
		{
			RectOffset endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = endValue;
			if (isRelative)
			{
				t.startValue.left += t.endValue.left;
				t.startValue.right += t.endValue.right;
				t.startValue.top += t.endValue.top;
				t.startValue.bottom += t.endValue.bottom;
			}
			t.setter(t.startValue);
		}

		public override RectOffset ConvertToStartValue(TweenerCore<RectOffset, RectOffset, NoOptions> t, RectOffset value)
		{
			return new RectOffset(value.left, value.right, value.top, value.bottom);
		}

		public override void SetRelativeEndValue(TweenerCore<RectOffset, RectOffset, NoOptions> t)
		{
			t.endValue.left += t.startValue.left;
			t.endValue.right += t.startValue.right;
			t.endValue.top += t.startValue.top;
			t.endValue.bottom += t.startValue.bottom;
		}

		public override void SetChangeValue(TweenerCore<RectOffset, RectOffset, NoOptions> t)
		{
			t.changeValue = new RectOffset(t.endValue.left - t.startValue.left, t.endValue.right - t.startValue.right, t.endValue.top - t.startValue.top, t.endValue.bottom - t.startValue.bottom);
		}

		public override float GetSpeedBasedDuration(NoOptions options, float unitsXSecond, RectOffset changeValue)
		{
			float num = (float)changeValue.right;
			if (num < 0f)
			{
				num = -num;
			}
			float num2 = (float)changeValue.bottom;
			if (num2 < 0f)
			{
				num2 = -num2;
			}
			return (float)Math.Sqrt((double)(num * num + num2 * num2)) / unitsXSecond;
		}

		public override void EvaluateAndApply(NoOptions options, Tween t, bool isRelative, DOGetter<RectOffset> getter, DOSetter<RectOffset> setter, float elapsed, RectOffset startValue, RectOffset changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			RectOffsetPlugin._r.left = startValue.left;
			RectOffsetPlugin._r.right = startValue.right;
			RectOffsetPlugin._r.top = startValue.top;
			RectOffsetPlugin._r.bottom = startValue.bottom;
			if (t.loopType == LoopType.Incremental)
			{
				int num = t.isComplete ? (t.completedLoops - 1) : t.completedLoops;
				RectOffsetPlugin._r.left += changeValue.left * num;
				RectOffsetPlugin._r.right += changeValue.right * num;
				RectOffsetPlugin._r.top += changeValue.top * num;
				RectOffsetPlugin._r.bottom += changeValue.bottom * num;
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				int num2 = ((t.loopType == LoopType.Incremental) ? t.loops : 1) * (t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
				RectOffsetPlugin._r.left += changeValue.left * num2;
				RectOffsetPlugin._r.right += changeValue.right * num2;
				RectOffsetPlugin._r.top += changeValue.top * num2;
				RectOffsetPlugin._r.bottom += changeValue.bottom * num2;
			}
			float num3 = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			setter(new RectOffset((int)Math.Round((double)((float)RectOffsetPlugin._r.left + (float)changeValue.left * num3)), (int)Math.Round((double)((float)RectOffsetPlugin._r.right + (float)changeValue.right * num3)), (int)Math.Round((double)((float)RectOffsetPlugin._r.top + (float)changeValue.top * num3)), (int)Math.Round((double)((float)RectOffsetPlugin._r.bottom + (float)changeValue.bottom * num3))));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class RectPlugin : ABSTweenPlugin<Rect, Rect, RectOptions>
	{
		public override void Reset(TweenerCore<Rect, Rect, RectOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Rect, Rect, RectOptions> t, bool isRelative)
		{
			Rect endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = endValue;
			if (isRelative)
			{
				t.startValue.x = t.startValue.x + t.endValue.x;
				t.startValue.y = t.startValue.y + t.endValue.y;
				t.startValue.width = t.startValue.width + t.endValue.width;
				t.startValue.height = t.startValue.height + t.endValue.height;
			}
			Rect startValue = t.startValue;
			if (t.plugOptions.snapping)
			{
				startValue.x = (float)Math.Round((double)startValue.x);
				startValue.y = (float)Math.Round((double)startValue.y);
				startValue.width = (float)Math.Round((double)startValue.width);
				startValue.height = (float)Math.Round((double)startValue.height);
			}
			t.setter(startValue);
		}

		public override Rect ConvertToStartValue(TweenerCore<Rect, Rect, RectOptions> t, Rect value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Rect, Rect, RectOptions> t)
		{
			t.endValue.x = t.endValue.x + t.startValue.x;
			t.endValue.y = t.endValue.y + t.startValue.y;
			t.endValue.width = t.endValue.width + t.startValue.width;
			t.endValue.height = t.endValue.height + t.startValue.height;
		}

		public override void SetChangeValue(TweenerCore<Rect, Rect, RectOptions> t)
		{
			t.changeValue = new Rect(t.endValue.x - t.startValue.x, t.endValue.y - t.startValue.y, t.endValue.width - t.startValue.width, t.endValue.height - t.startValue.height);
		}

		public override float GetSpeedBasedDuration(RectOptions options, float unitsXSecond, Rect changeValue)
		{
			float arg_0F_0 = changeValue.width;
			float height = changeValue.height;
			return (float)Math.Sqrt((double)(arg_0F_0 * arg_0F_0 + height * height)) / unitsXSecond;
		}

		public override void EvaluateAndApply(RectOptions options, Tween t, bool isRelative, DOGetter<Rect> getter, DOSetter<Rect> setter, float elapsed, Rect startValue, Rect changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				int num = t.isComplete ? (t.completedLoops - 1) : t.completedLoops;
				startValue.x += changeValue.x * (float)num;
				startValue.y += changeValue.y * (float)num;
				startValue.width += changeValue.width * (float)num;
				startValue.height += changeValue.height * (float)num;
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				int num2 = ((t.loopType == LoopType.Incremental) ? t.loops : 1) * (t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
				startValue.x += changeValue.x * (float)num2;
				startValue.y += changeValue.y * (float)num2;
				startValue.width += changeValue.width * (float)num2;
				startValue.height += changeValue.height * (float)num2;
			}
			float num3 = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			startValue.x += changeValue.x * num3;
			startValue.y += changeValue.y * num3;
			startValue.width += changeValue.width * num3;
			startValue.height += changeValue.height * num3;
			if (options.snapping)
			{
				startValue.x = (float)Math.Round((double)startValue.x);
				startValue.y = (float)Math.Round((double)startValue.y);
				startValue.width = (float)Math.Round((double)startValue.width);
				startValue.height = (float)Math.Round((double)startValue.height);
			}
			setter(startValue);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	public class UintPlugin : ABSTweenPlugin<uint, uint, UintOptions>
	{
		public override void Reset(TweenerCore<uint, uint, UintOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<uint, uint, UintOptions> t, bool isRelative)
		{
			uint endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			t.setter(t.startValue);
		}

		public override uint ConvertToStartValue(TweenerCore<uint, uint, UintOptions> t, uint value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<uint, uint, UintOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<uint, uint, UintOptions> t)
		{
			t.plugOptions.isNegativeChangeValue = (t.endValue < t.startValue);
			t.changeValue = (t.plugOptions.isNegativeChangeValue ? (t.startValue - t.endValue) : (t.endValue - t.startValue));
		}

		public override float GetSpeedBasedDuration(UintOptions options, float unitsXSecond, uint changeValue)
		{
			float num = changeValue / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(UintOptions options, Tween t, bool isRelative, DOGetter<uint> getter, DOSetter<uint> setter, float elapsed, uint startValue, uint changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			uint num;
			if (t.loopType == LoopType.Incremental)
			{
				num = (uint)((ulong)changeValue * (ulong)((long)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops)));
				if (options.isNegativeChangeValue)
				{
					startValue -= num;
				}
				else
				{
					startValue += num;
				}
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				num = (uint)((ulong)changeValue * (ulong)((long)((t.loopType == LoopType.Incremental) ? t.loops : 1)) * (ulong)((long)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops)));
				if (options.isNegativeChangeValue)
				{
					startValue -= num;
				}
				else
				{
					startValue += num;
				}
			}
			num = (uint)Math.Round((double)(changeValue * EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod)));
			if (options.isNegativeChangeValue)
			{
				setter(startValue - num);
				return;
			}
			setter(startValue + num);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class Vector2Plugin : ABSTweenPlugin<Vector2, Vector2, VectorOptions>
	{
		public override void Reset(TweenerCore<Vector2, Vector2, VectorOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Vector2, Vector2, VectorOptions> t, bool isRelative)
		{
			Vector2 endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			Vector2 vector = t.endValue;
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint != AxisConstraint.X)
			{
				if (axisConstraint != AxisConstraint.Y)
				{
					vector = t.startValue;
				}
				else
				{
					vector.y = t.startValue.y;
				}
			}
			else
			{
				vector.x = t.startValue.x;
			}
			if (t.plugOptions.snapping)
			{
				vector.x = (float)Math.Round((double)vector.x);
				vector.y = (float)Math.Round((double)vector.y);
			}
			t.setter(vector);
		}

		public override Vector2 ConvertToStartValue(TweenerCore<Vector2, Vector2, VectorOptions> t, Vector2 value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Vector2, Vector2, VectorOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Vector2, Vector2, VectorOptions> t)
		{
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint == AxisConstraint.X)
			{
				t.changeValue = new Vector2(t.endValue.x - t.startValue.x, 0f);
				return;
			}
			if (axisConstraint != AxisConstraint.Y)
			{
				t.changeValue = t.endValue - t.startValue;
				return;
			}
			t.changeValue = new Vector2(0f, t.endValue.y - t.startValue.y);
		}

		public override float GetSpeedBasedDuration(VectorOptions options, float unitsXSecond, Vector2 changeValue)
		{
			return changeValue.magnitude / unitsXSecond;
		}

		public override void EvaluateAndApply(VectorOptions options, Tween t, bool isRelative, DOGetter<Vector2> getter, DOSetter<Vector2> setter, float elapsed, Vector2 startValue, Vector2 changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			AxisConstraint axisConstraint = options.axisConstraint;
			if (axisConstraint == AxisConstraint.X)
			{
				Vector2 vector = getter();
				vector.x = startValue.x + changeValue.x * num;
				if (options.snapping)
				{
					vector.x = (float)Math.Round((double)vector.x);
				}
				setter(vector);
				return;
			}
			if (axisConstraint != AxisConstraint.Y)
			{
				startValue.x += changeValue.x * num;
				startValue.y += changeValue.y * num;
				if (options.snapping)
				{
					startValue.x = (float)Math.Round((double)startValue.x);
					startValue.y = (float)Math.Round((double)startValue.y);
				}
				setter(startValue);
				return;
			}
			Vector2 vector2 = getter();
			vector2.y = startValue.y + changeValue.y * num;
			if (options.snapping)
			{
				vector2.y = (float)Math.Round((double)vector2.y);
			}
			setter(vector2);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class Vector4Plugin : ABSTweenPlugin<Vector4, Vector4, VectorOptions>
	{
		public override void Reset(TweenerCore<Vector4, Vector4, VectorOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Vector4, Vector4, VectorOptions> t, bool isRelative)
		{
			Vector4 endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			Vector4 vector = t.endValue;
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint <= AxisConstraint.Y)
			{
				if (axisConstraint == AxisConstraint.X)
				{
					vector.x = t.startValue.x;
					goto IL_B3;
				}
				if (axisConstraint == AxisConstraint.Y)
				{
					vector.y = t.startValue.y;
					goto IL_B3;
				}
			}
			else
			{
				if (axisConstraint == AxisConstraint.Z)
				{
					vector.z = t.startValue.z;
					goto IL_B3;
				}
				if (axisConstraint == AxisConstraint.W)
				{
					vector.w = t.startValue.w;
					goto IL_B3;
				}
			}
			vector = t.startValue;
			IL_B3:
			if (t.plugOptions.snapping)
			{
				vector.x = (float)Math.Round((double)vector.x);
				vector.y = (float)Math.Round((double)vector.y);
				vector.z = (float)Math.Round((double)vector.z);
				vector.w = (float)Math.Round((double)vector.w);
			}
			t.setter(vector);
		}

		public override Vector4 ConvertToStartValue(TweenerCore<Vector4, Vector4, VectorOptions> t, Vector4 value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Vector4, Vector4, VectorOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Vector4, Vector4, VectorOptions> t)
		{
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint <= AxisConstraint.Y)
			{
				if (axisConstraint == AxisConstraint.X)
				{
					t.changeValue = new Vector4(t.endValue.x - t.startValue.x, 0f, 0f, 0f);
					return;
				}
				if (axisConstraint == AxisConstraint.Y)
				{
					t.changeValue = new Vector4(0f, t.endValue.y - t.startValue.y, 0f, 0f);
					return;
				}
			}
			else
			{
				if (axisConstraint == AxisConstraint.Z)
				{
					t.changeValue = new Vector4(0f, 0f, t.endValue.z - t.startValue.z, 0f);
					return;
				}
				if (axisConstraint == AxisConstraint.W)
				{
					t.changeValue = new Vector4(0f, 0f, 0f, t.endValue.w - t.startValue.w);
					return;
				}
			}
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(VectorOptions options, float unitsXSecond, Vector4 changeValue)
		{
			return changeValue.magnitude / unitsXSecond;
		}

		public override void EvaluateAndApply(VectorOptions options, Tween t, bool isRelative, DOGetter<Vector4> getter, DOSetter<Vector4> setter, float elapsed, Vector4 startValue, Vector4 changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			AxisConstraint axisConstraint = options.axisConstraint;
			if (axisConstraint <= AxisConstraint.Y)
			{
				if (axisConstraint == AxisConstraint.X)
				{
					Vector4 vector = getter();
					vector.x = startValue.x + changeValue.x * num;
					if (options.snapping)
					{
						vector.x = (float)Math.Round((double)vector.x);
					}
					setter(vector);
					return;
				}
				if (axisConstraint == AxisConstraint.Y)
				{
					Vector4 vector2 = getter();
					vector2.y = startValue.y + changeValue.y * num;
					if (options.snapping)
					{
						vector2.y = (float)Math.Round((double)vector2.y);
					}
					setter(vector2);
					return;
				}
			}
			else
			{
				if (axisConstraint == AxisConstraint.Z)
				{
					Vector4 vector3 = getter();
					vector3.z = startValue.z + changeValue.z * num;
					if (options.snapping)
					{
						vector3.z = (float)Math.Round((double)vector3.z);
					}
					setter(vector3);
					return;
				}
				if (axisConstraint == AxisConstraint.W)
				{
					Vector4 vector4 = getter();
					vector4.w = startValue.w + changeValue.w * num;
					if (options.snapping)
					{
						vector4.w = (float)Math.Round((double)vector4.w);
					}
					setter(vector4);
					return;
				}
			}
			startValue.x += changeValue.x * num;
			startValue.y += changeValue.y * num;
			startValue.z += changeValue.z * num;
			startValue.w += changeValue.w * num;
			if (options.snapping)
			{
				startValue.x = (float)Math.Round((double)startValue.x);
				startValue.y = (float)Math.Round((double)startValue.y);
				startValue.z = (float)Math.Round((double)startValue.z);
				startValue.w = (float)Math.Round((double)startValue.w);
			}
			setter(startValue);
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace DG.Tweening.Plugins
{
	public class StringPlugin : ABSTweenPlugin<string, string, StringOptions>
	{
		private static readonly StringBuilder _Buffer = new StringBuilder();

		private static readonly List<char> _OpenedTags = new List<char>();

		public override void SetFrom(TweenerCore<string, string, StringOptions> t, bool isRelative)
		{
			string endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = endValue;
			t.setter(t.startValue);
		}

		public override void Reset(TweenerCore<string, string, StringOptions> t)
		{
			t.startValue = (t.endValue = (t.changeValue = null));
		}

		public override string ConvertToStartValue(TweenerCore<string, string, StringOptions> t, string value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<string, string, StringOptions> t)
		{
		}

		public override void SetChangeValue(TweenerCore<string, string, StringOptions> t)
		{
			t.changeValue = t.endValue;
			t.plugOptions.startValueStrippedLength = Regex.Replace(t.startValue, "<[^>]*>", "").Length;
			t.plugOptions.changeValueStrippedLength = Regex.Replace(t.changeValue, "<[^>]*>", "").Length;
		}

		public override float GetSpeedBasedDuration(StringOptions options, float unitsXSecond, string changeValue)
		{
			float num = (float)(options.richTextEnabled ? options.changeValueStrippedLength : changeValue.Length) / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(StringOptions options, Tween t, bool isRelative, DOGetter<string> getter, DOSetter<string> setter, float elapsed, string startValue, string changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			StringPlugin._Buffer.Remove(0, StringPlugin._Buffer.Length);
			if (isRelative && t.loopType == LoopType.Incremental)
			{
				int num = t.isComplete ? (t.completedLoops - 1) : t.completedLoops;
				if (num > 0)
				{
					StringPlugin._Buffer.Append(startValue);
					for (int i = 0; i < num; i++)
					{
						StringPlugin._Buffer.Append(changeValue);
					}
					startValue = StringPlugin._Buffer.ToString();
					StringPlugin._Buffer.Remove(0, StringPlugin._Buffer.Length);
				}
			}
			int num2 = options.richTextEnabled ? options.startValueStrippedLength : startValue.Length;
			int num3 = options.richTextEnabled ? options.changeValueStrippedLength : changeValue.Length;
			int num4 = (int)Math.Round((double)((float)num3 * EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod)));
			if (num4 > num3)
			{
				num4 = num3;
			}
			else if (num4 < 0)
			{
				num4 = 0;
			}
			if (isRelative)
			{
				StringPlugin._Buffer.Append(startValue);
				if (options.scrambleMode != ScrambleMode.None)
				{
					setter(this.Append(changeValue, 0, num4, options.richTextEnabled).AppendScrambledChars(num3 - num4, this.ScrambledCharsToUse(options)).ToString());
					return;
				}
				setter(this.Append(changeValue, 0, num4, options.richTextEnabled).ToString());
				return;
			}
			else
			{
				if (options.scrambleMode != ScrambleMode.None)
				{
					setter(this.Append(changeValue, 0, num4, options.richTextEnabled).AppendScrambledChars(num3 - num4, this.ScrambledCharsToUse(options)).ToString());
					return;
				}
				int arg_193_0 = num2 - num3;
				int num5 = num2;
				if (arg_193_0 > 0)
				{
					float num6 = (float)num4 / (float)num3;
					num5 -= (int)((float)num5 * num6);
				}
				else
				{
					num5 -= num4;
				}
				this.Append(changeValue, 0, num4, options.richTextEnabled);
				if (num4 < num3 && num4 < num2)
				{
					this.Append(startValue, num4, options.richTextEnabled ? (num4 + num5) : num5, options.richTextEnabled);
				}
				setter(StringPlugin._Buffer.ToString());
				return;
			}
		}

		private StringBuilder Append(string value, int startIndex, int length, bool richTextEnabled)
		{
			if (!richTextEnabled)
			{
				StringPlugin._Buffer.Append(value, startIndex, length);
				return StringPlugin._Buffer;
			}
			StringPlugin._OpenedTags.Clear();
			bool flag = false;
			int length2 = value.Length;
			int i;
			for (i = 0; i < length; i++)
			{
				char c = value[i];
				if (c == '<')
				{
					bool flag2 = flag;
					char c2 = value[i + 1];
					flag = (i >= length2 - 1 || c2 != '/');
					if (flag)
					{
						StringPlugin._OpenedTags.Add((c2 == '#') ? 'c' : c2);
					}
					else
					{
						StringPlugin._OpenedTags.RemoveAt(StringPlugin._OpenedTags.Count - 1);
					}
					Match match = Regex.Match(value.Substring(i), "<.*?(>)");
					if (match.Success)
					{
						if (!flag && !flag2)
						{
							char c3 = value[i + 1];
							char[] array;
							if (c3 == 'c')
							{
								array = new char[]
								{
									'#',
									'c'
								};
							}
							else
							{
								array = new char[]
								{
									c3
								};
							}
							for (int j = i - 1; j > -1; j--)
							{
								if (value[j] == '<' && value[j + 1] != '/' && Array.IndexOf<char>(array, value[j + 2]) != -1)
								{
									StringPlugin._Buffer.Insert(0, value.Substring(j, value.IndexOf('>', j) + 1 - j));
									break;
								}
							}
						}
						StringPlugin._Buffer.Append(match.Value);
						int num = match.Groups[1].Index + 1;
						length += num;
						startIndex += num;
						i += num - 1;
					}
				}
				else if (i >= startIndex)
				{
					StringPlugin._Buffer.Append(c);
				}
			}
			if (StringPlugin._OpenedTags.Count > 0 && i < length2 - 1)
			{
				while (StringPlugin._OpenedTags.Count > 0 && i < length2 - 1)
				{
					Match match2 = Regex.Match(value.Substring(i), "(</).*?>");
					if (!match2.Success)
					{
						break;
					}
					if (match2.Value[2] == StringPlugin._OpenedTags[StringPlugin._OpenedTags.Count - 1])
					{
						StringPlugin._Buffer.Append(match2.Value);
						StringPlugin._OpenedTags.RemoveAt(StringPlugin._OpenedTags.Count - 1);
					}
					i += match2.Value.Length;
				}
			}
			return StringPlugin._Buffer;
		}

		private char[] ScrambledCharsToUse(StringOptions options)
		{
			switch (options.scrambleMode)
			{
			case ScrambleMode.Uppercase:
				return StringPluginExtensions.ScrambledCharsUppercase;
			case ScrambleMode.Lowercase:
				return StringPluginExtensions.ScrambledCharsLowercase;
			case ScrambleMode.Numerals:
				return StringPluginExtensions.ScrambledCharsNumerals;
			case ScrambleMode.Custom:
				return options.scrambledChars;
			default:
				return StringPluginExtensions.ScrambledCharsAll;
			}
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using System.Text;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	internal static class StringPluginExtensions
	{
		public static readonly char[] ScrambledCharsAll;

		public static readonly char[] ScrambledCharsUppercase;

		public static readonly char[] ScrambledCharsLowercase;

		public static readonly char[] ScrambledCharsNumerals;

		private static int _lastRndSeed;

		static StringPluginExtensions()
		{
			StringPluginExtensions.ScrambledCharsAll = new char[]
			{
				'A',
				'B',
				'C',
				'D',
				'E',
				'F',
				'G',
				'H',
				'I',
				'J',
				'K',
				'L',
				'M',
				'N',
				'O',
				'P',
				'Q',
				'R',
				'S',
				'T',
				'U',
				'V',
				'X',
				'Y',
				'Z',
				'a',
				'b',
				'c',
				'd',
				'e',
				'f',
				'g',
				'h',
				'i',
				'j',
				'k',
				'l',
				'm',
				'n',
				'o',
				'p',
				'q',
				'r',
				's',
				't',
				'u',
				'v',
				'x',
				'y',
				'z',
				'1',
				'2',
				'3',
				'4',
				'5',
				'6',
				'7',
				'8',
				'9',
				'0'
			};
			StringPluginExtensions.ScrambledCharsUppercase = new char[]
			{
				'A',
				'B',
				'C',
				'D',
				'E',
				'F',
				'G',
				'H',
				'I',
				'J',
				'K',
				'L',
				'M',
				'N',
				'O',
				'P',
				'Q',
				'R',
				'S',
				'T',
				'U',
				'V',
				'X',
				'Y',
				'Z'
			};
			StringPluginExtensions.ScrambledCharsLowercase = new char[]
			{
				'a',
				'b',
				'c',
				'd',
				'e',
				'f',
				'g',
				'h',
				'i',
				'j',
				'k',
				'l',
				'm',
				'n',
				'o',
				'p',
				'q',
				'r',
				's',
				't',
				'u',
				'v',
				'x',
				'y',
				'z'
			};
			StringPluginExtensions.ScrambledCharsNumerals = new char[]
			{
				'1',
				'2',
				'3',
				'4',
				'5',
				'6',
				'7',
				'8',
				'9',
				'0'
			};
			StringPluginExtensions.ScrambledCharsAll.ScrambleChars();
			StringPluginExtensions.ScrambledCharsUppercase.ScrambleChars();
			StringPluginExtensions.ScrambledCharsLowercase.ScrambleChars();
			StringPluginExtensions.ScrambledCharsNumerals.ScrambleChars();
		}

		internal static void ScrambleChars(this char[] chars)
		{
			int num = chars.Length;
			for (int i = 0; i < num; i++)
			{
				char c = chars[i];
				int num2 = Random.Range(i, num);
				chars[i] = chars[num2];
				chars[num2] = c;
			}
		}

		internal static StringBuilder AppendScrambledChars(this StringBuilder buffer, int length, char[] chars)
		{
			if (length <= 0)
			{
				return buffer;
			}
			int num = chars.Length;
			int num2;
			for (num2 = StringPluginExtensions._lastRndSeed; num2 == StringPluginExtensions._lastRndSeed; num2 = Random.Range(0, num))
			{
			}
			StringPluginExtensions._lastRndSeed = num2;
			for (int i = 0; i < length; i++)
			{
				if (num2 >= num)
				{
					num2 = 0;
				}
				buffer.Append(chars[num2]);
				num2++;
			}
			return buffer;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins
{
	public class FloatPlugin : ABSTweenPlugin<float, float, FloatOptions>
	{
		public override void Reset(TweenerCore<float, float, FloatOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<float, float, FloatOptions> t, bool isRelative)
		{
			float endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			t.setter((!t.plugOptions.snapping) ? t.startValue : ((float)Math.Round((double)t.startValue)));
		}

		public override float ConvertToStartValue(TweenerCore<float, float, FloatOptions> t, float value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<float, float, FloatOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<float, float, FloatOptions> t)
		{
			t.changeValue = t.endValue - t.startValue;
		}

		public override float GetSpeedBasedDuration(FloatOptions options, float unitsXSecond, float changeValue)
		{
			float num = changeValue / unitsXSecond;
			if (num < 0f)
			{
				num = -num;
			}
			return num;
		}

		public override void EvaluateAndApply(FloatOptions options, Tween t, bool isRelative, DOGetter<float> getter, DOSetter<float> setter, float elapsed, float startValue, float changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			setter((!options.snapping) ? (startValue + changeValue * EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod)) : ((float)Math.Round((double)(startValue + changeValue * EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod)))));
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins
{
	public class Vector3Plugin : ABSTweenPlugin<Vector3, Vector3, VectorOptions>
	{
		public override void Reset(TweenerCore<Vector3, Vector3, VectorOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Vector3, Vector3, VectorOptions> t, bool isRelative)
		{
			Vector3 endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue + endValue) : endValue);
			Vector3 vector = t.endValue;
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint != AxisConstraint.X)
			{
				if (axisConstraint != AxisConstraint.Y)
				{
					if (axisConstraint != AxisConstraint.Z)
					{
						vector = t.startValue;
					}
					else
					{
						vector.z = t.startValue.z;
					}
				}
				else
				{
					vector.y = t.startValue.y;
				}
			}
			else
			{
				vector.x = t.startValue.x;
			}
			if (t.plugOptions.snapping)
			{
				vector.x = (float)Math.Round((double)vector.x);
				vector.y = (float)Math.Round((double)vector.y);
				vector.z = (float)Math.Round((double)vector.z);
			}
			t.setter(vector);
		}

		public override Vector3 ConvertToStartValue(TweenerCore<Vector3, Vector3, VectorOptions> t, Vector3 value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Vector3, Vector3, VectorOptions> t)
		{
			t.endValue += t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Vector3, Vector3, VectorOptions> t)
		{
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint == AxisConstraint.X)
			{
				t.changeValue = new Vector3(t.endValue.x - t.startValue.x, 0f, 0f);
				return;
			}
			if (axisConstraint == AxisConstraint.Y)
			{
				t.changeValue = new Vector3(0f, t.endValue.y - t.startValue.y, 0f);
				return;
			}
			if (axisConstraint != AxisConstraint.Z)
			{
				t.changeValue = t.endValue - t.startValue;
				return;
			}
			t.changeValue = new Vector3(0f, 0f, t.endValue.z - t.startValue.z);
		}

		public override float GetSpeedBasedDuration(VectorOptions options, float unitsXSecond, Vector3 changeValue)
		{
			return changeValue.magnitude / unitsXSecond;
		}

		public override void EvaluateAndApply(VectorOptions options, Tween t, bool isRelative, DOGetter<Vector3> getter, DOSetter<Vector3> setter, float elapsed, Vector3 startValue, Vector3 changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			if (t.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)(t.isComplete ? (t.completedLoops - 1) : t.completedLoops);
			}
			if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental)
			{
				startValue += changeValue * (float)((t.loopType == LoopType.Incremental) ? t.loops : 1) * (float)(t.sequenceParent.isComplete ? (t.sequenceParent.completedLoops - 1) : t.sequenceParent.completedLoops);
			}
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			AxisConstraint axisConstraint = options.axisConstraint;
			if (axisConstraint == AxisConstraint.X)
			{
				Vector3 vector = getter();
				vector.x = startValue.x + changeValue.x * num;
				if (options.snapping)
				{
					vector.x = (float)Math.Round((double)vector.x);
				}
				setter(vector);
				return;
			}
			if (axisConstraint == AxisConstraint.Y)
			{
				Vector3 vector2 = getter();
				vector2.y = startValue.y + changeValue.y * num;
				if (options.snapping)
				{
					vector2.y = (float)Math.Round((double)vector2.y);
				}
				setter(vector2);
				return;
			}
			if (axisConstraint != AxisConstraint.Z)
			{
				startValue.x += changeValue.x * num;
				startValue.y += changeValue.y * num;
				startValue.z += changeValue.z * num;
				if (options.snapping)
				{
					startValue.x = (float)Math.Round((double)startValue.x);
					startValue.y = (float)Math.Round((double)startValue.y);
					startValue.z = (float)Math.Round((double)startValue.z);
				}
				setter(startValue);
				return;
			}
			Vector3 vector3 = getter();
			vector3.z = startValue.z + changeValue.z * num;
			if (options.snapping)
			{
				vector3.z = (float)Math.Round((double)vector3.z);
			}
			setter(vector3);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public interface IPlugOptions
	{
		void Reset();
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public enum OrientType
	{
		None,
		ToPath,
		LookAtTransform,
		LookAtPosition
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Options
{
	public struct PathOptions : IPlugOptions
	{
		public PathMode mode;

		public OrientType orientType;

		public AxisConstraint lockPositionAxis;

		public AxisConstraint lockRotationAxis;

		public bool isClosedPath;

		public Vector3 lookAtPosition;

		public Transform lookAtTransform;

		public float lookAhead;

		public bool hasCustomForwardDirection;

		public Quaternion forward;

		public bool useLocalPosition;

		public Transform parent;

		public bool isRigidbody;

		internal Quaternion startupRot;

		internal float startupZRot;

		public void Reset()
		{
			this.mode = PathMode.Ignore;
			this.orientType = OrientType.None;
			this.lockPositionAxis = (this.lockRotationAxis = AxisConstraint.None);
			this.isClosedPath = false;
			this.lookAtPosition = Vector3.zero;
			this.lookAtTransform = null;
			this.lookAhead = 0f;
			this.hasCustomForwardDirection = false;
			this.forward = Quaternion.identity;
			this.useLocalPosition = false;
			this.parent = null;
			this.startupRot = Quaternion.identity;
			this.startupZRot = 0f;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Options
{
	public struct QuaternionOptions : IPlugOptions
	{
		internal RotateMode rotateMode;

		internal AxisConstraint axisConstraint;

		internal Vector3 up;

		public void Reset()
		{
			this.rotateMode = RotateMode.Fast;
			this.axisConstraint = AxisConstraint.None;
			this.up = Vector3.zero;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct UintOptions : IPlugOptions
	{
		public bool isNegativeChangeValue;

		public void Reset()
		{
			this.isNegativeChangeValue = false;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct Vector3ArrayOptions : IPlugOptions
	{
		public AxisConstraint axisConstraint;

		public bool snapping;

		internal float[] durations;

		public void Reset()
		{
			this.axisConstraint = AxisConstraint.None;
			this.snapping = false;
			this.durations = null;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using System.Runtime.InteropServices;

namespace DG.Tweening.Plugins.Options
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct NoOptions : IPlugOptions
	{
		public void Reset()
		{
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct ColorOptions : IPlugOptions
	{
		public bool alphaOnly;

		public void Reset()
		{
			this.alphaOnly = false;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct FloatOptions : IPlugOptions
	{
		public bool snapping;

		public void Reset()
		{
			this.snapping = false;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct RectOptions : IPlugOptions
	{
		public bool snapping;

		public void Reset()
		{
			this.snapping = false;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct StringOptions : IPlugOptions
	{
		public bool richTextEnabled;

		public ScrambleMode scrambleMode;

		public char[] scrambledChars;

		internal int startValueStrippedLength;

		internal int changeValueStrippedLength;

		public void Reset()
		{
			this.richTextEnabled = false;
			this.scrambleMode = ScrambleMode.None;
			this.scrambledChars = null;
			this.startValueStrippedLength = (this.changeValueStrippedLength = 0);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Options
{
	public struct VectorOptions : IPlugOptions
	{
		public AxisConstraint axisConstraint;

		public bool snapping;

		public void Reset()
		{
			this.axisConstraint = AxisConstraint.None;
			this.snapping = false;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Core
{
	public interface ITPlugin<T1, out T2, out TPlugOptions, TPlugin>
	{
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Core
{
	internal static class SpecialPluginsUtils
	{
		internal static bool SetLookAt(TweenerCore<Quaternion, Vector3, QuaternionOptions> t)
		{
			Transform transform = t.target as Transform;
			Vector3 vector = t.endValue;
			vector -= transform.position;
			AxisConstraint axisConstraint = t.plugOptions.axisConstraint;
			if (axisConstraint != AxisConstraint.X)
			{
				if (axisConstraint != AxisConstraint.Y)
				{
					if (axisConstraint == AxisConstraint.Z)
					{
						vector.z = 0f;
					}
				}
				else
				{
					vector.y = 0f;
				}
			}
			else
			{
				vector.x = 0f;
			}
			Vector3 eulerAngles = Quaternion.LookRotation(vector, t.plugOptions.up).eulerAngles;
			t.endValue = eulerAngles;
			return true;
		}

		internal static bool SetPunch(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t)
		{
			Vector3 b;
			try
			{
				b = t.getter();
			}
			catch
			{
				return false;
			}
			t.isRelative = (t.isSpeedBased = false);
			t.easeType = Ease.OutQuad;
			t.customEase = null;
			int num = t.endValue.Length;
			for (int i = 0; i < num; i++)
			{
				t.endValue[i] = t.endValue[i] + b;
			}
			return true;
		}

		internal static bool SetShake(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t)
		{
			if (!SpecialPluginsUtils.SetPunch(t))
			{
				return false;
			}
			t.easeType = Ease.Linear;
			return true;
		}

		internal static bool SetCameraShakePosition(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions> t)
		{
			if (!SpecialPluginsUtils.SetShake(t))
			{
				return false;
			}
			Camera camera = t.target as Camera;
			if (camera == null)
			{
				return false;
			}
			Vector3 b = t.getter();
			Transform transform = camera.transform;
			int num = t.endValue.Length;
			for (int i = 0; i < num; i++)
			{
				Vector3 a = t.endValue[i];
				t.endValue[i] = transform.localRotation * (a - b) + b;
			}
			return true;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using System;

namespace DG.Tweening.Plugins.Core
{
	public interface IPlugSetter<T1, out T2, TPlugin, out TPlugOptions>
	{
		DOGetter<T1> Getter();

		DOSetter<T1> Setter();

		T2 EndValue();

		TPlugOptions GetOptions();
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Plugins.Core
{
	public interface ITweenPlugin
	{
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Plugins.Core
{
	public abstract class ABSTweenPlugin<T1, T2, TPlugOptions> : ITweenPlugin where TPlugOptions : struct, IPlugOptions
	{
		public abstract void Reset(TweenerCore<T1, T2, TPlugOptions> t);

		public abstract void SetFrom(TweenerCore<T1, T2, TPlugOptions> t, bool isRelative);

		public abstract T2 ConvertToStartValue(TweenerCore<T1, T2, TPlugOptions> t, T1 value);

		public abstract void SetRelativeEndValue(TweenerCore<T1, T2, TPlugOptions> t);

		public abstract void SetChangeValue(TweenerCore<T1, T2, TPlugOptions> t);

		public abstract float GetSpeedBasedDuration(TPlugOptions options, float unitsXSecond, T2 changeValue);

		public abstract void EvaluateAndApply(TPlugOptions options, Tween t, bool isRelative, DOGetter<T1> getter, DOSetter<T1> setter, float elapsed, T2 startValue, T2 changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice);
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace DG.Tweening.Plugins.Core
{
	internal static class PluginsManager
	{
		private static ITweenPlugin _floatPlugin;

		private static ITweenPlugin _doublePlugin;

		private static ITweenPlugin _intPlugin;

		private static ITweenPlugin _uintPlugin;

		private static ITweenPlugin _longPlugin;

		private static ITweenPlugin _ulongPlugin;

		private static ITweenPlugin _vector2Plugin;

		private static ITweenPlugin _vector3Plugin;

		private static ITweenPlugin _vector4Plugin;

		private static ITweenPlugin _quaternionPlugin;

		private static ITweenPlugin _colorPlugin;

		private static ITweenPlugin _rectPlugin;

		private static ITweenPlugin _rectOffsetPlugin;

		private static ITweenPlugin _stringPlugin;

		private static ITweenPlugin _vector3ArrayPlugin;

		private static ITweenPlugin _color2Plugin;

		private const int _MaxCustomPlugins = 20;

		private static Dictionary<Type, ITweenPlugin> _customPlugins;

		internal static ABSTweenPlugin<T1, T2, TPlugOptions> GetDefaultPlugin<T1, T2, TPlugOptions>() where TPlugOptions : struct, IPlugOptions
		{
			Type typeFromHandle = typeof(T1);
			Type typeFromHandle2 = typeof(T2);
			ITweenPlugin tweenPlugin = null;
			if (typeFromHandle == typeof(Vector3) && typeFromHandle == typeFromHandle2)
			{
				if (PluginsManager._vector3Plugin == null)
				{
					PluginsManager._vector3Plugin = new Vector3Plugin();
				}
				tweenPlugin = PluginsManager._vector3Plugin;
			}
			else if (typeFromHandle == typeof(Vector3) && typeFromHandle2 == typeof(Vector3[]))
			{
				if (PluginsManager._vector3ArrayPlugin == null)
				{
					PluginsManager._vector3ArrayPlugin = new Vector3ArrayPlugin();
				}
				tweenPlugin = PluginsManager._vector3ArrayPlugin;
			}
			else if (typeFromHandle == typeof(Quaternion))
			{
				if (typeFromHandle2 == typeof(Quaternion))
				{
					Debugger.LogError("Quaternion tweens require a Vector3 endValue");
				}
				else
				{
					if (PluginsManager._quaternionPlugin == null)
					{
						PluginsManager._quaternionPlugin = new QuaternionPlugin();
					}
					tweenPlugin = PluginsManager._quaternionPlugin;
				}
			}
			else if (typeFromHandle == typeof(Vector2))
			{
				if (PluginsManager._vector2Plugin == null)
				{
					PluginsManager._vector2Plugin = new Vector2Plugin();
				}
				tweenPlugin = PluginsManager._vector2Plugin;
			}
			else if (typeFromHandle == typeof(float))
			{
				if (PluginsManager._floatPlugin == null)
				{
					PluginsManager._floatPlugin = new FloatPlugin();
				}
				tweenPlugin = PluginsManager._floatPlugin;
			}
			else if (typeFromHandle == typeof(Color))
			{
				if (PluginsManager._colorPlugin == null)
				{
					PluginsManager._colorPlugin = new ColorPlugin();
				}
				tweenPlugin = PluginsManager._colorPlugin;
			}
			else if (typeFromHandle == typeof(int))
			{
				if (PluginsManager._intPlugin == null)
				{
					PluginsManager._intPlugin = new IntPlugin();
				}
				tweenPlugin = PluginsManager._intPlugin;
			}
			else if (typeFromHandle == typeof(Vector4))
			{
				if (PluginsManager._vector4Plugin == null)
				{
					PluginsManager._vector4Plugin = new Vector4Plugin();
				}
				tweenPlugin = PluginsManager._vector4Plugin;
			}
			else if (typeFromHandle == typeof(Rect))
			{
				if (PluginsManager._rectPlugin == null)
				{
					PluginsManager._rectPlugin = new RectPlugin();
				}
				tweenPlugin = PluginsManager._rectPlugin;
			}
			else if (typeFromHandle == typeof(RectOffset))
			{
				if (PluginsManager._rectOffsetPlugin == null)
				{
					PluginsManager._rectOffsetPlugin = new RectOffsetPlugin();
				}
				tweenPlugin = PluginsManager._rectOffsetPlugin;
			}
			else if (typeFromHandle == typeof(uint))
			{
				if (PluginsManager._uintPlugin == null)
				{
					PluginsManager._uintPlugin = new UintPlugin();
				}
				tweenPlugin = PluginsManager._uintPlugin;
			}
			else if (typeFromHandle == typeof(string))
			{
				if (PluginsManager._stringPlugin == null)
				{
					PluginsManager._stringPlugin = new StringPlugin();
				}
				tweenPlugin = PluginsManager._stringPlugin;
			}
			else if (typeFromHandle == typeof(Color2))
			{
				if (PluginsManager._color2Plugin == null)
				{
					PluginsManager._color2Plugin = new Color2Plugin();
				}
				tweenPlugin = PluginsManager._color2Plugin;
			}
			else if (typeFromHandle == typeof(long))
			{
				if (PluginsManager._longPlugin == null)
				{
					PluginsManager._longPlugin = new LongPlugin();
				}
				tweenPlugin = PluginsManager._longPlugin;
			}
			else if (typeFromHandle == typeof(ulong))
			{
				if (PluginsManager._ulongPlugin == null)
				{
					PluginsManager._ulongPlugin = new UlongPlugin();
				}
				tweenPlugin = PluginsManager._ulongPlugin;
			}
			else if (typeFromHandle == typeof(double))
			{
				if (PluginsManager._doublePlugin == null)
				{
					PluginsManager._doublePlugin = new DoublePlugin();
				}
				tweenPlugin = PluginsManager._doublePlugin;
			}
			if (tweenPlugin != null)
			{
				return tweenPlugin as ABSTweenPlugin<T1, T2, TPlugOptions>;
			}
			return null;
		}

		public static ABSTweenPlugin<T1, T2, TPlugOptions> GetCustomPlugin<TPlugin, T1, T2, TPlugOptions>() where TPlugin : ITweenPlugin, new() where TPlugOptions : struct, IPlugOptions
		{
			Type typeFromHandle = typeof(TPlugin);
			ITweenPlugin tweenPlugin;
			if (PluginsManager._customPlugins == null)
			{
				PluginsManager._customPlugins = new Dictionary<Type, ITweenPlugin>(20);
			}
			else if (PluginsManager._customPlugins.TryGetValue(typeFromHandle, out tweenPlugin))
			{
				return tweenPlugin as ABSTweenPlugin<T1, T2, TPlugOptions>;
			}
			tweenPlugin = Activator.CreateInstance<TPlugin>();
			PluginsManager._customPlugins.Add(typeFromHandle, tweenPlugin);
			return tweenPlugin as ABSTweenPlugin<T1, T2, TPlugOptions>;
		}

		internal static void PurgeAll()
		{
			PluginsManager._floatPlugin = null;
			PluginsManager._intPlugin = null;
			PluginsManager._uintPlugin = null;
			PluginsManager._longPlugin = null;
			PluginsManager._ulongPlugin = null;
			PluginsManager._vector2Plugin = null;
			PluginsManager._vector3Plugin = null;
			PluginsManager._vector4Plugin = null;
			PluginsManager._quaternionPlugin = null;
			PluginsManager._colorPlugin = null;
			PluginsManager._rectPlugin = null;
			PluginsManager._rectOffsetPlugin = null;
			PluginsManager._stringPlugin = null;
			PluginsManager._vector3ArrayPlugin = null;
			PluginsManager._color2Plugin = null;
			if (PluginsManager._customPlugins != null)
			{
				PluginsManager._customPlugins.Clear();
			}
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Core.PathCore
{
	[Serializable]
	public struct ControlPoint
	{
		public Vector3 a;

		public Vector3 b;

		public ControlPoint(Vector3 a, Vector3 b)
		{
			this.a = a;
			this.b = b;
		}

		public static ControlPoint operator +(ControlPoint cp, Vector3 v)
		{
			return new ControlPoint(cp.a + v, cp.b + v);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Core.PathCore
{
	internal abstract class ABSPathDecoder
	{
		internal abstract void FinalizePath(Path p, Vector3[] wps, bool isClosedPath);

		internal abstract Vector3 GetPoint(float perc, Vector3[] wps, Path p, ControlPoint[] controlPoints);
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Core.PathCore
{
	internal class CatmullRomDecoder : ABSPathDecoder
	{
		internal override void FinalizePath(Path p, Vector3[] wps, bool isClosedPath)
		{
			int num = wps.Length;
			if (p.controlPoints == null || p.controlPoints.Length != 2)
			{
				p.controlPoints = new ControlPoint[2];
			}
			if (isClosedPath)
			{
				p.controlPoints[0] = new ControlPoint(wps[num - 2], Vector3.zero);
				p.controlPoints[1] = new ControlPoint(wps[1], Vector3.zero);
			}
			else
			{
				p.controlPoints[0] = new ControlPoint(wps[1], Vector3.zero);
				Vector3 a = wps[num - 1];
				Vector3 b = a - wps[num - 2];
				p.controlPoints[1] = new ControlPoint(a + b, Vector3.zero);
			}
			p.subdivisions = num * p.subdivisionsXSegment;
			this.SetTimeToLengthTables(p, p.subdivisions);
			this.SetWaypointsLengths(p, p.subdivisionsXSegment);
		}

		internal override Vector3 GetPoint(float perc, Vector3[] wps, Path p, ControlPoint[] controlPoints)
		{
			int num = wps.Length - 1;
			int num2 = (int)Math.Floor((double)(perc * (float)num));
			int num3 = num - 1;
			if (num3 > num2)
			{
				num3 = num2;
			}
			float num4 = perc * (float)num - (float)num3;
			Vector3 a = (num3 == 0) ? controlPoints[0].a : wps[num3 - 1];
			Vector3 a2 = wps[num3];
			Vector3 vector = wps[num3 + 1];
			Vector3 b = (num3 + 2 > wps.Length - 1) ? controlPoints[1].a : wps[num3 + 2];
			return 0.5f * ((-a + 3f * a2 - 3f * vector + b) * (num4 * num4 * num4) + (2f * a - 5f * a2 + 4f * vector - b) * (num4 * num4) + (-a + vector) * num4 + 2f * a2);
		}

		internal void SetTimeToLengthTables(Path p, int subdivisions)
		{
			float num = 0f;
			float num2 = 1f / (float)subdivisions;
			float[] array = new float[subdivisions];
			float[] array2 = new float[subdivisions];
			Vector3 b = this.GetPoint(0f, p.wps, p, p.controlPoints);
			for (int i = 1; i < subdivisions + 1; i++)
			{
				float num3 = num2 * (float)i;
				Vector3 point = this.GetPoint(num3, p.wps, p, p.controlPoints);
				num += Vector3.Distance(point, b);
				b = point;
				array[i - 1] = num3;
				array2[i - 1] = num;
			}
			p.length = num;
			p.timesTable = array;
			p.lengthsTable = array2;
		}

		internal void SetWaypointsLengths(Path p, int subdivisions)
		{
			int num = p.wps.Length;
			float[] array = new float[num];
			array[0] = 0f;
			ControlPoint[] array2 = new ControlPoint[2];
			Vector3[] array3 = new Vector3[2];
			for (int i = 1; i < num; i++)
			{
				array2[0].a = ((i == 1) ? p.controlPoints[0].a : p.wps[i - 2]);
				array3[0] = p.wps[i - 1];
				array3[1] = p.wps[i];
				array2[1].a = ((i == num - 1) ? p.controlPoints[1].a : p.wps[i + 1]);
				float num2 = 0f;
				float num3 = 1f / (float)subdivisions;
				Vector3 b = this.GetPoint(0f, array3, p, array2);
				for (int j = 1; j < subdivisions + 1; j++)
				{
					float perc = num3 * (float)j;
					Vector3 point = this.GetPoint(perc, array3, p, array2);
					num2 += Vector3.Distance(point, b);
					b = point;
				}
				array[i] = num2;
			}
			p.wpLengths = array;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Core.PathCore
{
	internal class LinearDecoder : ABSPathDecoder
	{
		internal override void FinalizePath(Path p, Vector3[] wps, bool isClosedPath)
		{
			p.controlPoints = null;
			p.subdivisions = wps.Length * p.subdivisionsXSegment;
			this.SetTimeToLengthTables(p, p.subdivisions);
		}

		internal override Vector3 GetPoint(float perc, Vector3[] wps, Path p, ControlPoint[] controlPoints)
		{
			if (perc <= 0f)
			{
				p.linearWPIndex = 1;
				return wps[0];
			}
			int num = 0;
			int num2 = 0;
			int num3 = p.timesTable.Length;
			for (int i = 1; i < num3; i++)
			{
				if (p.timesTable[i] >= perc)
				{
					num = i - 1;
					num2 = i;
					break;
				}
			}
			float num4 = p.timesTable[num];
			float num5 = perc - num4;
			float maxLength = p.length * num5;
			Vector3 vector = wps[num];
			Vector3 a = wps[num2];
			p.linearWPIndex = num2;
			return vector + Vector3.ClampMagnitude(a - vector, maxLength);
		}

		internal void SetTimeToLengthTables(Path p, int subdivisions)
		{
			float num = 0f;
			int num2 = p.wps.Length;
			float[] array = new float[num2];
			Vector3 b = p.wps[0];
			for (int i = 0; i < num2; i++)
			{
				Vector3 expr_35 = p.wps[i];
				float num3 = Vector3.Distance(expr_35, b);
				num += num3;
				b = expr_35;
				array[i] = num3;
			}
			float[] array2 = new float[num2];
			float num4 = 0f;
			for (int j = 1; j < num2; j++)
			{
				num4 += array[j];
				array2[j] = num4 / num;
			}
			p.length = num;
			p.wpLengths = array;
			p.timesTable = array2;
		}

		internal void SetWaypointsLengths(Path p, int subdivisions)
		{
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Plugins.Core.PathCore
{
	[Serializable]
	public class Path
	{
		private static CatmullRomDecoder _catmullRomDecoder;

		private static LinearDecoder _linearDecoder;

		public float[] wpLengths;

		[SerializeField]
		internal PathType type;

		[SerializeField]
		internal int subdivisionsXSegment;

		[SerializeField]
		internal int subdivisions;

		[SerializeField]
		internal Vector3[] wps;

		[SerializeField]
		internal ControlPoint[] controlPoints;

		[SerializeField]
		internal float length;

		[SerializeField]
		internal bool isFinalized;

		[SerializeField]
		internal float[] timesTable;

		[SerializeField]
		internal float[] lengthsTable;

		internal int linearWPIndex = -1;

		private Path _incrementalClone;

		private int _incrementalIndex;

		private ABSPathDecoder _decoder;

		private bool _changed;

		internal Vector3[] nonLinearDrawWps;

		internal Vector3 targetPosition;

		internal Vector3? lookAtPosition;

		internal Color gizmoColor = new Color(1f, 1f, 1f, 0.7f);

		public Path(PathType type, Vector3[] waypoints, int subdivisionsXSegment, Color? gizmoColor = null)
		{
			this.type = type;
			this.subdivisionsXSegment = subdivisionsXSegment;
			if (gizmoColor.HasValue)
			{
				this.gizmoColor = gizmoColor.Value;
			}
			this.AssignWaypoints(waypoints, true);
			this.AssignDecoder(type);
			if (DOTween.isUnityEditor)
			{
				DOTween.GizmosDelegates.Add(new TweenCallback(this.Draw));
			}
		}

		internal Path()
		{
		}

		internal void FinalizePath(bool isClosedPath, AxisConstraint lockPositionAxes, Vector3 currTargetVal)
		{
			if (lockPositionAxes != AxisConstraint.None)
			{
				bool flag = (lockPositionAxes & AxisConstraint.X) == AxisConstraint.X;
				bool flag2 = (lockPositionAxes & AxisConstraint.Y) == AxisConstraint.Y;
				bool flag3 = (lockPositionAxes & AxisConstraint.Z) == AxisConstraint.Z;
				for (int i = 0; i < this.wps.Length; i++)
				{
					Vector3 vector = this.wps[i];
					this.wps[i] = new Vector3(flag ? currTargetVal.x : vector.x, flag2 ? currTargetVal.y : vector.y, flag3 ? currTargetVal.z : vector.z);
				}
			}
			this._decoder.FinalizePath(this, this.wps, isClosedPath);
			this.isFinalized = true;
		}

		internal Vector3 GetPoint(float perc, bool convertToConstantPerc = false)
		{
			if (convertToConstantPerc)
			{
				perc = this.ConvertToConstantPathPerc(perc);
			}
			return this._decoder.GetPoint(perc, this.wps, this, this.controlPoints);
		}

		internal float ConvertToConstantPathPerc(float perc)
		{
			if (this.type == PathType.Linear)
			{
				return perc;
			}
			if (perc > 0f && perc < 1f)
			{
				float num = this.length * perc;
				float num2 = 0f;
				float num3 = 0f;
				float num4 = 0f;
				float num5 = 0f;
				int num6 = this.lengthsTable.Length;
				int i = 0;
				while (i < num6)
				{
					if (this.lengthsTable[i] > num)
					{
						num4 = this.timesTable[i];
						num5 = this.lengthsTable[i];
						if (i > 0)
						{
							num3 = this.lengthsTable[i - 1];
							break;
						}
						break;
					}
					else
					{
						num2 = this.timesTable[i];
						i++;
					}
				}
				perc = num2 + (num - num3) / (num5 - num3) * (num4 - num2);
			}
			if (perc > 1f)
			{
				perc = 1f;
			}
			else if (perc < 0f)
			{
				perc = 0f;
			}
			return perc;
		}

		internal int GetWaypointIndexFromPerc(float perc, bool isMovingForward)
		{
			if (perc >= 1f)
			{
				return this.wps.Length - 1;
			}
			if (perc <= 0f)
			{
				return 0;
			}
			float num = this.length * perc;
			float num2 = 0f;
			int i = 0;
			int num3 = this.wpLengths.Length;
			while (i < num3)
			{
				num2 += this.wpLengths[i];
				if (i == num3 - 1)
				{
					if (!isMovingForward)
					{
						return i;
					}
					return i - 1;
				}
				else if (num2 >= num)
				{
					if (num2 <= num)
					{
						return i;
					}
					if (!isMovingForward)
					{
						return i;
					}
					return i - 1;
				}
				else
				{
					i++;
				}
			}
			return 0;
		}

		internal static Vector3[] GetDrawPoints(Path p, int drawSubdivisionsXSegment)
		{
			int num = p.wps.Length;
			if (p.type == PathType.Linear)
			{
				return p.wps;
			}
			int num2 = num * drawSubdivisionsXSegment;
			Vector3[] array = new Vector3[num2 + 1];
			for (int i = 0; i <= num2; i++)
			{
				float perc = (float)i / (float)num2;
				Vector3 point = p.GetPoint(perc, false);
				array[i] = point;
			}
			return array;
		}

		internal static void RefreshNonLinearDrawWps(Path p)
		{
			int num = p.wps.Length * 10;
			if (p.nonLinearDrawWps == null || p.nonLinearDrawWps.Length != num + 1)
			{
				p.nonLinearDrawWps = new Vector3[num + 1];
			}
			for (int i = 0; i <= num; i++)
			{
				float perc = (float)i / (float)num;
				Vector3 point = p.GetPoint(perc, false);
				p.nonLinearDrawWps[i] = point;
			}
		}

		internal void Destroy()
		{
			if (DOTween.isUnityEditor)
			{
				DOTween.GizmosDelegates.Remove(new TweenCallback(this.Draw));
			}
			this.wps = null;
			this.wpLengths = (this.timesTable = (this.lengthsTable = null));
			this.nonLinearDrawWps = null;
			this.isFinalized = false;
		}

		internal Path CloneIncremental(int loopIncrement)
		{
			if (this._incrementalClone != null)
			{
				if (this._incrementalIndex == loopIncrement)
				{
					return this._incrementalClone;
				}
				this._incrementalClone.Destroy();
			}
			int num = this.wps.Length;
			Vector3 a = this.wps[num - 1] - this.wps[0];
			Vector3[] array = new Vector3[this.wps.Length];
			for (int i = 0; i < num; i++)
			{
				array[i] = this.wps[i] + a * (float)loopIncrement;
			}
			int num2 = this.controlPoints.Length;
			ControlPoint[] array2 = new ControlPoint[num2];
			for (int j = 0; j < num2; j++)
			{
				array2[j] = this.controlPoints[j] + a * (float)loopIncrement;
			}
			Vector3[] array3 = null;
			if (this.nonLinearDrawWps != null)
			{
				int num3 = this.nonLinearDrawWps.Length;
				array3 = new Vector3[num3];
				for (int k = 0; k < num3; k++)
				{
					array3[k] = this.nonLinearDrawWps[k] + a * (float)loopIncrement;
				}
			}
			this._incrementalClone = new Path();
			this._incrementalIndex = loopIncrement;
			this._incrementalClone.type = this.type;
			this._incrementalClone.subdivisionsXSegment = this.subdivisionsXSegment;
			this._incrementalClone.subdivisions = this.subdivisions;
			this._incrementalClone.wps = array;
			this._incrementalClone.controlPoints = array2;
			if (DOTween.isUnityEditor)
			{
				DOTween.GizmosDelegates.Add(new TweenCallback(this._incrementalClone.Draw));
			}
			this._incrementalClone.length = this.length;
			this._incrementalClone.wpLengths = this.wpLengths;
			this._incrementalClone.timesTable = this.timesTable;
			this._incrementalClone.lengthsTable = this.lengthsTable;
			this._incrementalClone._decoder = this._decoder;
			this._incrementalClone.nonLinearDrawWps = array3;
			this._incrementalClone.targetPosition = this.targetPosition;
			this._incrementalClone.lookAtPosition = this.lookAtPosition;
			this._incrementalClone.isFinalized = true;
			return this._incrementalClone;
		}

		internal void AssignWaypoints(Vector3[] newWps, bool cloneWps = false)
		{
			if (cloneWps)
			{
				int num = newWps.Length;
				this.wps = new Vector3[num];
				for (int i = 0; i < num; i++)
				{
					this.wps[i] = newWps[i];
				}
				return;
			}
			this.wps = newWps;
		}

		internal void AssignDecoder(PathType pathType)
		{
			this.type = pathType;
			if (pathType == PathType.Linear)
			{
				if (Path._linearDecoder == null)
				{
					Path._linearDecoder = new LinearDecoder();
				}
				this._decoder = Path._linearDecoder;
				return;
			}
			if (Path._catmullRomDecoder == null)
			{
				Path._catmullRomDecoder = new CatmullRomDecoder();
			}
			this._decoder = Path._catmullRomDecoder;
		}

		internal void Draw()
		{
			Path.Draw(this);
		}

		private static void Draw(Path p)
		{
			if (p.timesTable == null)
			{
				return;
			}
			Color color = p.gizmoColor;
			color.a *= 0.5f;
			Gizmos.color = p.gizmoColor;
			int num = p.wps.Length;
			if (p._changed || (p.type != PathType.Linear && p.nonLinearDrawWps == null))
			{
				p._changed = false;
				if (p.type != PathType.Linear)
				{
					Path.RefreshNonLinearDrawWps(p);
				}
			}
			if (p.type == PathType.Linear)
			{
				Vector3 to = p.wps[0];
				for (int i = 0; i < num; i++)
				{
					Vector3 expr_8A = p.wps[i];
					Gizmos.DrawLine(expr_8A, to);
					to = expr_8A;
				}
			}
			else
			{
				Vector3 to = p.nonLinearDrawWps[0];
				int num2 = p.nonLinearDrawWps.Length;
				for (int j = 1; j < num2; j++)
				{
					Vector3 expr_C8 = p.nonLinearDrawWps[j];
					Gizmos.DrawLine(expr_C8, to);
					to = expr_C8;
				}
			}
			Gizmos.color = color;
			for (int k = 0; k < num; k++)
			{
				Gizmos.DrawSphere(p.wps[k], 0.075f);
			}
			if (p.lookAtPosition.HasValue)
			{
				Vector3 value = p.lookAtPosition.Value;
				Gizmos.DrawLine(p.targetPosition, value);
				Gizmos.DrawWireSphere(value, 0.075f);
			}
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core;
using DG.Tweening.Core.Easing;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;
using UnityEngine;

namespace DG.Tweening.CustomPlugins
{
	public class PureQuaternionPlugin : ABSTweenPlugin<Quaternion, Quaternion, NoOptions>
	{
		private static PureQuaternionPlugin _plug;

		public static PureQuaternionPlugin Plug()
		{
			if (PureQuaternionPlugin._plug == null)
			{
				PureQuaternionPlugin._plug = new PureQuaternionPlugin();
			}
			return PureQuaternionPlugin._plug;
		}

		public override void Reset(TweenerCore<Quaternion, Quaternion, NoOptions> t)
		{
		}

		public override void SetFrom(TweenerCore<Quaternion, Quaternion, NoOptions> t, bool isRelative)
		{
			Quaternion endValue = t.endValue;
			t.endValue = t.getter();
			t.startValue = (isRelative ? (t.endValue * endValue) : endValue);
			t.setter(t.startValue);
		}

		public override Quaternion ConvertToStartValue(TweenerCore<Quaternion, Quaternion, NoOptions> t, Quaternion value)
		{
			return value;
		}

		public override void SetRelativeEndValue(TweenerCore<Quaternion, Quaternion, NoOptions> t)
		{
			t.endValue *= t.startValue;
		}

		public override void SetChangeValue(TweenerCore<Quaternion, Quaternion, NoOptions> t)
		{
			t.changeValue.x = t.endValue.x - t.startValue.x;
			t.changeValue.y = t.endValue.y - t.startValue.y;
			t.changeValue.z = t.endValue.z - t.startValue.z;
			t.changeValue.w = t.endValue.w - t.startValue.w;
		}

		public override float GetSpeedBasedDuration(NoOptions options, float unitsXSecond, Quaternion changeValue)
		{
			return changeValue.eulerAngles.magnitude / unitsXSecond;
		}

		public override void EvaluateAndApply(NoOptions options, Tween t, bool isRelative, DOGetter<Quaternion> getter, DOSetter<Quaternion> setter, float elapsed, Quaternion startValue, Quaternion changeValue, float duration, bool usingInversePosition, UpdateNotice updateNotice)
		{
			float num = EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
			startValue.x += changeValue.x * num;
			startValue.y += changeValue.y * num;
			startValue.z += changeValue.z * num;
			startValue.w += changeValue.w * num;
			setter(startValue);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core
{
	public abstract class ABSSequentiable
	{
		internal TweenType tweenType;

		internal float sequencedPosition;

		internal float sequencedEndPosition;

		internal TweenCallback onStart;
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core
{
	public delegate T DOGetter<out T>();
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core
{
	public delegate void DOSetter<in T>(T pNewValue);
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Core
{
	public static class Debugger
	{
		public static int logPriority;

		public static void Log(object message)
		{
			UnityEngine.Debug.Log("DOTWEEN :: " + message);
		}

		public static void LogWarning(object message)
		{
			UnityEngine.Debug.LogWarning("DOTWEEN :: " + message);
		}

		public static void LogError(object message)
		{
			UnityEngine.Debug.LogError("DOTWEEN :: " + message);
		}

		public static void LogReport(object message)
		{
			UnityEngine.Debug.Log("<color=#00B500FF>DOTWEEN :: " + message + "</color>");
		}

		public static void LogInvalidTween(Tween t)
		{
			Debugger.LogWarning("This Tween has been killed and is now invalid");
		}

		public static void LogNestedTween(Tween t)
		{
			Debugger.LogWarning("This Tween was added to a Sequence and can't be controlled directly");
		}

		public static void LogNullTween(Tween t)
		{
			Debugger.LogWarning("Null Tween");
		}

		public static void LogNonPathTween(Tween t)
		{
			Debugger.LogWarning("This Tween is not a path tween");
		}

		public static void LogMissingMaterialProperty(string propertyName)
		{
			Debugger.LogWarning(string.Format("This material doesn't have a {0} property", propertyName));
		}

		public static void LogRemoveActiveTweenError(string propertyName)
		{
			Debugger.Log(string.Format("Error in RemoveActiveTween.{0}. It's been taken care of so no problems, but Daniele (DOTween's author) is trying to pinpoint it and it would be awesome if you could reproduce this log in a sample project and send it to him. Or even just write him the complete log that was generated by this message. Fixing this would make DOTween slightly faster. Thanks.", propertyName));
		}

		public static void SetLogPriority(LogBehaviour logBehaviour)
		{
			if (logBehaviour == LogBehaviour.Default)
			{
				Debugger.logPriority = 1;
				return;
			}
			if (logBehaviour != LogBehaviour.Verbose)
			{
				Debugger.logPriority = 0;
				return;
			}
			Debugger.logPriority = 2;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace DG.Tweening.Core
{
	[AddComponentMenu("")]
	public class DOTweenComponent : MonoBehaviour, IDOTweenInit
	{
		private sealed class _WaitForCompletion_d__13 : IEnumerator<object>, IDisposable, IEnumerator
		{
			private int __1__state;

			private object __2__current;

			public Tween t;

			object IEnumerator<object>.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			public _WaitForCompletion_d__13(int __1__state)
			{
				this.__1__state = __1__state;
			}

			void IDisposable.Dispose()
			{
			}

			bool IEnumerator.MoveNext()
			{
				int num = this.__1__state;
				if (num != 0)
				{
					if (num != 1)
					{
						return false;
					}
					this.__1__state = -1;
				}
				else
				{
					this.__1__state = -1;
				}
				if (!this.t.active || this.t.isComplete)
				{
					return false;
				}
				this.__2__current = null;
				this.__1__state = 1;
				return true;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}

		private sealed class _WaitForRewind_d__14 : IEnumerator<object>, IDisposable, IEnumerator
		{
			private int __1__state;

			private object __2__current;

			public Tween t;

			object IEnumerator<object>.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			public _WaitForRewind_d__14(int __1__state)
			{
				this.__1__state = __1__state;
			}

			void IDisposable.Dispose()
			{
			}

			bool IEnumerator.MoveNext()
			{
				int num = this.__1__state;
				if (num != 0)
				{
					if (num != 1)
					{
						return false;
					}
					this.__1__state = -1;
				}
				else
				{
					this.__1__state = -1;
				}
				if (!this.t.active || (this.t.playedOnce && this.t.position * (float)(this.t.completedLoops + 1) <= 0f))
				{
					return false;
				}
				this.__2__current = null;
				this.__1__state = 1;
				return true;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}

		private sealed class _WaitForKill_d__15 : IEnumerator<object>, IDisposable, IEnumerator
		{
			private int __1__state;

			private object __2__current;

			public Tween t;

			object IEnumerator<object>.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			public _WaitForKill_d__15(int __1__state)
			{
				this.__1__state = __1__state;
			}

			void IDisposable.Dispose()
			{
			}

			bool IEnumerator.MoveNext()
			{
				int num = this.__1__state;
				if (num != 0)
				{
					if (num != 1)
					{
						return false;
					}
					this.__1__state = -1;
				}
				else
				{
					this.__1__state = -1;
				}
				if (!this.t.active)
				{
					return false;
				}
				this.__2__current = null;
				this.__1__state = 1;
				return true;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}

		private sealed class _WaitForElapsedLoops_d__16 : IEnumerator<object>, IDisposable, IEnumerator
		{
			private int __1__state;

			private object __2__current;

			public Tween t;

			public int elapsedLoops;

			object IEnumerator<object>.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			public _WaitForElapsedLoops_d__16(int __1__state)
			{
				this.__1__state = __1__state;
			}

			void IDisposable.Dispose()
			{
			}

			bool IEnumerator.MoveNext()
			{
				int num = this.__1__state;
				if (num != 0)
				{
					if (num != 1)
					{
						return false;
					}
					this.__1__state = -1;
				}
				else
				{
					this.__1__state = -1;
				}
				if (!this.t.active || this.t.completedLoops >= this.elapsedLoops)
				{
					return false;
				}
				this.__2__current = null;
				this.__1__state = 1;
				return true;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}

		private sealed class _WaitForPosition_d__17 : IEnumerator<object>, IDisposable, IEnumerator
		{
			private int __1__state;

			private object __2__current;

			public Tween t;

			public float position;

			object IEnumerator<object>.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			public _WaitForPosition_d__17(int __1__state)
			{
				this.__1__state = __1__state;
			}

			void IDisposable.Dispose()
			{
			}

			bool IEnumerator.MoveNext()
			{
				int num = this.__1__state;
				if (num != 0)
				{
					if (num != 1)
					{
						return false;
					}
					this.__1__state = -1;
				}
				else
				{
					this.__1__state = -1;
				}
				if (!this.t.active || this.t.position * (float)(this.t.completedLoops + 1) >= this.position)
				{
					return false;
				}
				this.__2__current = null;
				this.__1__state = 1;
				return true;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}

		private sealed class _WaitForStart_d__18 : IEnumerator<object>, IDisposable, IEnumerator
		{
			private int __1__state;

			private object __2__current;

			public Tween t;

			object IEnumerator<object>.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			object IEnumerator.Current
			{
				get
				{
					return this.__2__current;
				}
			}

			public _WaitForStart_d__18(int __1__state)
			{
				this.__1__state = __1__state;
			}

			void IDisposable.Dispose()
			{
			}

			bool IEnumerator.MoveNext()
			{
				int num = this.__1__state;
				if (num != 0)
				{
					if (num != 1)
					{
						return false;
					}
					this.__1__state = -1;
				}
				else
				{
					this.__1__state = -1;
				}
				if (!this.t.active || this.t.playedOnce)
				{
					return false;
				}
				this.__2__current = null;
				this.__1__state = 1;
				return true;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}
		}

		public int inspectorUpdater;

		private float _unscaledTime;

		private float _unscaledDeltaTime;

		private bool _duplicateToDestroy;

		private void Awake()
		{
			this.inspectorUpdater = 0;
			this._unscaledTime = Time.realtimeSinceStartup;
		}

		private void Start()
		{
			if (DOTween.instance != this)
			{
				this._duplicateToDestroy = true;
				Object.Destroy(base.gameObject);
			}
		}

		private void Update()
		{
			this._unscaledDeltaTime = Time.realtimeSinceStartup - this._unscaledTime;
			if (DOTween.useSmoothDeltaTime && this._unscaledDeltaTime > DOTween.maxSmoothUnscaledTime)
			{
				this._unscaledDeltaTime = DOTween.maxSmoothUnscaledTime;
			}
			if (TweenManager.hasActiveDefaultTweens)
			{
				TweenManager.Update(UpdateType.Normal, (DOTween.useSmoothDeltaTime ? Time.smoothDeltaTime : Time.deltaTime) * DOTween.timeScale, this._unscaledDeltaTime * DOTween.timeScale);
			}
			this._unscaledTime = Time.realtimeSinceStartup;
			if (DOTween.isUnityEditor)
			{
				this.inspectorUpdater++;
				if (DOTween.showUnityEditorReport && TweenManager.hasActiveTweens)
				{
					if (TweenManager.totActiveTweeners > DOTween.maxActiveTweenersReached)
					{
						DOTween.maxActiveTweenersReached = TweenManager.totActiveTweeners;
					}
					if (TweenManager.totActiveSequences > DOTween.maxActiveSequencesReached)
					{
						DOTween.maxActiveSequencesReached = TweenManager.totActiveSequences;
					}
				}
			}
		}

		private void LateUpdate()
		{
			if (TweenManager.hasActiveLateTweens)
			{
				TweenManager.Update(UpdateType.Late, (DOTween.useSmoothDeltaTime ? Time.smoothDeltaTime : Time.deltaTime) * DOTween.timeScale, this._unscaledDeltaTime * DOTween.timeScale);
			}
		}

		private void FixedUpdate()
		{
			if (TweenManager.hasActiveFixedTweens && Time.timeScale > 0f)
			{
				TweenManager.Update(UpdateType.Fixed, (DOTween.useSmoothDeltaTime ? Time.smoothDeltaTime : Time.deltaTime) * DOTween.timeScale, (DOTween.useSmoothDeltaTime ? Time.smoothDeltaTime : Time.deltaTime) / Time.timeScale * DOTween.timeScale);
			}
		}

		private void OnDrawGizmos()
		{
			if (!DOTween.drawGizmos || !DOTween.isUnityEditor)
			{
				return;
			}
			int count = DOTween.GizmosDelegates.Count;
			if (count == 0)
			{
				return;
			}
			for (int i = 0; i < count; i++)
			{
				DOTween.GizmosDelegates[i]();
			}
		}

		private void OnDestroy()
		{
			if (this._duplicateToDestroy)
			{
				return;
			}
			if (DOTween.showUnityEditorReport)
			{
				Debugger.LogReport(string.Concat(new object[]
				{
					"REPORT > Max overall simultaneous active Tweeners/Sequences: ",
					DOTween.maxActiveTweenersReached,
					"/",
					DOTween.maxActiveSequencesReached
				}));
			}
			if (DOTween.instance == this)
			{
				DOTween.instance = null;
			}
		}

		private void OnApplicationQuit()
		{
			DOTween.isQuitting = true;
		}

		public IDOTweenInit SetCapacity(int tweenersCapacity, int sequencesCapacity)
		{
			TweenManager.SetCapacities(tweenersCapacity, sequencesCapacity);
			return this;
		}

		internal IEnumerator WaitForCompletion(Tween t)
		{
			DOTweenComponent._WaitForCompletion_d__13 expr_06 = new DOTweenComponent._WaitForCompletion_d__13(0);
			expr_06.t = t;
			return expr_06;
		}

		internal IEnumerator WaitForRewind(Tween t)
		{
			DOTweenComponent._WaitForRewind_d__14 expr_06 = new DOTweenComponent._WaitForRewind_d__14(0);
			expr_06.t = t;
			return expr_06;
		}

		internal IEnumerator WaitForKill(Tween t)
		{
			DOTweenComponent._WaitForKill_d__15 expr_06 = new DOTweenComponent._WaitForKill_d__15(0);
			expr_06.t = t;
			return expr_06;
		}

		internal IEnumerator WaitForElapsedLoops(Tween t, int elapsedLoops)
		{
			DOTweenComponent._WaitForElapsedLoops_d__16 expr_06 = new DOTweenComponent._WaitForElapsedLoops_d__16(0);
			expr_06.t = t;
			expr_06.elapsedLoops = elapsedLoops;
			return expr_06;
		}

		internal IEnumerator WaitForPosition(Tween t, float position)
		{
			DOTweenComponent._WaitForPosition_d__17 expr_06 = new DOTweenComponent._WaitForPosition_d__17(0);
			expr_06.t = t;
			expr_06.position = position;
			return expr_06;
		}

		internal IEnumerator WaitForStart(Tween t)
		{
			DOTweenComponent._WaitForStart_d__18 expr_06 = new DOTweenComponent._WaitForStart_d__18(0);
			expr_06.t = t;
			return expr_06;
		}

		internal static void Create()
		{
			if (DOTween.instance != null)
			{
				return;
			}
			GameObject expr_18 = new GameObject("[DOTween]");
			Object.DontDestroyOnLoad(expr_18);
			DOTween.instance = expr_18.AddComponent<DOTweenComponent>();
		}

		internal static void DestroyInstance()
		{
			if (DOTween.instance != null)
			{
				Object.Destroy(DOTween.instance.gameObject);
			}
			DOTween.instance = null;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Core
{
	public class DOTweenSettings : ScriptableObject
	{
		public enum SettingsLocation
		{
			AssetsDirectory,
			DOTweenDirectory,
			DemigiantDirectory
		}

		public const string AssetName = "DOTweenSettings";

		public bool useSafeMode = true;

		public float timeScale = 1f;

		public bool useSmoothDeltaTime;

		public float maxSmoothUnscaledTime = 0.15f;

		public bool showUnityEditorReport;

		public LogBehaviour logBehaviour = LogBehaviour.ErrorsOnly;

		public bool drawGizmos = true;

		public bool defaultRecyclable;

		public AutoPlay defaultAutoPlay = AutoPlay.All;

		public UpdateType defaultUpdateType;

		public bool defaultTimeScaleIndependent;

		public Ease defaultEaseType = Ease.OutQuad;

		public float defaultEaseOvershootOrAmplitude = 1.70158f;

		public float defaultEasePeriod;

		public bool defaultAutoKill = true;

		public LoopType defaultLoopType;

		public DOTweenSettings.SettingsLocation storeSettingsLocation;
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Core
{
	public static class Extensions
	{
		internal static T SetSpecialStartupMode<T>(this T t, SpecialStartupMode mode) where T : Tween
		{
			t.specialStartupMode = mode;
			return t;
		}

		internal static TweenerCore<T1, T2, TPlugOptions> NoFrom<T1, T2, TPlugOptions>(this TweenerCore<T1, T2, TPlugOptions> t) where TPlugOptions : struct, IPlugOptions
		{
			t.isFromAllowed = false;
			return t;
		}

		internal static TweenerCore<T1, T2, TPlugOptions> Blendable<T1, T2, TPlugOptions>(this TweenerCore<T1, T2, TPlugOptions> t) where TPlugOptions : struct, IPlugOptions
		{
			t.isBlendable = true;
			return t;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core
{
	internal class SequenceCallback : ABSSequentiable
	{
		public SequenceCallback(float sequencedPosition, TweenCallback callback)
		{
			this.tweenType = TweenType.Callback;
			this.sequencedPosition = sequencedPosition;
			this.onStart = callback;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Options;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace DG.Tweening.Core
{
	internal static class TweenManager
	{
		internal enum CapacityIncreaseMode
		{
			TweenersAndSequences,
			TweenersOnly,
			SequencesOnly
		}

		private const int _DefaultMaxTweeners = 200;

		private const int _DefaultMaxSequences = 50;

		private const string _MaxTweensReached = "Max Tweens reached: capacity has automatically been increased from #0 to #1. Use DOTween.SetTweensCapacity to set it manually at startup";

		internal static int maxActive = 250;

		internal static int maxTweeners = 200;

		internal static int maxSequences = 50;

		internal static bool hasActiveTweens;

		internal static bool hasActiveDefaultTweens;

		internal static bool hasActiveLateTweens;

		internal static bool hasActiveFixedTweens;

		internal static int totActiveTweens;

		internal static int totActiveDefaultTweens;

		internal static int totActiveLateTweens;

		internal static int totActiveFixedTweens;

		internal static int totActiveTweeners;

		internal static int totActiveSequences;

		internal static int totPooledTweeners;

		internal static int totPooledSequences;

		internal static int totTweeners;

		internal static int totSequences;

		internal static bool isUpdateLoop;

		internal static Tween[] _activeTweens = new Tween[250];

		private static Tween[] _pooledTweeners = new Tween[200];

		private static readonly Stack<Tween> _PooledSequences = new Stack<Tween>();

		private static readonly List<Tween> _KillList = new List<Tween>(250);

		private static int _maxActiveLookupId = -1;

		private static bool _requiresActiveReorganization;

		private static int _reorganizeFromId = -1;

		private static int _minPooledTweenerId = -1;

		private static int _maxPooledTweenerId = -1;

		private static bool _despawnAllCalledFromUpdateLoopCallback;

		internal static TweenerCore<T1, T2, TPlugOptions> GetTweener<T1, T2, TPlugOptions>() where TPlugOptions : struct, IPlugOptions
		{
			if (TweenManager.totPooledTweeners > 0)
			{
				Type typeFromHandle = typeof(T1);
				Type typeFromHandle2 = typeof(T2);
				Type typeFromHandle3 = typeof(TPlugOptions);
				for (int i = TweenManager._maxPooledTweenerId; i > TweenManager._minPooledTweenerId - 1; i--)
				{
					Tween tween = TweenManager._pooledTweeners[i];
					if (tween != null && tween.typeofT1 == typeFromHandle && tween.typeofT2 == typeFromHandle2 && tween.typeofTPlugOptions == typeFromHandle3)
					{
						TweenerCore<T1, T2, TPlugOptions> expr_69 = (TweenerCore<T1, T2, TPlugOptions>)tween;
						TweenManager.AddActiveTween(expr_69);
						TweenManager._pooledTweeners[i] = null;
						if (TweenManager._maxPooledTweenerId != TweenManager._minPooledTweenerId)
						{
							if (i == TweenManager._maxPooledTweenerId)
							{
								TweenManager._maxPooledTweenerId--;
							}
							else if (i == TweenManager._minPooledTweenerId)
							{
								TweenManager._minPooledTweenerId++;
							}
						}
						TweenManager.totPooledTweeners--;
						return expr_69;
					}
				}
				if (TweenManager.totTweeners >= TweenManager.maxTweeners)
				{
					TweenManager._pooledTweeners[TweenManager._maxPooledTweenerId] = null;
					TweenManager._maxPooledTweenerId--;
					TweenManager.totPooledTweeners--;
					TweenManager.totTweeners--;
				}
			}
			else if (TweenManager.totTweeners >= TweenManager.maxTweeners - 1)
			{
				int num = TweenManager.maxTweeners;
				int num2 = TweenManager.maxSequences;
				TweenManager.IncreaseCapacities(TweenManager.CapacityIncreaseMode.TweenersOnly);
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning("Max Tweens reached: capacity has automatically been increased from #0 to #1. Use DOTween.SetTweensCapacity to set it manually at startup".Replace("#0", num + "/" + num2).Replace("#1", TweenManager.maxTweeners + "/" + TweenManager.maxSequences));
				}
			}
			TweenerCore<T1, T2, TPlugOptions> arg_19B_0 = new TweenerCore<T1, T2, TPlugOptions>();
			TweenManager.totTweeners++;
			TweenManager.AddActiveTween(arg_19B_0);
			return arg_19B_0;
		}

		internal static Sequence GetSequence()
		{
			if (TweenManager.totPooledSequences > 0)
			{
				Sequence expr_17 = (Sequence)TweenManager._PooledSequences.Pop();
				TweenManager.AddActiveTween(expr_17);
				TweenManager.totPooledSequences--;
				return expr_17;
			}
			if (TweenManager.totSequences >= TweenManager.maxSequences - 1)
			{
				int num = TweenManager.maxTweeners;
				int num2 = TweenManager.maxSequences;
				TweenManager.IncreaseCapacities(TweenManager.CapacityIncreaseMode.SequencesOnly);
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning("Max Tweens reached: capacity has automatically been increased from #0 to #1. Use DOTween.SetTweensCapacity to set it manually at startup".Replace("#0", num + "/" + num2).Replace("#1", TweenManager.maxTweeners + "/" + TweenManager.maxSequences));
				}
			}
			Sequence arg_B5_0 = new Sequence();
			TweenManager.totSequences++;
			TweenManager.AddActiveTween(arg_B5_0);
			return arg_B5_0;
		}

		internal static void SetUpdateType(Tween t, UpdateType updateType, bool isIndependentUpdate)
		{
			if (!t.active || t.updateType == updateType)
			{
				t.updateType = updateType;
				t.isIndependentUpdate = isIndependentUpdate;
				return;
			}
			if (t.updateType == UpdateType.Normal)
			{
				TweenManager.totActiveDefaultTweens--;
				TweenManager.hasActiveDefaultTweens = (TweenManager.totActiveDefaultTweens > 0);
			}
			else if (t.updateType == UpdateType.Fixed)
			{
				TweenManager.totActiveFixedTweens--;
				TweenManager.hasActiveFixedTweens = (TweenManager.totActiveFixedTweens > 0);
			}
			else
			{
				TweenManager.totActiveLateTweens--;
				TweenManager.hasActiveLateTweens = (TweenManager.totActiveLateTweens > 0);
			}
			t.updateType = updateType;
			t.isIndependentUpdate = isIndependentUpdate;
			if (updateType == UpdateType.Normal)
			{
				TweenManager.totActiveDefaultTweens++;
				TweenManager.hasActiveDefaultTweens = true;
				return;
			}
			if (updateType == UpdateType.Fixed)
			{
				TweenManager.totActiveFixedTweens++;
				TweenManager.hasActiveFixedTweens = true;
				return;
			}
			TweenManager.totActiveLateTweens++;
			TweenManager.hasActiveLateTweens = true;
		}

		internal static void AddActiveTweenToSequence(Tween t)
		{
			TweenManager.RemoveActiveTween(t);
		}

		internal static int DespawnAll()
		{
			int result = TweenManager.totActiveTweens;
			for (int i = 0; i < TweenManager._maxActiveLookupId + 1; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween != null)
				{
					TweenManager.Despawn(tween, false);
				}
			}
			TweenManager.ClearTweenArray(TweenManager._activeTweens);
			TweenManager.hasActiveTweens = (TweenManager.hasActiveDefaultTweens = (TweenManager.hasActiveLateTweens = (TweenManager.hasActiveFixedTweens = false)));
			TweenManager.totActiveTweens = (TweenManager.totActiveDefaultTweens = (TweenManager.totActiveLateTweens = (TweenManager.totActiveFixedTweens = 0)));
			TweenManager.totActiveTweeners = (TweenManager.totActiveSequences = 0);
			TweenManager._maxActiveLookupId = (TweenManager._reorganizeFromId = -1);
			TweenManager._requiresActiveReorganization = false;
			if (TweenManager.isUpdateLoop)
			{
				TweenManager._despawnAllCalledFromUpdateLoopCallback = true;
			}
			return result;
		}

		internal static void Despawn(Tween t, bool modifyActiveLists = true)
		{
			if (t.onKill != null)
			{
				Tween.OnTweenCallback(t.onKill);
			}
			if (modifyActiveLists)
			{
				TweenManager.RemoveActiveTween(t);
			}
			if (t.isRecyclable)
			{
				TweenType tweenType = t.tweenType;
				if (tweenType != TweenType.Tweener)
				{
					if (tweenType == TweenType.Sequence)
					{
						TweenManager._PooledSequences.Push(t);
						TweenManager.totPooledSequences++;
						Sequence sequence = (Sequence)t;
						int count = sequence.sequencedTweens.Count;
						for (int i = 0; i < count; i++)
						{
							TweenManager.Despawn(sequence.sequencedTweens[i], false);
						}
					}
				}
				else
				{
					if (TweenManager._maxPooledTweenerId == -1)
					{
						TweenManager._maxPooledTweenerId = TweenManager.maxTweeners - 1;
						TweenManager._minPooledTweenerId = TweenManager.maxTweeners - 1;
					}
					if (TweenManager._maxPooledTweenerId < TweenManager.maxTweeners - 1)
					{
						TweenManager._pooledTweeners[TweenManager._maxPooledTweenerId + 1] = t;
						TweenManager._maxPooledTweenerId++;
						if (TweenManager._minPooledTweenerId > TweenManager._maxPooledTweenerId)
						{
							TweenManager._minPooledTweenerId = TweenManager._maxPooledTweenerId;
						}
					}
					else
					{
						int j = TweenManager._maxPooledTweenerId;
						while (j > -1)
						{
							if (TweenManager._pooledTweeners[j] == null)
							{
								TweenManager._pooledTweeners[j] = t;
								if (j < TweenManager._minPooledTweenerId)
								{
									TweenManager._minPooledTweenerId = j;
								}
								if (TweenManager._maxPooledTweenerId < TweenManager._minPooledTweenerId)
								{
									TweenManager._maxPooledTweenerId = TweenManager._minPooledTweenerId;
									break;
								}
								break;
							}
							else
							{
								j--;
							}
						}
					}
					TweenManager.totPooledTweeners++;
				}
			}
			else
			{
				TweenType tweenType = t.tweenType;
				if (tweenType != TweenType.Tweener)
				{
					if (tweenType == TweenType.Sequence)
					{
						TweenManager.totSequences--;
						Sequence sequence2 = (Sequence)t;
						int count2 = sequence2.sequencedTweens.Count;
						for (int k = 0; k < count2; k++)
						{
							TweenManager.Despawn(sequence2.sequencedTweens[k], false);
						}
					}
				}
				else
				{
					TweenManager.totTweeners--;
				}
			}
			t.active = false;
			t.Reset();
		}

		internal static void PurgeAll()
		{
			for (int i = 0; i < TweenManager.totActiveTweens; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween != null)
				{
					tween.active = false;
					if (tween.onKill != null)
					{
						Tween.OnTweenCallback(tween.onKill);
					}
				}
			}
			TweenManager.ClearTweenArray(TweenManager._activeTweens);
			TweenManager.hasActiveTweens = (TweenManager.hasActiveDefaultTweens = (TweenManager.hasActiveLateTweens = (TweenManager.hasActiveFixedTweens = false)));
			TweenManager.totActiveTweens = (TweenManager.totActiveDefaultTweens = (TweenManager.totActiveLateTweens = (TweenManager.totActiveFixedTweens = 0)));
			TweenManager.totActiveTweeners = (TweenManager.totActiveSequences = 0);
			TweenManager._maxActiveLookupId = (TweenManager._reorganizeFromId = -1);
			TweenManager._requiresActiveReorganization = false;
			TweenManager.PurgePools();
			TweenManager.ResetCapacities();
			TweenManager.totTweeners = (TweenManager.totSequences = 0);
		}

		internal static void PurgePools()
		{
			TweenManager.totTweeners -= TweenManager.totPooledTweeners;
			TweenManager.totSequences -= TweenManager.totPooledSequences;
			TweenManager.ClearTweenArray(TweenManager._pooledTweeners);
			TweenManager._PooledSequences.Clear();
			TweenManager.totPooledTweeners = (TweenManager.totPooledSequences = 0);
			TweenManager._minPooledTweenerId = (TweenManager._maxPooledTweenerId = -1);
		}

		internal static void ResetCapacities()
		{
			TweenManager.SetCapacities(200, 50);
		}

		internal static void SetCapacities(int tweenersCapacity, int sequencesCapacity)
		{
			if (tweenersCapacity < sequencesCapacity)
			{
				tweenersCapacity = sequencesCapacity;
			}
			TweenManager.maxActive = tweenersCapacity + sequencesCapacity;
			TweenManager.maxTweeners = tweenersCapacity;
			TweenManager.maxSequences = sequencesCapacity;
			Array.Resize<Tween>(ref TweenManager._activeTweens, TweenManager.maxActive);
			Array.Resize<Tween>(ref TweenManager._pooledTweeners, tweenersCapacity);
			TweenManager._KillList.Capacity = TweenManager.maxActive;
		}

		internal static int Validate()
		{
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			int num = 0;
			for (int i = 0; i < TweenManager._maxActiveLookupId + 1; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (!tween.Validate())
				{
					num++;
					TweenManager.MarkForKilling(tween);
				}
			}
			if (num > 0)
			{
				TweenManager.DespawnActiveTweens(TweenManager._KillList);
				TweenManager._KillList.Clear();
			}
			return num;
		}

		internal static void Update(UpdateType updateType, float deltaTime, float independentTime)
		{
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			TweenManager.isUpdateLoop = true;
			bool flag = false;
			int num = TweenManager._maxActiveLookupId + 1;
			for (int i = 0; i < num; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween != null && tween.updateType == updateType)
				{
					if (!tween.active)
					{
						flag = true;
						TweenManager.MarkForKilling(tween);
					}
					else if (tween.isPlaying)
					{
						tween.creationLocked = true;
						float num2 = (tween.isIndependentUpdate ? independentTime : deltaTime) * tween.timeScale;
						if (!tween.delayComplete)
						{
							num2 = tween.UpdateDelay(tween.elapsedDelay + num2);
							if (num2 <= -1f)
							{
								flag = true;
								TweenManager.MarkForKilling(tween);
								goto IL_202;
							}
							if (num2 <= 0f)
							{
								goto IL_202;
							}
							if (tween.playedOnce && tween.onPlay != null)
							{
								Tween.OnTweenCallback(tween.onPlay);
							}
						}
						if (!tween.startupDone && !tween.Startup())
						{
							flag = true;
							TweenManager.MarkForKilling(tween);
						}
						else
						{
							float num3 = tween.position;
							bool flag2 = num3 >= tween.duration;
							int num4 = tween.completedLoops;
							if (tween.duration <= 0f)
							{
								num3 = 0f;
								num4 = ((tween.loops == -1) ? (tween.completedLoops + 1) : tween.loops);
							}
							else
							{
								if (tween.isBackwards)
								{
									num3 -= num2;
									while (num3 < 0f && num4 > -1)
									{
										num3 += tween.duration;
										num4--;
									}
									if (num4 < 0 || (flag2 && num4 < 1))
									{
										num3 = 0f;
										num4 = (flag2 ? 1 : 0);
									}
								}
								else
								{
									num3 += num2;
									while (num3 >= tween.duration && (tween.loops == -1 || num4 < tween.loops))
									{
										num3 -= tween.duration;
										num4++;
									}
								}
								if (flag2)
								{
									num4--;
								}
								if (tween.loops != -1 && num4 >= tween.loops)
								{
									num3 = tween.duration;
								}
							}
							if (Tween.DoGoto(tween, num3, num4, UpdateMode.Update))
							{
								flag = true;
								TweenManager.MarkForKilling(tween);
							}
						}
					}
				}
				IL_202:;
			}
			if (flag)
			{
				if (TweenManager._despawnAllCalledFromUpdateLoopCallback)
				{
					TweenManager._despawnAllCalledFromUpdateLoopCallback = false;
				}
				else
				{
					TweenManager.DespawnActiveTweens(TweenManager._KillList);
				}
				TweenManager._KillList.Clear();
			}
			TweenManager.isUpdateLoop = false;
		}

		internal static int FilteredOperation(OperationType operationType, FilterType filterType, object id, bool optionalBool, float optionalFloat, object optionalObj = null, object[] optionalArray = null)
		{
			int num = 0;
			bool flag = false;
			int num2 = (optionalArray == null) ? 0 : optionalArray.Length;
			for (int i = TweenManager._maxActiveLookupId; i > -1; i--)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween != null && tween.active)
				{
					bool flag2 = false;
					switch (filterType)
					{
					case FilterType.All:
						flag2 = true;
						break;
					case FilterType.TargetOrId:
						flag2 = (id.Equals(tween.id) || id.Equals(tween.target));
						break;
					case FilterType.TargetAndId:
						flag2 = (id.Equals(tween.id) && optionalObj != null && optionalObj.Equals(tween.target));
						break;
					case FilterType.AllExceptTargetsOrIds:
						flag2 = true;
						for (int j = 0; j < num2; j++)
						{
							object obj = optionalArray[j];
							if (obj.Equals(tween.id) || obj.Equals(tween.target))
							{
								flag2 = false;
								break;
							}
						}
						break;
					}
					if (flag2)
					{
						switch (operationType)
						{
						case OperationType.Complete:
						{
							bool autoKill = tween.autoKill;
							if (TweenManager.Complete(tween, false, (optionalFloat > 0f) ? UpdateMode.Update : UpdateMode.Goto))
							{
								num += ((!optionalBool) ? 1 : (autoKill ? 1 : 0));
								if (autoKill)
								{
									if (TweenManager.isUpdateLoop)
									{
										tween.active = false;
									}
									else
									{
										flag = true;
										TweenManager._KillList.Add(tween);
									}
								}
							}
							break;
						}
						case OperationType.Despawn:
							num++;
							if (TweenManager.isUpdateLoop)
							{
								tween.active = false;
							}
							else
							{
								TweenManager.Despawn(tween, false);
								flag = true;
								TweenManager._KillList.Add(tween);
							}
							break;
						case OperationType.Flip:
							if (TweenManager.Flip(tween))
							{
								num++;
							}
							break;
						case OperationType.Goto:
							TweenManager.Goto(tween, optionalFloat, optionalBool, UpdateMode.Goto);
							num++;
							break;
						case OperationType.Pause:
							if (TweenManager.Pause(tween))
							{
								num++;
							}
							break;
						case OperationType.Play:
							if (TweenManager.Play(tween))
							{
								num++;
							}
							break;
						case OperationType.PlayForward:
							if (TweenManager.PlayForward(tween))
							{
								num++;
							}
							break;
						case OperationType.PlayBackwards:
							if (TweenManager.PlayBackwards(tween))
							{
								num++;
							}
							break;
						case OperationType.Rewind:
							if (TweenManager.Rewind(tween, optionalBool))
							{
								num++;
							}
							break;
						case OperationType.SmoothRewind:
							if (TweenManager.SmoothRewind(tween))
							{
								num++;
							}
							break;
						case OperationType.Restart:
							if (TweenManager.Restart(tween, optionalBool))
							{
								num++;
							}
							break;
						case OperationType.TogglePause:
							if (TweenManager.TogglePause(tween))
							{
								num++;
							}
							break;
						case OperationType.IsTweening:
							if ((!tween.isComplete || !tween.autoKill) && (!optionalBool || tween.isPlaying))
							{
								num++;
							}
							break;
						}
					}
				}
			}
			if (flag)
			{
				for (int k = TweenManager._KillList.Count - 1; k > -1; k--)
				{
					TweenManager.RemoveActiveTween(TweenManager._KillList[k]);
				}
				TweenManager._KillList.Clear();
			}
			return num;
		}

		internal static bool Complete(Tween t, bool modifyActiveLists = true, UpdateMode updateMode = UpdateMode.Goto)
		{
			if (t.loops == -1)
			{
				return false;
			}
			if (!t.isComplete)
			{
				Tween.DoGoto(t, t.duration, t.loops, updateMode);
				t.isPlaying = false;
				if (t.autoKill)
				{
					if (TweenManager.isUpdateLoop)
					{
						t.active = false;
					}
					else
					{
						TweenManager.Despawn(t, modifyActiveLists);
					}
				}
				return true;
			}
			return false;
		}

		internal static bool Flip(Tween t)
		{
			t.isBackwards = !t.isBackwards;
			return true;
		}

		internal static void ForceInit(Tween t, bool isSequenced = false)
		{
			if (t.startupDone)
			{
				return;
			}
			if (!t.Startup() && !isSequenced)
			{
				if (TweenManager.isUpdateLoop)
				{
					t.active = false;
					return;
				}
				TweenManager.RemoveActiveTween(t);
			}
		}

		internal static bool Goto(Tween t, float to, bool andPlay = false, UpdateMode updateMode = UpdateMode.Goto)
		{
			bool isPlaying = t.isPlaying;
			t.isPlaying = andPlay;
			t.delayComplete = true;
			t.elapsedDelay = t.delay;
			int num = Mathf.FloorToInt(to / t.duration);
			float num2 = to % t.duration;
			if (t.loops != -1 && num >= t.loops)
			{
				num = t.loops;
				num2 = t.duration;
			}
			else if (num2 >= t.duration)
			{
				num2 = 0f;
			}
			bool flag = Tween.DoGoto(t, num2, num, updateMode);
			if ((!andPlay & isPlaying) && !flag && t.onPause != null)
			{
				Tween.OnTweenCallback(t.onPause);
			}
			return flag;
		}

		internal static bool Pause(Tween t)
		{
			if (t.isPlaying)
			{
				t.isPlaying = false;
				if (t.onPause != null)
				{
					Tween.OnTweenCallback(t.onPause);
				}
				return true;
			}
			return false;
		}

		internal static bool Play(Tween t)
		{
			if (!t.isPlaying && ((!t.isBackwards && !t.isComplete) || (t.isBackwards && (t.completedLoops > 0 || t.position > 0f))))
			{
				t.isPlaying = true;
				if (t.playedOnce && t.delayComplete && t.onPlay != null)
				{
					Tween.OnTweenCallback(t.onPlay);
				}
				return true;
			}
			return false;
		}

		internal static bool PlayBackwards(Tween t)
		{
			if (!t.isBackwards)
			{
				t.isBackwards = true;
				TweenManager.Play(t);
				return true;
			}
			return TweenManager.Play(t);
		}

		internal static bool PlayForward(Tween t)
		{
			if (t.isBackwards)
			{
				t.isBackwards = false;
				TweenManager.Play(t);
				return true;
			}
			return TweenManager.Play(t);
		}

		internal static bool Restart(Tween t, bool includeDelay = true)
		{
			bool arg_1F_0 = !t.isPlaying;
			t.isBackwards = false;
			TweenManager.Rewind(t, includeDelay);
			t.isPlaying = true;
			if (arg_1F_0 && t.playedOnce && t.delayComplete && t.onPlay != null)
			{
				Tween.OnTweenCallback(t.onPlay);
			}
			return true;
		}

		internal static bool Rewind(Tween t, bool includeDelay = true)
		{
			bool isPlaying = t.isPlaying;
			t.isPlaying = false;
			bool result = false;
			if (t.delay > 0f)
			{
				if (includeDelay)
				{
					result = (t.delay > 0f && t.elapsedDelay > 0f);
					t.elapsedDelay = 0f;
					t.delayComplete = false;
				}
				else
				{
					result = (t.elapsedDelay < t.delay);
					t.elapsedDelay = t.delay;
					t.delayComplete = true;
				}
			}
			if (t.position > 0f || t.completedLoops > 0 || !t.startupDone)
			{
				result = true;
				if ((!Tween.DoGoto(t, 0f, 0, UpdateMode.Goto) & isPlaying) && t.onPause != null)
				{
					Tween.OnTweenCallback(t.onPause);
				}
			}
			return result;
		}

		internal static bool SmoothRewind(Tween t)
		{
			bool result = false;
			if (t.delay > 0f)
			{
				result = (t.elapsedDelay < t.delay);
				t.elapsedDelay = t.delay;
				t.delayComplete = true;
			}
			if (t.position > 0f || t.completedLoops > 0 || !t.startupDone)
			{
				result = true;
				if (t.loopType == LoopType.Incremental)
				{
					t.PlayBackwards();
				}
				else
				{
					t.Goto(t.ElapsedDirectionalPercentage() * t.duration, false);
					t.PlayBackwards();
				}
			}
			else
			{
				t.isPlaying = false;
			}
			return result;
		}

		internal static bool TogglePause(Tween t)
		{
			if (t.isPlaying)
			{
				return TweenManager.Pause(t);
			}
			return TweenManager.Play(t);
		}

		internal static int TotalPooledTweens()
		{
			return TweenManager.totPooledTweeners + TweenManager.totPooledSequences;
		}

		internal static int TotalPlayingTweens()
		{
			if (!TweenManager.hasActiveTweens)
			{
				return 0;
			}
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			int num = 0;
			for (int i = 0; i < TweenManager._maxActiveLookupId + 1; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween != null && tween.isPlaying)
				{
					num++;
				}
			}
			return num;
		}

		internal static List<Tween> GetActiveTweens(bool playing)
		{
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			if (TweenManager.totActiveTweens <= 0)
			{
				return null;
			}
			int num = TweenManager.totActiveTweens;
			List<Tween> list = new List<Tween>(num);
			for (int i = 0; i < num; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween.isPlaying == playing)
				{
					list.Add(tween);
				}
			}
			if (list.Count > 0)
			{
				return list;
			}
			return null;
		}

		internal static List<Tween> GetTweensById(object id, bool playingOnly)
		{
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			if (TweenManager.totActiveTweens <= 0)
			{
				return null;
			}
			int num = TweenManager.totActiveTweens;
			List<Tween> list = new List<Tween>(num);
			for (int i = 0; i < num; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween != null && object.Equals(id, tween.id) && (!playingOnly || tween.isPlaying))
				{
					list.Add(tween);
				}
			}
			if (list.Count > 0)
			{
				return list;
			}
			return null;
		}

		internal static List<Tween> GetTweensByTarget(object target, bool playingOnly)
		{
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			if (TweenManager.totActiveTweens <= 0)
			{
				return null;
			}
			int num = TweenManager.totActiveTweens;
			List<Tween> list = new List<Tween>(num);
			for (int i = 0; i < num; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween.target == target && (!playingOnly || tween.isPlaying))
				{
					list.Add(tween);
				}
			}
			if (list.Count > 0)
			{
				return list;
			}
			return null;
		}

		private static void MarkForKilling(Tween t)
		{
			t.active = false;
			TweenManager._KillList.Add(t);
		}

		private static void AddActiveTween(Tween t)
		{
			if (TweenManager._requiresActiveReorganization)
			{
				TweenManager.ReorganizeActiveTweens();
			}
			t.active = true;
			t.updateType = DOTween.defaultUpdateType;
			t.isIndependentUpdate = DOTween.defaultTimeScaleIndependent;
			t.activeId = (TweenManager._maxActiveLookupId = TweenManager.totActiveTweens);
			TweenManager._activeTweens[TweenManager.totActiveTweens] = t;
			if (t.updateType == UpdateType.Normal)
			{
				TweenManager.totActiveDefaultTweens++;
				TweenManager.hasActiveDefaultTweens = true;
			}
			else if (t.updateType == UpdateType.Fixed)
			{
				TweenManager.totActiveFixedTweens++;
				TweenManager.hasActiveFixedTweens = true;
			}
			else
			{
				TweenManager.totActiveLateTweens++;
				TweenManager.hasActiveLateTweens = true;
			}
			TweenManager.totActiveTweens++;
			if (t.tweenType == TweenType.Tweener)
			{
				TweenManager.totActiveTweeners++;
			}
			else
			{
				TweenManager.totActiveSequences++;
			}
			TweenManager.hasActiveTweens = true;
		}

		private static void ReorganizeActiveTweens()
		{
			if (TweenManager.totActiveTweens <= 0)
			{
				TweenManager._maxActiveLookupId = -1;
				TweenManager._requiresActiveReorganization = false;
				TweenManager._reorganizeFromId = -1;
				return;
			}
			if (TweenManager._reorganizeFromId == TweenManager._maxActiveLookupId)
			{
				TweenManager._maxActiveLookupId--;
				TweenManager._requiresActiveReorganization = false;
				TweenManager._reorganizeFromId = -1;
				return;
			}
			int num = 1;
			int num2 = TweenManager._maxActiveLookupId + 1;
			TweenManager._maxActiveLookupId = TweenManager._reorganizeFromId - 1;
			for (int i = TweenManager._reorganizeFromId + 1; i < num2; i++)
			{
				Tween tween = TweenManager._activeTweens[i];
				if (tween == null)
				{
					num++;
				}
				else
				{
					tween.activeId = (TweenManager._maxActiveLookupId = i - num);
					TweenManager._activeTweens[i - num] = tween;
					TweenManager._activeTweens[i] = null;
				}
			}
			TweenManager._requiresActiveReorganization = false;
			TweenManager._reorganizeFromId = -1;
		}

		private static void DespawnActiveTweens(List<Tween> tweens)
		{
			for (int i = tweens.Count - 1; i > -1; i--)
			{
				TweenManager.Despawn(tweens[i], true);
			}
		}

		private static void RemoveActiveTween(Tween t)
		{
			int activeId = t.activeId;
			t.activeId = -1;
			TweenManager._requiresActiveReorganization = true;
			if (TweenManager._reorganizeFromId == -1 || TweenManager._reorganizeFromId > activeId)
			{
				TweenManager._reorganizeFromId = activeId;
			}
			TweenManager._activeTweens[activeId] = null;
			if (t.updateType == UpdateType.Normal)
			{
				if (TweenManager.totActiveDefaultTweens > 0)
				{
					TweenManager.totActiveDefaultTweens--;
					TweenManager.hasActiveDefaultTweens = (TweenManager.totActiveDefaultTweens > 0);
				}
				else
				{
					Debugger.LogRemoveActiveTweenError("totActiveDefaultTweens");
				}
			}
			else if (t.updateType == UpdateType.Fixed)
			{
				if (TweenManager.totActiveFixedTweens > 0)
				{
					TweenManager.totActiveFixedTweens--;
					TweenManager.hasActiveFixedTweens = (TweenManager.totActiveFixedTweens > 0);
				}
				else
				{
					Debugger.LogRemoveActiveTweenError("totActiveFixedTweens");
				}
			}
			else if (TweenManager.totActiveLateTweens > 0)
			{
				TweenManager.totActiveLateTweens--;
				TweenManager.hasActiveLateTweens = (TweenManager.totActiveLateTweens > 0);
			}
			else
			{
				Debugger.LogRemoveActiveTweenError("totActiveLateTweens");
			}
			TweenManager.totActiveTweens--;
			TweenManager.hasActiveTweens = (TweenManager.totActiveTweens > 0);
			if (t.tweenType == TweenType.Tweener)
			{
				TweenManager.totActiveTweeners--;
			}
			else
			{
				TweenManager.totActiveSequences--;
			}
			if (TweenManager.totActiveTweens < 0)
			{
				TweenManager.totActiveTweens = 0;
				Debugger.LogRemoveActiveTweenError("totActiveTweens");
			}
			if (TweenManager.totActiveTweeners < 0)
			{
				TweenManager.totActiveTweeners = 0;
				Debugger.LogRemoveActiveTweenError("totActiveTweeners");
			}
			if (TweenManager.totActiveSequences < 0)
			{
				TweenManager.totActiveSequences = 0;
				Debugger.LogRemoveActiveTweenError("totActiveSequences");
			}
		}

		private static void ClearTweenArray(Tween[] tweens)
		{
			int num = tweens.Length;
			for (int i = 0; i < num; i++)
			{
				tweens[i] = null;
			}
		}

		private static void IncreaseCapacities(TweenManager.CapacityIncreaseMode increaseMode)
		{
			int num = 0;
			int num2 = Mathf.Max((int)((float)TweenManager.maxTweeners * 1.5f), 200);
			int num3 = Mathf.Max((int)((float)TweenManager.maxSequences * 1.5f), 50);
			if (increaseMode != TweenManager.CapacityIncreaseMode.TweenersOnly)
			{
				if (increaseMode != TweenManager.CapacityIncreaseMode.SequencesOnly)
				{
					num += num2;
					TweenManager.maxTweeners += num2;
					TweenManager.maxSequences += num3;
					Array.Resize<Tween>(ref TweenManager._pooledTweeners, TweenManager.maxTweeners);
				}
				else
				{
					num += num3;
					TweenManager.maxSequences += num3;
				}
			}
			else
			{
				num += num2;
				TweenManager.maxTweeners += num2;
				Array.Resize<Tween>(ref TweenManager._pooledTweeners, TweenManager.maxTweeners);
			}
			TweenManager.maxActive = TweenManager.maxTweeners + TweenManager.maxSequences;
			Array.Resize<Tween>(ref TweenManager._activeTweens, TweenManager.maxActive);
			if (num > 0)
			{
				TweenManager._KillList.Capacity += num;
			}
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Core
{
	internal static class Utils
	{
		internal static Vector3 Vector3FromAngle(float degrees, float magnitude)
		{
			float f = degrees * 0.0174532924f;
			return new Vector3(magnitude * Mathf.Cos(f), magnitude * Mathf.Sin(f), 0f);
		}

		internal static float Angle2D(Vector3 from, Vector3 to)
		{
			Vector2 arg_0E_0 = Vector2.right;
			to -= from;
			float num = Vector2.Angle(arg_0E_0, to);
			if (Vector3.Cross(arg_0E_0, to).z > 0f)
			{
				num = 360f - num;
			}
			return num * -1f;
		}
	}
}

// Decompile from assembly: DOTween.dll

using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core;
using DG.Tweening.Plugins.Options;
using System;

namespace DG.Tweening.Core
{
	public class TweenerCore<T1, T2, TPlugOptions> : Tweener where TPlugOptions : struct, IPlugOptions
	{
		public T2 startValue;

		public T2 endValue;

		public T2 changeValue;

		public TPlugOptions plugOptions;

		public DOGetter<T1> getter;

		public DOSetter<T1> setter;

		internal ABSTweenPlugin<T1, T2, TPlugOptions> tweenPlugin;

		private const string _TxtCantChangeSequencedValues = "You cannot change the values of a tween contained inside a Sequence";

		internal TweenerCore()
		{
			this.typeofT1 = typeof(T1);
			this.typeofT2 = typeof(T2);
			this.typeofTPlugOptions = typeof(TPlugOptions);
			this.tweenType = TweenType.Tweener;
			this.Reset();
		}

		public override Tweener ChangeStartValue(object newStartValue, float newDuration = -1f)
		{
			if (this.isSequenced)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning("You cannot change the values of a tween contained inside a Sequence");
				}
				return this;
			}
			Type type = newStartValue.GetType();
			if (type != this.typeofT2)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning(string.Concat(new object[]
					{
						"ChangeStartValue: incorrect newStartValue type (is ",
						type,
						", should be ",
						this.typeofT2,
						")"
					}));
				}
				return this;
			}
			return Tweener.DoChangeStartValue<T1, T2, TPlugOptions>(this, (T2)((object)newStartValue), newDuration);
		}

		public override Tweener ChangeEndValue(object newEndValue, bool snapStartValue)
		{
			return this.ChangeEndValue(newEndValue, -1f, snapStartValue);
		}

		public override Tweener ChangeEndValue(object newEndValue, float newDuration = -1f, bool snapStartValue = false)
		{
			if (this.isSequenced)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning("You cannot change the values of a tween contained inside a Sequence");
				}
				return this;
			}
			Type type = newEndValue.GetType();
			if (type != this.typeofT2)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning(string.Concat(new object[]
					{
						"ChangeEndValue: incorrect newEndValue type (is ",
						type,
						", should be ",
						this.typeofT2,
						")"
					}));
				}
				return this;
			}
			return Tweener.DoChangeEndValue<T1, T2, TPlugOptions>(this, (T2)((object)newEndValue), newDuration, snapStartValue);
		}

		public override Tweener ChangeValues(object newStartValue, object newEndValue, float newDuration = -1f)
		{
			if (this.isSequenced)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning("You cannot change the values of a tween contained inside a Sequence");
				}
				return this;
			}
			Type type = newStartValue.GetType();
			Type type2 = newEndValue.GetType();
			if (type != this.typeofT2)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning(string.Concat(new object[]
					{
						"ChangeValues: incorrect value type (is ",
						type,
						", should be ",
						this.typeofT2,
						")"
					}));
				}
				return this;
			}
			if (type2 != this.typeofT2)
			{
				if (Debugger.logPriority >= 1)
				{
					Debugger.LogWarning(string.Concat(new object[]
					{
						"ChangeValues: incorrect value type (is ",
						type2,
						", should be ",
						this.typeofT2,
						")"
					}));
				}
				return this;
			}
			return Tweener.DoChangeValues<T1, T2, TPlugOptions>(this, (T2)((object)newStartValue), (T2)((object)newEndValue), newDuration);
		}

		internal override Tweener SetFrom(bool relative)
		{
			this.tweenPlugin.SetFrom(this, relative);
			this.hasManuallySetStartValue = true;
			return this;
		}

		internal sealed override void Reset()
		{
			base.Reset();
			if (this.tweenPlugin != null)
			{
				this.tweenPlugin.Reset(this);
			}
			this.plugOptions.Reset();
			this.getter = null;
			this.setter = null;
			this.hasManuallySetStartValue = false;
			this.isFromAllowed = true;
		}

		internal override bool Validate()
		{
			try
			{
				this.getter();
			}
			catch
			{
				return false;
			}
			return true;
		}

		internal override float UpdateDelay(float elapsed)
		{
			return Tweener.DoUpdateDelay<T1, T2, TPlugOptions>(this, elapsed);
		}

		internal override bool Startup()
		{
			return Tweener.DoStartup<T1, T2, TPlugOptions>(this);
		}

		internal override bool ApplyTween(float prevPosition, int prevCompletedLoops, int newCompletedSteps, bool useInversePosition, UpdateMode updateMode, UpdateNotice updateNotice)
		{
			float elapsed = useInversePosition ? (this.duration - this.position) : this.position;
			if (DOTween.useSafeMode)
			{
				try
				{
					this.tweenPlugin.EvaluateAndApply(this.plugOptions, this, this.isRelative, this.getter, this.setter, elapsed, this.startValue, this.changeValue, this.duration, useInversePosition, updateNotice);
					return false;
				}
				catch
				{
					return true;
				}
			}
			this.tweenPlugin.EvaluateAndApply(this.plugOptions, this, this.isRelative, this.getter, this.setter, elapsed, this.startValue, this.changeValue, this.duration, useInversePosition, updateNotice);
			return false;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core.Enums
{
	internal enum FilterType
	{
		All,
		TargetOrId,
		TargetAndId,
		AllExceptTargetsOrIds,
		DOGetter
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core.Enums
{
	internal enum OperationType
	{
		Complete,
		Despawn,
		Flip,
		Goto,
		Pause,
		Play,
		PlayForward,
		PlayBackwards,
		Rewind,
		SmoothRewind,
		Restart,
		TogglePause,
		IsTweening
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core.Enums
{
	internal enum SpecialStartupMode
	{
		None,
		SetLookAt,
		SetShake,
		SetPunch,
		SetCameraShakePosition
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core.Enums
{
	public enum UpdateNotice
	{
		None,
		RewindStep
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core.Enums
{
	internal enum UpdateMode
	{
		Update,
		Goto,
		IgnoreOnUpdate
	}
}

// Decompile from assembly: DOTween.dll

using System;

namespace DG.Tweening.Core.Easing
{
	public static class Bounce
	{
		public static float EaseIn(float time, float duration, float unusedOvershootOrAmplitude, float unusedPeriod)
		{
			return 1f - Bounce.EaseOut(duration - time, duration, -1f, -1f);
		}

		public static float EaseOut(float time, float duration, float unusedOvershootOrAmplitude, float unusedPeriod)
		{
			if ((time /= duration) < 0.363636374f)
			{
				return 7.5625f * time * time;
			}
			if (time < 0.727272749f)
			{
				return 7.5625f * (time -= 0.545454562f) * time + 0.75f;
			}
			if (time < 0.909090936f)
			{
				return 7.5625f * (time -= 0.8181818f) * time + 0.9375f;
			}
			return 7.5625f * (time -= 0.954545438f) * time + 0.984375f;
		}

		public static float EaseInOut(float time, float duration, float unusedOvershootOrAmplitude, float unusedPeriod)
		{
			if (time < duration * 0.5f)
			{
				return Bounce.EaseIn(time * 2f, duration, -1f, -1f) * 0.5f;
			}
			return Bounce.EaseOut(time * 2f - duration, duration, -1f, -1f) * 0.5f + 0.5f;
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using System.Runtime.CompilerServices;

namespace DG.Tweening.Core.Easing
{
	public static class EaseManager
	{
		[Serializable]
		private sealed class __c
		{
			public static readonly EaseManager.__c __9 = new EaseManager.__c();

			public static EaseFunction __9__4_0;

			public static EaseFunction __9__4_1;

			public static EaseFunction __9__4_2;

			public static EaseFunction __9__4_3;

			public static EaseFunction __9__4_4;

			public static EaseFunction __9__4_5;

			public static EaseFunction __9__4_6;

			public static EaseFunction __9__4_7;

			public static EaseFunction __9__4_8;

			public static EaseFunction __9__4_9;

			public static EaseFunction __9__4_10;

			public static EaseFunction __9__4_11;

			public static EaseFunction __9__4_12;

			public static EaseFunction __9__4_13;

			public static EaseFunction __9__4_14;

			public static EaseFunction __9__4_15;

			public static EaseFunction __9__4_16;

			public static EaseFunction __9__4_17;

			public static EaseFunction __9__4_18;

			public static EaseFunction __9__4_19;

			public static EaseFunction __9__4_20;

			public static EaseFunction __9__4_21;

			public static EaseFunction __9__4_22;

			public static EaseFunction __9__4_23;

			public static EaseFunction __9__4_24;

			public static EaseFunction __9__4_25;

			public static EaseFunction __9__4_26;

			public static EaseFunction __9__4_27;

			public static EaseFunction __9__4_28;

			public static EaseFunction __9__4_29;

			public static EaseFunction __9__4_30;

			public static EaseFunction __9__4_31;

			public static EaseFunction __9__4_32;

			public static EaseFunction __9__4_33;

			public static EaseFunction __9__4_34;

			public static EaseFunction __9__4_35;

			internal float _ToEaseFunction_b__4_0(float time, float duration, float overshootOrAmplitude, float period)
			{
				return time / duration;
			}

			internal float _ToEaseFunction_b__4_1(float time, float duration, float overshootOrAmplitude, float period)
			{
				return -(float)Math.Cos((double)(time / duration * 1.57079637f)) + 1f;
			}

			internal float _ToEaseFunction_b__4_2(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (float)Math.Sin((double)(time / duration * 1.57079637f));
			}

			internal float _ToEaseFunction_b__4_3(float time, float duration, float overshootOrAmplitude, float period)
			{
				return -0.5f * ((float)Math.Cos((double)(3.14159274f * time / duration)) - 1f);
			}

			internal float _ToEaseFunction_b__4_4(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time /= duration) * time;
			}

			internal float _ToEaseFunction_b__4_5(float time, float duration, float overshootOrAmplitude, float period)
			{
				return -(time /= duration) * (time - 2f);
			}

			internal float _ToEaseFunction_b__4_6(float time, float duration, float overshootOrAmplitude, float period)
			{
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time;
				}
				return -0.5f * ((time -= 1f) * (time - 2f) - 1f);
			}

			internal float _ToEaseFunction_b__4_7(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time /= duration) * time * time;
			}

			internal float _ToEaseFunction_b__4_8(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time = time / duration - 1f) * time * time + 1f;
			}

			internal float _ToEaseFunction_b__4_9(float time, float duration, float overshootOrAmplitude, float period)
			{
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time * time;
				}
				return 0.5f * ((time -= 2f) * time * time + 2f);
			}

			internal float _ToEaseFunction_b__4_10(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time /= duration) * time * time * time;
			}

			internal float _ToEaseFunction_b__4_11(float time, float duration, float overshootOrAmplitude, float period)
			{
				return -((time = time / duration - 1f) * time * time * time - 1f);
			}

			internal float _ToEaseFunction_b__4_12(float time, float duration, float overshootOrAmplitude, float period)
			{
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time * time * time;
				}
				return -0.5f * ((time -= 2f) * time * time * time - 2f);
			}

			internal float _ToEaseFunction_b__4_13(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time /= duration) * time * time * time * time;
			}

			internal float _ToEaseFunction_b__4_14(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time = time / duration - 1f) * time * time * time * time + 1f;
			}

			internal float _ToEaseFunction_b__4_15(float time, float duration, float overshootOrAmplitude, float period)
			{
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time * time * time * time;
				}
				return 0.5f * ((time -= 2f) * time * time * time * time + 2f);
			}

			internal float _ToEaseFunction_b__4_16(float time, float duration, float overshootOrAmplitude, float period)
			{
				if (time != 0f)
				{
					return (float)Math.Pow(2.0, (double)(10f * (time / duration - 1f)));
				}
				return 0f;
			}

			internal float _ToEaseFunction_b__4_17(float time, float duration, float overshootOrAmplitude, float period)
			{
				if (time == duration)
				{
					return 1f;
				}
				return -(float)Math.Pow(2.0, (double)(-10f * time / duration)) + 1f;
			}

			internal float _ToEaseFunction_b__4_18(float time, float duration, float overshootOrAmplitude, float period)
			{
				if (time == 0f)
				{
					return 0f;
				}
				if (time == duration)
				{
					return 1f;
				}
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * (float)Math.Pow(2.0, (double)(10f * (time - 1f)));
				}
				return 0.5f * (-(float)Math.Pow(2.0, (double)(-10f * (time -= 1f))) + 2f);
			}

			internal float _ToEaseFunction_b__4_19(float time, float duration, float overshootOrAmplitude, float period)
			{
				return -((float)Math.Sqrt((double)(1f - (time /= duration) * time)) - 1f);
			}

			internal float _ToEaseFunction_b__4_20(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (float)Math.Sqrt((double)(1f - (time = time / duration - 1f) * time));
			}

			internal float _ToEaseFunction_b__4_21(float time, float duration, float overshootOrAmplitude, float period)
			{
				if ((time /= duration * 0.5f) < 1f)
				{
					return -0.5f * ((float)Math.Sqrt((double)(1f - time * time)) - 1f);
				}
				return 0.5f * ((float)Math.Sqrt((double)(1f - (time -= 2f) * time)) + 1f);
			}

			internal float _ToEaseFunction_b__4_22(float time, float duration, float overshootOrAmplitude, float period)
			{
				if (time == 0f)
				{
					return 0f;
				}
				if ((time /= duration) == 1f)
				{
					return 1f;
				}
				if (period == 0f)
				{
					period = duration * 0.3f;
				}
				float num;
				if (overshootOrAmplitude < 1f)
				{
					overshootOrAmplitude = 1f;
					num = period / 4f;
				}
				else
				{
					num = period / 6.28318548f * (float)Math.Asin((double)(1f / overshootOrAmplitude));
				}
				return -(overshootOrAmplitude * (float)Math.Pow(2.0, (double)(10f * (time -= 1f))) * (float)Math.Sin((double)((time * duration - num) * 6.28318548f / period)));
			}

			internal float _ToEaseFunction_b__4_23(float time, float duration, float overshootOrAmplitude, float period)
			{
				if (time == 0f)
				{
					return 0f;
				}
				if ((time /= duration) == 1f)
				{
					return 1f;
				}
				if (period == 0f)
				{
					period = duration * 0.3f;
				}
				float num;
				if (overshootOrAmplitude < 1f)
				{
					overshootOrAmplitude = 1f;
					num = period / 4f;
				}
				else
				{
					num = period / 6.28318548f * (float)Math.Asin((double)(1f / overshootOrAmplitude));
				}
				return overshootOrAmplitude * (float)Math.Pow(2.0, (double)(-10f * time)) * (float)Math.Sin((double)((time * duration - num) * 6.28318548f / period)) + 1f;
			}

			internal float _ToEaseFunction_b__4_24(float time, float duration, float overshootOrAmplitude, float period)
			{
				if (time == 0f)
				{
					return 0f;
				}
				if ((time /= duration * 0.5f) == 2f)
				{
					return 1f;
				}
				if (period == 0f)
				{
					period = duration * 0.450000018f;
				}
				float num;
				if (overshootOrAmplitude < 1f)
				{
					overshootOrAmplitude = 1f;
					num = period / 4f;
				}
				else
				{
					num = period / 6.28318548f * (float)Math.Asin((double)(1f / overshootOrAmplitude));
				}
				if (time < 1f)
				{
					return -0.5f * (overshootOrAmplitude * (float)Math.Pow(2.0, (double)(10f * (time -= 1f))) * (float)Math.Sin((double)((time * duration - num) * 6.28318548f / period)));
				}
				return overshootOrAmplitude * (float)Math.Pow(2.0, (double)(-10f * (time -= 1f))) * (float)Math.Sin((double)((time * duration - num) * 6.28318548f / period)) * 0.5f + 1f;
			}

			internal float _ToEaseFunction_b__4_25(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time /= duration) * time * ((overshootOrAmplitude + 1f) * time - overshootOrAmplitude);
			}

			internal float _ToEaseFunction_b__4_26(float time, float duration, float overshootOrAmplitude, float period)
			{
				return (time = time / duration - 1f) * time * ((overshootOrAmplitude + 1f) * time + overshootOrAmplitude) + 1f;
			}

			internal float _ToEaseFunction_b__4_27(float time, float duration, float overshootOrAmplitude, float period)
			{
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * (time * time * (((overshootOrAmplitude *= 1.525f) + 1f) * time - overshootOrAmplitude));
				}
				return 0.5f * ((time -= 2f) * time * (((overshootOrAmplitude *= 1.525f) + 1f) * time + overshootOrAmplitude) + 2f);
			}

			internal float _ToEaseFunction_b__4_28(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Bounce.EaseIn(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_29(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Bounce.EaseOut(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_30(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Bounce.EaseInOut(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_31(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Flash.Ease(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_32(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Flash.EaseIn(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_33(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Flash.EaseOut(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_34(float time, float duration, float overshootOrAmplitude, float period)
			{
				return Flash.EaseInOut(time, duration, overshootOrAmplitude, period);
			}

			internal float _ToEaseFunction_b__4_35(float time, float duration, float overshootOrAmplitude, float period)
			{
				return -(time /= duration) * (time - 2f);
			}
		}

		private const float _PiOver2 = 1.57079637f;

		private const float _TwoPi = 6.28318548f;

		public static float Evaluate(Tween t, float time, float duration, float overshootOrAmplitude, float period)
		{
			return EaseManager.Evaluate(t.easeType, t.customEase, time, duration, overshootOrAmplitude, period);
		}

		public static float Evaluate(Ease easeType, EaseFunction customEase, float time, float duration, float overshootOrAmplitude, float period)
		{
			switch (easeType)
			{
			case Ease.Linear:
				return time / duration;
			case Ease.InSine:
				return -(float)Math.Cos((double)(time / duration * 1.57079637f)) + 1f;
			case Ease.OutSine:
				return (float)Math.Sin((double)(time / duration * 1.57079637f));
			case Ease.InOutSine:
				return -0.5f * ((float)Math.Cos((double)(3.14159274f * time / duration)) - 1f);
			case Ease.InQuad:
				return (time /= duration) * time;
			case Ease.OutQuad:
				return -(time /= duration) * (time - 2f);
			case Ease.InOutQuad:
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time;
				}
				return -0.5f * ((time -= 1f) * (time - 2f) - 1f);
			case Ease.InCubic:
				return (time /= duration) * time * time;
			case Ease.OutCubic:
				return (time = time / duration - 1f) * time * time + 1f;
			case Ease.InOutCubic:
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time * time;
				}
				return 0.5f * ((time -= 2f) * time * time + 2f);
			case Ease.InQuart:
				return (time /= duration) * time * time * time;
			case Ease.OutQuart:
				return -((time = time / duration - 1f) * time * time * time - 1f);
			case Ease.InOutQuart:
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time * time * time;
				}
				return -0.5f * ((time -= 2f) * time * time * time - 2f);
			case Ease.InQuint:
				return (time /= duration) * time * time * time * time;
			case Ease.OutQuint:
				return (time = time / duration - 1f) * time * time * time * time + 1f;
			case Ease.InOutQuint:
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * time * time * time * time * time;
				}
				return 0.5f * ((time -= 2f) * time * time * time * time + 2f);
			case Ease.InExpo:
				if (time != 0f)
				{
					return (float)Math.Pow(2.0, (double)(10f * (time / duration - 1f)));
				}
				return 0f;
			case Ease.OutExpo:
				if (time == duration)
				{
					return 1f;
				}
				return -(float)Math.Pow(2.0, (double)(-10f * time / duration)) + 1f;
			case Ease.InOutExpo:
				if (time == 0f)
				{
					return 0f;
				}
				if (time == duration)
				{
					return 1f;
				}
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * (float)Math.Pow(2.0, (double)(10f * (time - 1f)));
				}
				return 0.5f * (-(float)Math.Pow(2.0, (double)(-10f * (time -= 1f))) + 2f);
			case Ease.InCirc:
				return -((float)Math.Sqrt((double)(1f - (time /= duration) * time)) - 1f);
			case Ease.OutCirc:
				return (float)Math.Sqrt((double)(1f - (time = time / duration - 1f) * time));
			case Ease.InOutCirc:
				if ((time /= duration * 0.5f) < 1f)
				{
					return -0.5f * ((float)Math.Sqrt((double)(1f - time * time)) - 1f);
				}
				return 0.5f * ((float)Math.Sqrt((double)(1f - (time -= 2f) * time)) + 1f);
			case Ease.InElastic:
			{
				if (time == 0f)
				{
					return 0f;
				}
				if ((time /= duration) == 1f)
				{
					return 1f;
				}
				if (period == 0f)
				{
					period = duration * 0.3f;
				}
				float num;
				if (overshootOrAmplitude < 1f)
				{
					overshootOrAmplitude = 1f;
					num = period / 4f;
				}
				else
				{
					num = period / 6.28318548f * (float)Math.Asin((double)(1f / overshootOrAmplitude));
				}
				return -(overshootOrAmplitude * (float)Math.Pow(2.0, (double)(10f * (time -= 1f))) * (float)Math.Sin((double)((time * duration - num) * 6.28318548f / period)));
			}
			case Ease.OutElastic:
			{
				if (time == 0f)
				{
					return 0f;
				}
				if ((time /= duration) == 1f)
				{
					return 1f;
				}
				if (period == 0f)
				{
					period = duration * 0.3f;
				}
				float num2;
				if (overshootOrAmplitude < 1f)
				{
					overshootOrAmplitude = 1f;
					num2 = period / 4f;
				}
				else
				{
					num2 = period / 6.28318548f * (float)Math.Asin((double)(1f / overshootOrAmplitude));
				}
				return overshootOrAmplitude * (float)Math.Pow(2.0, (double)(-10f * time)) * (float)Math.Sin((double)((time * duration - num2) * 6.28318548f / period)) + 1f;
			}
			case Ease.InOutElastic:
			{
				if (time == 0f)
				{
					return 0f;
				}
				if ((time /= duration * 0.5f) == 2f)
				{
					return 1f;
				}
				if (period == 0f)
				{
					period = duration * 0.450000018f;
				}
				float num3;
				if (overshootOrAmplitude < 1f)
				{
					overshootOrAmplitude = 1f;
					num3 = period / 4f;
				}
				else
				{
					num3 = period / 6.28318548f * (float)Math.Asin((double)(1f / overshootOrAmplitude));
				}
				if (time < 1f)
				{
					return -0.5f * (overshootOrAmplitude * (float)Math.Pow(2.0, (double)(10f * (time -= 1f))) * (float)Math.Sin((double)((time * duration - num3) * 6.28318548f / period)));
				}
				return overshootOrAmplitude * (float)Math.Pow(2.0, (double)(-10f * (time -= 1f))) * (float)Math.Sin((double)((time * duration - num3) * 6.28318548f / period)) * 0.5f + 1f;
			}
			case Ease.InBack:
				return (time /= duration) * time * ((overshootOrAmplitude + 1f) * time - overshootOrAmplitude);
			case Ease.OutBack:
				return (time = time / duration - 1f) * time * ((overshootOrAmplitude + 1f) * time + overshootOrAmplitude) + 1f;
			case Ease.InOutBack:
				if ((time /= duration * 0.5f) < 1f)
				{
					return 0.5f * (time * time * (((overshootOrAmplitude *= 1.525f) + 1f) * time - overshootOrAmplitude));
				}
				return 0.5f * ((time -= 2f) * time * (((overshootOrAmplitude *= 1.525f) + 1f) * time + overshootOrAmplitude) + 2f);
			case Ease.InBounce:
				return Bounce.EaseIn(time, duration, overshootOrAmplitude, period);
			case Ease.OutBounce:
				return Bounce.EaseOut(time, duration, overshootOrAmplitude, period);
			case Ease.InOutBounce:
				return Bounce.EaseInOut(time, duration, overshootOrAmplitude, period);
			case Ease.Flash:
				return Flash.Ease(time, duration, overshootOrAmplitude, period);
			case Ease.InFlash:
				return Flash.EaseIn(time, duration, overshootOrAmplitude, period);
			case Ease.OutFlash:
				return Flash.EaseOut(time, duration, overshootOrAmplitude, period);
			case Ease.InOutFlash:
				return Flash.EaseInOut(time, duration, overshootOrAmplitude, period);
			case Ease.INTERNAL_Zero:
				return 1f;
			case Ease.INTERNAL_Custom:
				return customEase(time, duration, overshootOrAmplitude, period);
			default:
				return -(time /= duration) * (time - 2f);
			}
		}

		public static EaseFunction ToEaseFunction(Ease ease)
		{
			switch (ease)
			{
			case Ease.Linear:
			{
				EaseFunction arg_B8_0;
				if ((arg_B8_0 = EaseManager.__c.__9__4_0) == null)
				{
					arg_B8_0 = (EaseManager.__c.__9__4_0 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_0));
				}
				return arg_B8_0;
			}
			case Ease.InSine:
			{
				EaseFunction arg_D8_0;
				if ((arg_D8_0 = EaseManager.__c.__9__4_1) == null)
				{
					arg_D8_0 = (EaseManager.__c.__9__4_1 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_1));
				}
				return arg_D8_0;
			}
			case Ease.OutSine:
			{
				EaseFunction arg_F8_0;
				if ((arg_F8_0 = EaseManager.__c.__9__4_2) == null)
				{
					arg_F8_0 = (EaseManager.__c.__9__4_2 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_2));
				}
				return arg_F8_0;
			}
			case Ease.InOutSine:
			{
				EaseFunction arg_118_0;
				if ((arg_118_0 = EaseManager.__c.__9__4_3) == null)
				{
					arg_118_0 = (EaseManager.__c.__9__4_3 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_3));
				}
				return arg_118_0;
			}
			case Ease.InQuad:
			{
				EaseFunction arg_138_0;
				if ((arg_138_0 = EaseManager.__c.__9__4_4) == null)
				{
					arg_138_0 = (EaseManager.__c.__9__4_4 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_4));
				}
				return arg_138_0;
			}
			case Ease.OutQuad:
			{
				EaseFunction arg_158_0;
				if ((arg_158_0 = EaseManager.__c.__9__4_5) == null)
				{
					arg_158_0 = (EaseManager.__c.__9__4_5 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_5));
				}
				return arg_158_0;
			}
			case Ease.InOutQuad:
			{
				EaseFunction arg_178_0;
				if ((arg_178_0 = EaseManager.__c.__9__4_6) == null)
				{
					arg_178_0 = (EaseManager.__c.__9__4_6 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_6));
				}
				return arg_178_0;
			}
			case Ease.InCubic:
			{
				EaseFunction arg_198_0;
				if ((arg_198_0 = EaseManager.__c.__9__4_7) == null)
				{
					arg_198_0 = (EaseManager.__c.__9__4_7 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_7));
				}
				return arg_198_0;
			}
			case Ease.OutCubic:
			{
				EaseFunction arg_1B8_0;
				if ((arg_1B8_0 = EaseManager.__c.__9__4_8) == null)
				{
					arg_1B8_0 = (EaseManager.__c.__9__4_8 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_8));
				}
				return arg_1B8_0;
			}
			case Ease.InOutCubic:
			{
				EaseFunction arg_1D8_0;
				if ((arg_1D8_0 = EaseManager.__c.__9__4_9) == null)
				{
					arg_1D8_0 = (EaseManager.__c.__9__4_9 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_9));
				}
				return arg_1D8_0;
			}
			case Ease.InQuart:
			{
				EaseFunction arg_1F8_0;
				if ((arg_1F8_0 = EaseManager.__c.__9__4_10) == null)
				{
					arg_1F8_0 = (EaseManager.__c.__9__4_10 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_10));
				}
				return arg_1F8_0;
			}
			case Ease.OutQuart:
			{
				EaseFunction arg_218_0;
				if ((arg_218_0 = EaseManager.__c.__9__4_11) == null)
				{
					arg_218_0 = (EaseManager.__c.__9__4_11 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_11));
				}
				return arg_218_0;
			}
			case Ease.InOutQuart:
			{
				EaseFunction arg_238_0;
				if ((arg_238_0 = EaseManager.__c.__9__4_12) == null)
				{
					arg_238_0 = (EaseManager.__c.__9__4_12 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_12));
				}
				return arg_238_0;
			}
			case Ease.InQuint:
			{
				EaseFunction arg_258_0;
				if ((arg_258_0 = EaseManager.__c.__9__4_13) == null)
				{
					arg_258_0 = (EaseManager.__c.__9__4_13 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_13));
				}
				return arg_258_0;
			}
			case Ease.OutQuint:
			{
				EaseFunction arg_278_0;
				if ((arg_278_0 = EaseManager.__c.__9__4_14) == null)
				{
					arg_278_0 = (EaseManager.__c.__9__4_14 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_14));
				}
				return arg_278_0;
			}
			case Ease.InOutQuint:
			{
				EaseFunction arg_298_0;
				if ((arg_298_0 = EaseManager.__c.__9__4_15) == null)
				{
					arg_298_0 = (EaseManager.__c.__9__4_15 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_15));
				}
				return arg_298_0;
			}
			case Ease.InExpo:
			{
				EaseFunction arg_2B8_0;
				if ((arg_2B8_0 = EaseManager.__c.__9__4_16) == null)
				{
					arg_2B8_0 = (EaseManager.__c.__9__4_16 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_16));
				}
				return arg_2B8_0;
			}
			case Ease.OutExpo:
			{
				EaseFunction arg_2D8_0;
				if ((arg_2D8_0 = EaseManager.__c.__9__4_17) == null)
				{
					arg_2D8_0 = (EaseManager.__c.__9__4_17 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_17));
				}
				return arg_2D8_0;
			}
			case Ease.InOutExpo:
			{
				EaseFunction arg_2F8_0;
				if ((arg_2F8_0 = EaseManager.__c.__9__4_18) == null)
				{
					arg_2F8_0 = (EaseManager.__c.__9__4_18 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_18));
				}
				return arg_2F8_0;
			}
			case Ease.InCirc:
			{
				EaseFunction arg_318_0;
				if ((arg_318_0 = EaseManager.__c.__9__4_19) == null)
				{
					arg_318_0 = (EaseManager.__c.__9__4_19 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_19));
				}
				return arg_318_0;
			}
			case Ease.OutCirc:
			{
				EaseFunction arg_338_0;
				if ((arg_338_0 = EaseManager.__c.__9__4_20) == null)
				{
					arg_338_0 = (EaseManager.__c.__9__4_20 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_20));
				}
				return arg_338_0;
			}
			case Ease.InOutCirc:
			{
				EaseFunction arg_358_0;
				if ((arg_358_0 = EaseManager.__c.__9__4_21) == null)
				{
					arg_358_0 = (EaseManager.__c.__9__4_21 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_21));
				}
				return arg_358_0;
			}
			case Ease.InElastic:
			{
				EaseFunction arg_378_0;
				if ((arg_378_0 = EaseManager.__c.__9__4_22) == null)
				{
					arg_378_0 = (EaseManager.__c.__9__4_22 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_22));
				}
				return arg_378_0;
			}
			case Ease.OutElastic:
			{
				EaseFunction arg_398_0;
				if ((arg_398_0 = EaseManager.__c.__9__4_23) == null)
				{
					arg_398_0 = (EaseManager.__c.__9__4_23 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_23));
				}
				return arg_398_0;
			}
			case Ease.InOutElastic:
			{
				EaseFunction arg_3B8_0;
				if ((arg_3B8_0 = EaseManager.__c.__9__4_24) == null)
				{
					arg_3B8_0 = (EaseManager.__c.__9__4_24 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_24));
				}
				return arg_3B8_0;
			}
			case Ease.InBack:
			{
				EaseFunction arg_3D8_0;
				if ((arg_3D8_0 = EaseManager.__c.__9__4_25) == null)
				{
					arg_3D8_0 = (EaseManager.__c.__9__4_25 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_25));
				}
				return arg_3D8_0;
			}
			case Ease.OutBack:
			{
				EaseFunction arg_3F8_0;
				if ((arg_3F8_0 = EaseManager.__c.__9__4_26) == null)
				{
					arg_3F8_0 = (EaseManager.__c.__9__4_26 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_26));
				}
				return arg_3F8_0;
			}
			case Ease.InOutBack:
			{
				EaseFunction arg_418_0;
				if ((arg_418_0 = EaseManager.__c.__9__4_27) == null)
				{
					arg_418_0 = (EaseManager.__c.__9__4_27 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_27));
				}
				return arg_418_0;
			}
			case Ease.InBounce:
			{
				EaseFunction arg_438_0;
				if ((arg_438_0 = EaseManager.__c.__9__4_28) == null)
				{
					arg_438_0 = (EaseManager.__c.__9__4_28 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_28));
				}
				return arg_438_0;
			}
			case Ease.OutBounce:
			{
				EaseFunction arg_458_0;
				if ((arg_458_0 = EaseManager.__c.__9__4_29) == null)
				{
					arg_458_0 = (EaseManager.__c.__9__4_29 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_29));
				}
				return arg_458_0;
			}
			case Ease.InOutBounce:
			{
				EaseFunction arg_478_0;
				if ((arg_478_0 = EaseManager.__c.__9__4_30) == null)
				{
					arg_478_0 = (EaseManager.__c.__9__4_30 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_30));
				}
				return arg_478_0;
			}
			case Ease.Flash:
			{
				EaseFunction arg_498_0;
				if ((arg_498_0 = EaseManager.__c.__9__4_31) == null)
				{
					arg_498_0 = (EaseManager.__c.__9__4_31 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_31));
				}
				return arg_498_0;
			}
			case Ease.InFlash:
			{
				EaseFunction arg_4B8_0;
				if ((arg_4B8_0 = EaseManager.__c.__9__4_32) == null)
				{
					arg_4B8_0 = (EaseManager.__c.__9__4_32 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_32));
				}
				return arg_4B8_0;
			}
			case Ease.OutFlash:
			{
				EaseFunction arg_4D8_0;
				if ((arg_4D8_0 = EaseManager.__c.__9__4_33) == null)
				{
					arg_4D8_0 = (EaseManager.__c.__9__4_33 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_33));
				}
				return arg_4D8_0;
			}
			case Ease.InOutFlash:
			{
				EaseFunction arg_4F8_0;
				if ((arg_4F8_0 = EaseManager.__c.__9__4_34) == null)
				{
					arg_4F8_0 = (EaseManager.__c.__9__4_34 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_34));
				}
				return arg_4F8_0;
			}
			default:
			{
				EaseFunction arg_518_0;
				if ((arg_518_0 = EaseManager.__c.__9__4_35) == null)
				{
					arg_518_0 = (EaseManager.__c.__9__4_35 = new EaseFunction(EaseManager.__c.__9._ToEaseFunction_b__4_35));
				}
				return arg_518_0;
			}
			}
		}

		internal static bool IsFlashEase(Ease ease)
		{
			switch (ease)
			{
			case Ease.Flash:
			case Ease.InFlash:
			case Ease.OutFlash:
			case Ease.InOutFlash:
				return true;
			default:
				return false;
			}
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Core.Easing
{
	public class EaseCurve
	{
		private readonly AnimationCurve _animCurve;

		public EaseCurve(AnimationCurve animCurve)
		{
			this._animCurve = animCurve;
		}

		public float Evaluate(float time, float duration, float unusedOvershoot, float unusedPeriod)
		{
			float time2 = this._animCurve[this._animCurve.length - 1].time;
			float num = time / duration;
			return this._animCurve.Evaluate(num * time2);
		}
	}
}

// Decompile from assembly: DOTween.dll

using System;
using UnityEngine;

namespace DG.Tweening.Core.Easing
{
	public static class Flash
	{
		public static float Ease(float time, float duration, float overshootOrAmplitude, float period)
		{
			int num = Mathf.CeilToInt(time / duration * overshootOrAmplitude);
			float num2 = duration / overshootOrAmplitude;
			time -= num2 * (float)(num - 1);
			float num3 = (float)((num % 2 != 0) ? 1 : (-1));
			if (num3 < 0f)
			{
				time -= num2;
			}
			float res = time * num3 / num2;
			return Flash.WeightedEase(overshootOrAmplitude, period, num, num2, num3, res);
		}

		public static float EaseIn(float time, float duration, float overshootOrAmplitude, float period)
		{
			int num = Mathf.CeilToInt(time / duration * overshootOrAmplitude);
			float num2 = duration / overshootOrAmplitude;
			time -= num2 * (float)(num - 1);
			float num3 = (float)((num % 2 != 0) ? 1 : (-1));
			if (num3 < 0f)
			{
				time -= num2;
			}
			time *= num3;
			float res = (time /= num2) * time;
			return Flash.WeightedEase(overshootOrAmplitude, period, num, num2, num3, res);
		}

		public static float EaseOut(float time, float duration, float overshootOrAmplitude, float period)
		{
			int num = Mathf.CeilToInt(time / duration * overshootOrAmplitude);
			float num2 = duration / overshootOrAmplitude;
			time -= num2 * (float)(num - 1);
			float num3 = (float)((num % 2 != 0) ? 1 : (-1));
			if (num3 < 0f)
			{
				time -= num2;
			}
			time *= num3;
			float res = -(time /= num2) * (time - 2f);
			return Flash.WeightedEase(overshootOrAmplitude, period, num, num2, num3, res);
		}

		public static float EaseInOut(float time, float duration, float overshootOrAmplitude, float period)
		{
			int num = Mathf.CeilToInt(time / duration * overshootOrAmplitude);
			float num2 = duration / overshootOrAmplitude;
			time -= num2 * (float)(num - 1);
			float num3 = (float)((num % 2 != 0) ? 1 : (-1));
			if (num3 < 0f)
			{
				time -= num2;
			}
			time *= num3;
			float res = ((time /= num2 * 0.5f) < 1f) ? (0.5f * time * time) : (-0.5f * ((time -= 1f) * (time - 2f) - 1f));
			return Flash.WeightedEase(overshootOrAmplitude, period, num, num2, num3, res);
		}

		private static float WeightedEase(float overshootOrAmplitude, float period, int stepIndex, float stepDuration, float dir, float res)
		{
			float num = 0f;
			float num2 = 0f;
			if (dir > 0f && (int)overshootOrAmplitude % 2 == 0)
			{
				stepIndex++;
			}
			else if (dir < 0f && (int)overshootOrAmplitude % 2 != 0)
			{
				stepIndex++;
			}
			if (period > 0f)
			{
				float num3 = (float)Math.Truncate((double)overshootOrAmplitude);
				num2 = overshootOrAmplitude - num3;
				if (num3 % 2f > 0f)
				{
					num2 = 1f - num2;
				}
				num2 = num2 * (float)stepIndex / overshootOrAmplitude;
				num = res * (overshootOrAmplitude - (float)stepIndex) / overshootOrAmplitude;
			}
			else if (period < 0f)
			{
				period = -period;
				num = res * (float)stepIndex / overshootOrAmplitude;
			}
			float num4 = num - res;
			res += num4 * period + num2;
			if (res > 1f)
			{
				res = 1f;
			}
			return res;
		}
	}
}

